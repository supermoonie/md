{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/同余方程.md","hash":"926e40eaf832a762a4631fcfb2714cb7a4815d55","modified":1589759969534},{"_id":"source/_posts/hexo.md","hash":"0ad5b8c18ed8c92b148d78b922f62ebae0fd5220","modified":1589759969530},{"_id":"source/_posts/Redis开发与运维.md","hash":"6db063c9ac28c89ca70e680bd1dd7b446b7304ea","modified":1589759969530},{"_id":"source/_posts/伪随机数生成算法.md","hash":"66c18c3f32373fb14612160e47cfb3ccd6c93fdd","modified":1589759969534},{"_id":"source/categories/index.md","hash":"51ff0ae81f57c8e58464c6fb32b430573aa33e22","modified":1589759969535},{"_id":"source/tags/index.md","hash":"4c5aeb7a632cb63bae0b5c187c8950fe6037463e","modified":1589759969537},{"_id":"source/about/index.md","hash":"65066b02c7fc7d7a14b61caa1d1492ade233010a","modified":1589759969535},{"_id":"source/_posts/算法导论.md","hash":"c749a4c29de567bff9772f5e876d277c00d959e9","modified":1589759969534}],"Category":[{"name":"数学","_id":"ckabq6gh700023fgr24tk3xh4"},{"name":"blog","_id":"ckabq6gha00043fgr1eir061j"},{"name":"数论","parent":"ckabq6gh700023fgr24tk3xh4","_id":"ckabq6ghb00063fgr9hct56pf"},{"name":"算法","_id":"ckabq6ghm000o3fgr32q81t1c"},{"name":"分布式组件","_id":"ckabq6ght000y3fgr41bo1amb"}],"Data":[],"Page":[{"title":"categories","date":"2020-04-18T03:43:49.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-04-18 11:43:49\ntype: \"categories\"\n---\n","updated":"2020-05-17T23:59:29.535Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckabq6ghj000k3fgrb24g4skc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-04-18T03:48:23.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-04-18 11:48:23\ntype: \"tags\"\n---\n","updated":"2020-05-17T23:59:29.537Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckabq6ghl000m3fgr7raugcdx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"About me","date":"2020-04-17T04:37:08.000Z","_content":":email: wangchao_mooniew@163.com\n\n![image-20200430162002758](/Users/moonie/Library/Application Support/typora-user-images/image-20200430162002758.png)\n\n","source":"about/index.md","raw":"---\ntitle: About me\ndate: 2020-04-17 12:37:08\n---\n:email: wangchao_mooniew@163.com\n\n![image-20200430162002758](/Users/moonie/Library/Application Support/typora-user-images/image-20200430162002758.png)\n\n","updated":"2020-05-17T23:59:29.535Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckabq6ghn000q3fgreybte9wt","content":"<p>:email: wangchao_mooniew@163.com</p>\n<p><img src=\"/Users/moonie/Library/Application Support/typora-user-images/image-20200430162002758.png\" alt=\"image-20200430162002758\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>:email: wangchao_mooniew@163.com</p>\n<p><img src=\"/Users/moonie/Library/Application Support/typora-user-images/image-20200430162002758.png\" alt=\"image-20200430162002758\"></p>\n"}],"Post":[{"title":"同余","date":"2020-04-28T00:03:31.000Z","_content":"\n## 一、相关概念\n\n**最大公约数：** 也称最大公因数、最大公因子，指两个或多个整数共有的约数中最大的一个，计作 (a, b)。\n**最小公倍数：** 两个或多个整数公有的倍数叫做公倍数，其中除 0 以外最小的公倍数就叫这几个整数的最小公倍数，计作 [a, b]。\n\n<!-- more -->\n\n**同余：** 给定一个正整数 $m$，如果用 $m$ 去除两个整数 $a$ 和 $b$ 所得的余数相同，我们就说 $a,\\;b$ 对模 $m$ 同余，计作 $a\\equiv b(mod\\;m)$. 如果余数不同，我们就说 $a,\\;b$ 对模 $m$ 不同余，计作 $a \\not\\equiv b(mod\\;m)$  \n\n## 二、同余定理\n\n1. 整数 $a,\\;b$ 对模 $m$ 同余的充分必要条件是 $m|a-b$ \n2. 如果 $a\\equiv b(mod\\;m),\\;\\alpha\\equiv \\beta(mod\\;m)$ ，则有\n   1. $ax+\\alpha y=bx+\\beta y(mod\\;m)$ ，其中 $x,\\;y$ 为任意整数\n   2. $a\\alpha=b\\beta(mod\\;m)$ \n   3. $a^n=b^n(mod\\;m)$ ，其中 $n > 0$ \n   4. $f(a)=f(b)(mod\\;m)$ ，其中 $f(x)$ 为任意给定的整系数多项式\n3. 若 $ac=bc(mod\\;m)$ ，且若 $(m,\\;c)=d$ ，则 $a\\equiv b(mod\\;\\frac{m}{d})$ \n4. 若 $a\\equiv b(mod\\;m_i),\\;i=1,2,\\cdots,n$ ，则 $a\\equiv b(mod\\;[m1,\\cdots,m_n])$ \n\n## 三、一次不定方程\n\n二元一次不定方程是指\n$$\na_1x+a_2y=n \\tag{1}\n$$\n其中 $a_1,a_2,n$ 是给定的整数，$a_1a_2\\neq0$ 则有：\n\n1. 方程(1)有整数解$x,\\;y$ 的充分必要条件是$(a_1,\\;a_2)|n$ \n\n2. 设 $(a_1,\\;a_2)=1$ ，则(1)的全部解可表为 $x=x_0+a_2t,\\;y=y_0-a_1t$ ，其中 $x_0,y_0$ 为(1)的一组解，$t$ 为任意整数\n\n3. 设 $s\\geq2,\\;s$ 元一次不定方程 \n   $$\n   a_1x_1+a_2x_2+\\cdots+a_sx_s=n,a_1\\cdots a_s\\neq0 \\tag {2}\n   $$\n   有整数解$x_1,\\cdots,x_s$ 的充分必要条件是$(a_1,\\cdots,a_s)|n$ \n\n4. 在$n\\gt a_1a_2$ 时，(2) 有正整数解$x_1\\gt 0,\\;x_2\\gt 0$ ，但在$(a_1,a_2)=1,\\;n=a_1a_2$ 时，(2) 没有正整数解 $x_2\\gt0,x_2\\gt 0$ \n\n## 三、欧几里得算法（辗转相除法）\n\n定理：设 $a,b,c$ 是任意三个不全为零的整数，且$a=bq+c$ ，其中$q$ 是整数，则$(a,b)=(b,c)$ \n\n公式表示为：\n$$\ngcd(a,\\;b)=gcd(b,a\\;mod\\;b)\n$$\n算法表示：\n\n```c\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n\n## 四、扩展欧几里得算法\n\n基本算法：对于不完全为 0 的非负整数$a, \\; b, \\; gcd(a, b)$ 表示 $a, \\; b$ 的最大公约数，必然存在整数对 $x, y$，使得 $ax + by = gcd(a, b)$ \n\n证明：\n\n1. 当 $b=0,\\;gcd(a,b)=a$ ，此时 $x=1,\\;y=0$ \n\n2. $ab\\neq0$ 时，设$ax_1+by_1=gcd(a,b),\\;bx_2+(a\\;mod\\;b)y_2=gcd(b, a\\;modb)$ 根据欧几里得原理有\n$$\n   ax_1+by_1=bx_2+(a\\;mod\\;b)y_2=bx_2+(a-(a/b)*b)y_2=ay_2+bx_2-(a/b)*by_2\n   $$\n   根据恒等定理得：$x_1=y_2,\\;y_1=x_2-(a/b)*y_2$  ，这样就得到了求解$x_1,y_1$ 基于$x_2,y_2$ ，由递归思想即可求解\n\n算法表示：\n\n```c\nint exgcd(int a, int b, int &x, int &y){\n    if(b == 0){\n        x = 1; y = 0;\n        return a;\n    }\n    int result = exgcd(b, a%b, x, y);\n    int tp = x;\n    x = y;\n    y = tp - a/b*y;\n    return result;\n}\n```\n\n","source":"_posts/同余方程.md","raw":"---\ntitle: 同余\ndate: 2020-04-28 08:03:31\ntags:\n- 同余\n- 一次不定方程\n- 欧几里得\n- 算法\ncategories:\n- 数学\n- 数论\n---\n\n## 一、相关概念\n\n**最大公约数：** 也称最大公因数、最大公因子，指两个或多个整数共有的约数中最大的一个，计作 (a, b)。\n**最小公倍数：** 两个或多个整数公有的倍数叫做公倍数，其中除 0 以外最小的公倍数就叫这几个整数的最小公倍数，计作 [a, b]。\n\n<!-- more -->\n\n**同余：** 给定一个正整数 $m$，如果用 $m$ 去除两个整数 $a$ 和 $b$ 所得的余数相同，我们就说 $a,\\;b$ 对模 $m$ 同余，计作 $a\\equiv b(mod\\;m)$. 如果余数不同，我们就说 $a,\\;b$ 对模 $m$ 不同余，计作 $a \\not\\equiv b(mod\\;m)$  \n\n## 二、同余定理\n\n1. 整数 $a,\\;b$ 对模 $m$ 同余的充分必要条件是 $m|a-b$ \n2. 如果 $a\\equiv b(mod\\;m),\\;\\alpha\\equiv \\beta(mod\\;m)$ ，则有\n   1. $ax+\\alpha y=bx+\\beta y(mod\\;m)$ ，其中 $x,\\;y$ 为任意整数\n   2. $a\\alpha=b\\beta(mod\\;m)$ \n   3. $a^n=b^n(mod\\;m)$ ，其中 $n > 0$ \n   4. $f(a)=f(b)(mod\\;m)$ ，其中 $f(x)$ 为任意给定的整系数多项式\n3. 若 $ac=bc(mod\\;m)$ ，且若 $(m,\\;c)=d$ ，则 $a\\equiv b(mod\\;\\frac{m}{d})$ \n4. 若 $a\\equiv b(mod\\;m_i),\\;i=1,2,\\cdots,n$ ，则 $a\\equiv b(mod\\;[m1,\\cdots,m_n])$ \n\n## 三、一次不定方程\n\n二元一次不定方程是指\n$$\na_1x+a_2y=n \\tag{1}\n$$\n其中 $a_1,a_2,n$ 是给定的整数，$a_1a_2\\neq0$ 则有：\n\n1. 方程(1)有整数解$x,\\;y$ 的充分必要条件是$(a_1,\\;a_2)|n$ \n\n2. 设 $(a_1,\\;a_2)=1$ ，则(1)的全部解可表为 $x=x_0+a_2t,\\;y=y_0-a_1t$ ，其中 $x_0,y_0$ 为(1)的一组解，$t$ 为任意整数\n\n3. 设 $s\\geq2,\\;s$ 元一次不定方程 \n   $$\n   a_1x_1+a_2x_2+\\cdots+a_sx_s=n,a_1\\cdots a_s\\neq0 \\tag {2}\n   $$\n   有整数解$x_1,\\cdots,x_s$ 的充分必要条件是$(a_1,\\cdots,a_s)|n$ \n\n4. 在$n\\gt a_1a_2$ 时，(2) 有正整数解$x_1\\gt 0,\\;x_2\\gt 0$ ，但在$(a_1,a_2)=1,\\;n=a_1a_2$ 时，(2) 没有正整数解 $x_2\\gt0,x_2\\gt 0$ \n\n## 三、欧几里得算法（辗转相除法）\n\n定理：设 $a,b,c$ 是任意三个不全为零的整数，且$a=bq+c$ ，其中$q$ 是整数，则$(a,b)=(b,c)$ \n\n公式表示为：\n$$\ngcd(a,\\;b)=gcd(b,a\\;mod\\;b)\n$$\n算法表示：\n\n```c\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n\n## 四、扩展欧几里得算法\n\n基本算法：对于不完全为 0 的非负整数$a, \\; b, \\; gcd(a, b)$ 表示 $a, \\; b$ 的最大公约数，必然存在整数对 $x, y$，使得 $ax + by = gcd(a, b)$ \n\n证明：\n\n1. 当 $b=0,\\;gcd(a,b)=a$ ，此时 $x=1,\\;y=0$ \n\n2. $ab\\neq0$ 时，设$ax_1+by_1=gcd(a,b),\\;bx_2+(a\\;mod\\;b)y_2=gcd(b, a\\;modb)$ 根据欧几里得原理有\n$$\n   ax_1+by_1=bx_2+(a\\;mod\\;b)y_2=bx_2+(a-(a/b)*b)y_2=ay_2+bx_2-(a/b)*by_2\n   $$\n   根据恒等定理得：$x_1=y_2,\\;y_1=x_2-(a/b)*y_2$  ，这样就得到了求解$x_1,y_1$ 基于$x_2,y_2$ ，由递归思想即可求解\n\n算法表示：\n\n```c\nint exgcd(int a, int b, int &x, int &y){\n    if(b == 0){\n        x = 1; y = 0;\n        return a;\n    }\n    int result = exgcd(b, a%b, x, y);\n    int tp = x;\n    x = y;\n    y = tp - a/b*y;\n    return result;\n}\n```\n\n","slug":"同余方程","published":1,"updated":"2020-05-17T23:59:29.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckabq6ggw00003fgrgb7xa4fk","content":"<h2 id=\"一、相关概念\"><a href=\"#一、相关概念\" class=\"headerlink\" title=\"一、相关概念\"></a>一、相关概念</h2><p><strong>最大公约数：</strong> 也称最大公因数、最大公因子，指两个或多个整数共有的约数中最大的一个，计作 (a, b)。<br><strong>最小公倍数：</strong> 两个或多个整数公有的倍数叫做公倍数，其中除 0 以外最小的公倍数就叫这几个整数的最小公倍数，计作 [a, b]。</p>\n<a id=\"more\"></a>\n<p><strong>同余：</strong> 给定一个正整数 $m$，如果用 $m$ 去除两个整数 $a$ 和 $b$ 所得的余数相同，我们就说 $a,\\;b$ 对模 $m$ 同余，计作 $a\\equiv b(mod\\;m)$. 如果余数不同，我们就说 $a,\\;b$ 对模 $m$ 不同余，计作 $a \\not\\equiv b(mod\\;m)$  </p>\n<h2 id=\"二、同余定理\"><a href=\"#二、同余定理\" class=\"headerlink\" title=\"二、同余定理\"></a>二、同余定理</h2><ol>\n<li>整数 $a,\\;b$ 对模 $m$ 同余的充分必要条件是 $m|a-b$ </li>\n<li>如果 $a\\equiv b(mod\\;m),\\;\\alpha\\equiv \\beta(mod\\;m)$ ，则有<ol>\n<li>$ax+\\alpha y=bx+\\beta y(mod\\;m)$ ，其中 $x,\\;y$ 为任意整数</li>\n<li>$a\\alpha=b\\beta(mod\\;m)$ </li>\n<li>$a^n=b^n(mod\\;m)$ ，其中 $n &gt; 0$ </li>\n<li>$f(a)=f(b)(mod\\;m)$ ，其中 $f(x)$ 为任意给定的整系数多项式</li>\n</ol>\n</li>\n<li>若 $ac=bc(mod\\;m)$ ，且若 $(m,\\;c)=d$ ，则 $a\\equiv b(mod\\;\\frac{m}{d})$ </li>\n<li>若 $a\\equiv b(mod\\;m_i),\\;i=1,2,\\cdots,n$ ，则 $a\\equiv b(mod\\;[m1,\\cdots,m_n])$ </li>\n</ol>\n<h2 id=\"三、一次不定方程\"><a href=\"#三、一次不定方程\" class=\"headerlink\" title=\"三、一次不定方程\"></a>三、一次不定方程</h2><p>二元一次不定方程是指</p>\n<script type=\"math/tex; mode=display\">\na_1x+a_2y=n \\tag{1}</script><p>其中 $a_1,a_2,n$ 是给定的整数，$a_1a_2\\neq0$ 则有：</p>\n<ol>\n<li><p>方程(1)有整数解$x,\\;y$ 的充分必要条件是$(a_1,\\;a_2)|n$ </p>\n</li>\n<li><p>设 $(a_1,\\;a_2)=1$ ，则(1)的全部解可表为 $x=x_0+a_2t,\\;y=y_0-a_1t$ ，其中 $x_0,y_0$ 为(1)的一组解，$t$ 为任意整数</p>\n</li>\n<li><p>设 $s\\geq2,\\;s$ 元一次不定方程 </p>\n<script type=\"math/tex; mode=display\">\na_1x_1+a_2x_2+\\cdots+a_sx_s=n,a_1\\cdots a_s\\neq0 \\tag {2}</script><p>有整数解$x_1,\\cdots,x_s$ 的充分必要条件是$(a_1,\\cdots,a_s)|n$ </p>\n</li>\n<li><p>在$n\\gt a_1a_2$ 时，(2) 有正整数解$x_1\\gt 0,\\;x_2\\gt 0$ ，但在$(a_1,a_2)=1,\\;n=a_1a_2$ 时，(2) 没有正整数解 $x_2\\gt0,x_2\\gt 0$ </p>\n</li>\n</ol>\n<h2 id=\"三、欧几里得算法（辗转相除法）\"><a href=\"#三、欧几里得算法（辗转相除法）\" class=\"headerlink\" title=\"三、欧几里得算法（辗转相除法）\"></a>三、欧几里得算法（辗转相除法）</h2><p>定理：设 $a,b,c$ 是任意三个不全为零的整数，且$a=bq+c$ ，其中$q$ 是整数，则$(a,b)=(b,c)$ </p>\n<p>公式表示为：</p>\n<script type=\"math/tex; mode=display\">\ngcd(a,\\;b)=gcd(b,a\\;mod\\;b)</script><p>算法表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b == <span class=\"number\">0</span> ? a : gcd(b, a % b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、扩展欧几里得算法\"><a href=\"#四、扩展欧几里得算法\" class=\"headerlink\" title=\"四、扩展欧几里得算法\"></a>四、扩展欧几里得算法</h2><p>基本算法：对于不完全为 0 的非负整数$a, \\; b, \\; gcd(a, b)$ 表示 $a, \\; b$ 的最大公约数，必然存在整数对 $x, y$，使得 $ax + by = gcd(a, b)$ </p>\n<p>证明：</p>\n<ol>\n<li><p>当 $b=0,\\;gcd(a,b)=a$ ，此时 $x=1,\\;y=0$ </p>\n</li>\n<li><p>$ab\\neq0$ 时，设$ax_1+by_1=gcd(a,b),\\;bx_2+(a\\;mod\\;b)y_2=gcd(b, a\\;modb)$ 根据欧几里得原理有</p>\n<script type=\"math/tex; mode=display\">\nax_1+by_1=bx_2+(a\\;mod\\;b)y_2=bx_2+(a-(a/b)*b)y_2=ay_2+bx_2-(a/b)*by_2</script><p>根据恒等定理得：$x_1=y_2,\\;y_1=x_2-(a/b)*y_2$  ，这样就得到了求解$x_1,y_1$ 基于$x_2,y_2$ ，由递归思想即可求解</p>\n</li>\n</ol>\n<p>算法表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">exgcd</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        x = <span class=\"number\">1</span>; y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = exgcd(b, a%b, x, y);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = tp - a/b*y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、相关概念\"><a href=\"#一、相关概念\" class=\"headerlink\" title=\"一、相关概念\"></a>一、相关概念</h2><p><strong>最大公约数：</strong> 也称最大公因数、最大公因子，指两个或多个整数共有的约数中最大的一个，计作 (a, b)。<br><strong>最小公倍数：</strong> 两个或多个整数公有的倍数叫做公倍数，其中除 0 以外最小的公倍数就叫这几个整数的最小公倍数，计作 [a, b]。</p>","more":"<p><strong>同余：</strong> 给定一个正整数 $m$，如果用 $m$ 去除两个整数 $a$ 和 $b$ 所得的余数相同，我们就说 $a,\\;b$ 对模 $m$ 同余，计作 $a\\equiv b(mod\\;m)$. 如果余数不同，我们就说 $a,\\;b$ 对模 $m$ 不同余，计作 $a \\not\\equiv b(mod\\;m)$  </p>\n<h2 id=\"二、同余定理\"><a href=\"#二、同余定理\" class=\"headerlink\" title=\"二、同余定理\"></a>二、同余定理</h2><ol>\n<li>整数 $a,\\;b$ 对模 $m$ 同余的充分必要条件是 $m|a-b$ </li>\n<li>如果 $a\\equiv b(mod\\;m),\\;\\alpha\\equiv \\beta(mod\\;m)$ ，则有<ol>\n<li>$ax+\\alpha y=bx+\\beta y(mod\\;m)$ ，其中 $x,\\;y$ 为任意整数</li>\n<li>$a\\alpha=b\\beta(mod\\;m)$ </li>\n<li>$a^n=b^n(mod\\;m)$ ，其中 $n &gt; 0$ </li>\n<li>$f(a)=f(b)(mod\\;m)$ ，其中 $f(x)$ 为任意给定的整系数多项式</li>\n</ol>\n</li>\n<li>若 $ac=bc(mod\\;m)$ ，且若 $(m,\\;c)=d$ ，则 $a\\equiv b(mod\\;\\frac{m}{d})$ </li>\n<li>若 $a\\equiv b(mod\\;m_i),\\;i=1,2,\\cdots,n$ ，则 $a\\equiv b(mod\\;[m1,\\cdots,m_n])$ </li>\n</ol>\n<h2 id=\"三、一次不定方程\"><a href=\"#三、一次不定方程\" class=\"headerlink\" title=\"三、一次不定方程\"></a>三、一次不定方程</h2><p>二元一次不定方程是指</p>\n<script type=\"math/tex; mode=display\">\na_1x+a_2y=n \\tag{1}</script><p>其中 $a_1,a_2,n$ 是给定的整数，$a_1a_2\\neq0$ 则有：</p>\n<ol>\n<li><p>方程(1)有整数解$x,\\;y$ 的充分必要条件是$(a_1,\\;a_2)|n$ </p>\n</li>\n<li><p>设 $(a_1,\\;a_2)=1$ ，则(1)的全部解可表为 $x=x_0+a_2t,\\;y=y_0-a_1t$ ，其中 $x_0,y_0$ 为(1)的一组解，$t$ 为任意整数</p>\n</li>\n<li><p>设 $s\\geq2,\\;s$ 元一次不定方程 </p>\n<script type=\"math/tex; mode=display\">\na_1x_1+a_2x_2+\\cdots+a_sx_s=n,a_1\\cdots a_s\\neq0 \\tag {2}</script><p>有整数解$x_1,\\cdots,x_s$ 的充分必要条件是$(a_1,\\cdots,a_s)|n$ </p>\n</li>\n<li><p>在$n\\gt a_1a_2$ 时，(2) 有正整数解$x_1\\gt 0,\\;x_2\\gt 0$ ，但在$(a_1,a_2)=1,\\;n=a_1a_2$ 时，(2) 没有正整数解 $x_2\\gt0,x_2\\gt 0$ </p>\n</li>\n</ol>\n<h2 id=\"三、欧几里得算法（辗转相除法）\"><a href=\"#三、欧几里得算法（辗转相除法）\" class=\"headerlink\" title=\"三、欧几里得算法（辗转相除法）\"></a>三、欧几里得算法（辗转相除法）</h2><p>定理：设 $a,b,c$ 是任意三个不全为零的整数，且$a=bq+c$ ，其中$q$ 是整数，则$(a,b)=(b,c)$ </p>\n<p>公式表示为：</p>\n<script type=\"math/tex; mode=display\">\ngcd(a,\\;b)=gcd(b,a\\;mod\\;b)</script><p>算法表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b == <span class=\"number\">0</span> ? a : gcd(b, a % b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、扩展欧几里得算法\"><a href=\"#四、扩展欧几里得算法\" class=\"headerlink\" title=\"四、扩展欧几里得算法\"></a>四、扩展欧几里得算法</h2><p>基本算法：对于不完全为 0 的非负整数$a, \\; b, \\; gcd(a, b)$ 表示 $a, \\; b$ 的最大公约数，必然存在整数对 $x, y$，使得 $ax + by = gcd(a, b)$ </p>\n<p>证明：</p>\n<ol>\n<li><p>当 $b=0,\\;gcd(a,b)=a$ ，此时 $x=1,\\;y=0$ </p>\n</li>\n<li><p>$ab\\neq0$ 时，设$ax_1+by_1=gcd(a,b),\\;bx_2+(a\\;mod\\;b)y_2=gcd(b, a\\;modb)$ 根据欧几里得原理有</p>\n<script type=\"math/tex; mode=display\">\nax_1+by_1=bx_2+(a\\;mod\\;b)y_2=bx_2+(a-(a/b)*b)y_2=ay_2+bx_2-(a/b)*by_2</script><p>根据恒等定理得：$x_1=y_2,\\;y_1=x_2-(a/b)*y_2$  ，这样就得到了求解$x_1,y_1$ 基于$x_2,y_2$ ，由递归思想即可求解</p>\n</li>\n</ol>\n<p>算法表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">exgcd</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> &amp;x, <span class=\"keyword\">int</span> &amp;y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        x = <span class=\"number\">1</span>; y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = exgcd(b, a%b, x, y);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = tp - a/b*y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"hexo","date":"2020-04-26T23:41:44.000Z","_content":"\n## 特殊字符编码\n\n```toml\n- &#45; &minus; 减号\n! &#33; 感叹号\n\" &#34; &quot; 双引号\n# &#35; 井号\n$ &#36; 美元符号\n% &#37; 百分号\n& &#38; &amp; &\n' &#39; 单引号\n( &#40; 左小括号\n) &#41; 右小括号\n* &#42; 星号\n+ &#43; 加号\n< &#60; &lt; 左尖括号\n= &#61; 等号\n> &#62; &gt; 右尖括号\n? &#63; 问好\n@ &#64; at\n[ &#91; 左中括号\n\\ &#92; 反斜线\n] &#93; 右中括号\n{ &#123; 坐大括号\n| &#124; 竖线\n} &#125; 右大括号\n```\n\n","source":"_posts/hexo.md","raw":"---\ntitle: hexo\ndate: 2020-04-27 07:41:44\ntags:\n- hexo\n- markdown\ncategories:\n- blog\n---\n\n## 特殊字符编码\n\n```toml\n- &#45; &minus; 减号\n! &#33; 感叹号\n\" &#34; &quot; 双引号\n# &#35; 井号\n$ &#36; 美元符号\n% &#37; 百分号\n& &#38; &amp; &\n' &#39; 单引号\n( &#40; 左小括号\n) &#41; 右小括号\n* &#42; 星号\n+ &#43; 加号\n< &#60; &lt; 左尖括号\n= &#61; 等号\n> &#62; &gt; 右尖括号\n? &#63; 问好\n@ &#64; at\n[ &#91; 左中括号\n\\ &#92; 反斜线\n] &#93; 右中括号\n{ &#123; 坐大括号\n| &#124; 竖线\n} &#125; 右大括号\n```\n\n","slug":"hexo","published":1,"updated":"2020-05-17T23:59:29.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckabq6gh400013fgr48642rg8","content":"<h2 id=\"特殊字符编码\"><a href=\"#特殊字符编码\" class=\"headerlink\" title=\"特殊字符编码\"></a>特殊字符编码</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- &amp;#45; &amp;minus; 减号</span><br><span class=\"line\">! &amp;#33; 感叹号</span><br><span class=\"line\">\" &amp;#34; &amp;quot; 双引号</span><br><span class=\"line\"><span class=\"comment\"># &amp;#35; 井号</span></span><br><span class=\"line\">$ &amp;#36; 美元符号</span><br><span class=\"line\">% &amp;#37; 百分号</span><br><span class=\"line\">&amp; &amp;#38; &amp;amp; &amp;</span><br><span class=\"line\">' &amp;#39; 单引号</span><br><span class=\"line\">( &amp;#40; 左小括号</span><br><span class=\"line\">) &amp;#41; 右小括号</span><br><span class=\"line\">* &amp;#42; 星号</span><br><span class=\"line\">+ &amp;#43; 加号</span><br><span class=\"line\">&lt; &amp;#60; &amp;lt; 左尖括号</span><br><span class=\"line\">= &amp;#61; 等号</span><br><span class=\"line\">&gt; &amp;#62; &amp;gt; 右尖括号</span><br><span class=\"line\">? &amp;#63; 问好</span><br><span class=\"line\">@ &amp;#64; at</span><br><span class=\"line\"><span class=\"section\">[ &amp;#91; 左中括号</span></span><br><span class=\"line\"><span class=\"section\">\\ &amp;#92; 反斜线</span></span><br><span class=\"line\">] &amp;#93; 右中括号</span><br><span class=\"line\">&#123; &amp;#123; 坐大括号</span><br><span class=\"line\">| &amp;#124; 竖线</span><br><span class=\"line\">&#125; &amp;#125; 右大括号</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"特殊字符编码\"><a href=\"#特殊字符编码\" class=\"headerlink\" title=\"特殊字符编码\"></a>特殊字符编码</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- &amp;#45; &amp;minus; 减号</span><br><span class=\"line\">! &amp;#33; 感叹号</span><br><span class=\"line\">\" &amp;#34; &amp;quot; 双引号</span><br><span class=\"line\"><span class=\"comment\"># &amp;#35; 井号</span></span><br><span class=\"line\">$ &amp;#36; 美元符号</span><br><span class=\"line\">% &amp;#37; 百分号</span><br><span class=\"line\">&amp; &amp;#38; &amp;amp; &amp;</span><br><span class=\"line\">' &amp;#39; 单引号</span><br><span class=\"line\">( &amp;#40; 左小括号</span><br><span class=\"line\">) &amp;#41; 右小括号</span><br><span class=\"line\">* &amp;#42; 星号</span><br><span class=\"line\">+ &amp;#43; 加号</span><br><span class=\"line\">&lt; &amp;#60; &amp;lt; 左尖括号</span><br><span class=\"line\">= &amp;#61; 等号</span><br><span class=\"line\">&gt; &amp;#62; &amp;gt; 右尖括号</span><br><span class=\"line\">? &amp;#63; 问好</span><br><span class=\"line\">@ &amp;#64; at</span><br><span class=\"line\"><span class=\"section\">[ &amp;#91; 左中括号</span></span><br><span class=\"line\"><span class=\"section\">\\ &amp;#92; 反斜线</span></span><br><span class=\"line\">] &amp;#93; 右中括号</span><br><span class=\"line\">&#123; &amp;#123; 坐大括号</span><br><span class=\"line\">| &amp;#124; 竖线</span><br><span class=\"line\">&#125; &amp;#125; 右大括号</span><br></pre></td></tr></table></figure>\n"},{"title":"算法导论","date":"2020-04-20T09:41:44.000Z","_content":"\n## 第一部分 基础知识\n\n### 第 2 章 算法基础\n\n#### 2.1 插入排序\n\n![algorithm_introduction_02](https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_02.png)\n\n<!-- more -->\n\n#### 2.2 算法分析\n\n- 运行时间：基本操作数或步数\n- 最坏情况与平均情况分析\n- 增长量级 \n\n#### 2.3 设计算法\n\n分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。\n\n每层递归都有三个步骤：\n\n1. 分解原问题为若干子问题\n2. 解决这些子问题\n3. 合并这些子问题的解成原问题的解\n\n![algorithm_introduction_03](https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_03.png)\n\n### 第 3 章 函数的增长\n\n### 第 4 章 分治策略\n\n三种求解递归式的方法：\n- 代入法：猜测一个界，然后用数学归纳法证明这个界是正确的\n- 递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价\n- 主方法：可求解如下公式的递归式的界：\n  $$\n  T(n) = aT(n/b) + f(n)\n  $$\n  其中 $a \\ge 1, b \\gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。\n\n#### 4.1 最大字数组问题\n- 暴力求解算法\n  两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ \n- 分治策略求解算法\n  将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：\n  - 左字数组\n  - 右字数组\n  - 跨越中点的字数组\n\n  ![algorithm_introduction_04](https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_04.svg)\n\n### 第 5 章 堆排序\n\n\n\n![heap_sort](https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/heap_sort.svg)\n\n#### 5.1 建堆：\n\n1. 选取最后一个包含叶子结点的节点（n/2）\n2. 从n/2, (n/2 - 1), (n/2 - 2) ... 依次遍历至根节点\n3. 遍历的过程中与子节点进行比较，如果子节点大则进行交换并再次对此子节点进行堆调整\n\n#### 5.2 堆排序\n\n1. 建堆，使数组中的最大值位于根节点\n2. 将根节点与最后一个节点互换位置并去除\n3. 堆剩余的数组元素建堆\n4. 重复2，3 直至剩下最后一个元素\n\n#### 5.3 优先队列\n\n参考Java的`PriorityQueue` \n\n### 第 6 章 快速排序\n\n\n\n","source":"_posts/算法导论.md","raw":"---\ntitle: 算法导论\ndate: 2020-04-20 17:41:44\ntags: 算法\ncategories:\n- 算法\n---\n\n## 第一部分 基础知识\n\n### 第 2 章 算法基础\n\n#### 2.1 插入排序\n\n![algorithm_introduction_02](https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_02.png)\n\n<!-- more -->\n\n#### 2.2 算法分析\n\n- 运行时间：基本操作数或步数\n- 最坏情况与平均情况分析\n- 增长量级 \n\n#### 2.3 设计算法\n\n分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。\n\n每层递归都有三个步骤：\n\n1. 分解原问题为若干子问题\n2. 解决这些子问题\n3. 合并这些子问题的解成原问题的解\n\n![algorithm_introduction_03](https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_03.png)\n\n### 第 3 章 函数的增长\n\n### 第 4 章 分治策略\n\n三种求解递归式的方法：\n- 代入法：猜测一个界，然后用数学归纳法证明这个界是正确的\n- 递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价\n- 主方法：可求解如下公式的递归式的界：\n  $$\n  T(n) = aT(n/b) + f(n)\n  $$\n  其中 $a \\ge 1, b \\gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。\n\n#### 4.1 最大字数组问题\n- 暴力求解算法\n  两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ \n- 分治策略求解算法\n  将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：\n  - 左字数组\n  - 右字数组\n  - 跨越中点的字数组\n\n  ![algorithm_introduction_04](https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_04.svg)\n\n### 第 5 章 堆排序\n\n\n\n![heap_sort](https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/heap_sort.svg)\n\n#### 5.1 建堆：\n\n1. 选取最后一个包含叶子结点的节点（n/2）\n2. 从n/2, (n/2 - 1), (n/2 - 2) ... 依次遍历至根节点\n3. 遍历的过程中与子节点进行比较，如果子节点大则进行交换并再次对此子节点进行堆调整\n\n#### 5.2 堆排序\n\n1. 建堆，使数组中的最大值位于根节点\n2. 将根节点与最后一个节点互换位置并去除\n3. 堆剩余的数组元素建堆\n4. 重复2，3 直至剩下最后一个元素\n\n#### 5.3 优先队列\n\n参考Java的`PriorityQueue` \n\n### 第 6 章 快速排序\n\n\n\n","slug":"算法导论","published":1,"updated":"2020-05-17T23:59:29.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckabq6ghk000l3fgrcyz4fqg3","content":"<h2 id=\"第一部分-基础知识\"><a href=\"#第一部分-基础知识\" class=\"headerlink\" title=\"第一部分 基础知识\"></a>第一部分 基础知识</h2><h3 id=\"第-2-章-算法基础\"><a href=\"#第-2-章-算法基础\" class=\"headerlink\" title=\"第 2 章 算法基础\"></a>第 2 章 算法基础</h3><h4 id=\"2-1-插入排序\"><a href=\"#2-1-插入排序\" class=\"headerlink\" title=\"2.1 插入排序\"></a>2.1 插入排序</h4><p><img src=\"https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_02.png\" alt=\"algorithm_introduction_02\"></p>\n<a id=\"more\"></a>\n<h4 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h4><ul>\n<li>运行时间：基本操作数或步数</li>\n<li>最坏情况与平均情况分析</li>\n<li>增长量级 </li>\n</ul>\n<h4 id=\"2-3-设计算法\"><a href=\"#2-3-设计算法\" class=\"headerlink\" title=\"2.3 设计算法\"></a>2.3 设计算法</h4><p>分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>\n<p>每层递归都有三个步骤：</p>\n<ol>\n<li>分解原问题为若干子问题</li>\n<li>解决这些子问题</li>\n<li>合并这些子问题的解成原问题的解</li>\n</ol>\n<p><img src=\"https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_03.png\" alt=\"algorithm_introduction_03\"></p>\n<h3 id=\"第-3-章-函数的增长\"><a href=\"#第-3-章-函数的增长\" class=\"headerlink\" title=\"第 3 章 函数的增长\"></a>第 3 章 函数的增长</h3><h3 id=\"第-4-章-分治策略\"><a href=\"#第-4-章-分治策略\" class=\"headerlink\" title=\"第 4 章 分治策略\"></a>第 4 章 分治策略</h3><p>三种求解递归式的方法：</p>\n<ul>\n<li>代入法：猜测一个界，然后用数学归纳法证明这个界是正确的</li>\n<li>递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价</li>\n<li>主方法：可求解如下公式的递归式的界：<script type=\"math/tex; mode=display\">\nT(n) = aT(n/b) + f(n)</script>其中 $a \\ge 1, b \\gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。</li>\n</ul>\n<h4 id=\"4-1-最大字数组问题\"><a href=\"#4-1-最大字数组问题\" class=\"headerlink\" title=\"4.1 最大字数组问题\"></a>4.1 最大字数组问题</h4><ul>\n<li>暴力求解算法<br>两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ </li>\n<li><p>分治策略求解算法<br>将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：</p>\n<ul>\n<li>左字数组</li>\n<li>右字数组</li>\n<li>跨越中点的字数组</li>\n</ul>\n<p><img src=\"https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_04.svg\" alt=\"algorithm_introduction_04\"></p>\n</li>\n</ul>\n<h3 id=\"第-5-章-堆排序\"><a href=\"#第-5-章-堆排序\" class=\"headerlink\" title=\"第 5 章 堆排序\"></a>第 5 章 堆排序</h3><p><img src=\"https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/heap_sort.svg\" alt=\"heap_sort\"></p>\n<h4 id=\"5-1-建堆：\"><a href=\"#5-1-建堆：\" class=\"headerlink\" title=\"5.1 建堆：\"></a>5.1 建堆：</h4><ol>\n<li>选取最后一个包含叶子结点的节点（n/2）</li>\n<li>从n/2, (n/2 - 1), (n/2 - 2) … 依次遍历至根节点</li>\n<li>遍历的过程中与子节点进行比较，如果子节点大则进行交换并再次对此子节点进行堆调整</li>\n</ol>\n<h4 id=\"5-2-堆排序\"><a href=\"#5-2-堆排序\" class=\"headerlink\" title=\"5.2 堆排序\"></a>5.2 堆排序</h4><ol>\n<li>建堆，使数组中的最大值位于根节点</li>\n<li>将根节点与最后一个节点互换位置并去除</li>\n<li>堆剩余的数组元素建堆</li>\n<li>重复2，3 直至剩下最后一个元素</li>\n</ol>\n<h4 id=\"5-3-优先队列\"><a href=\"#5-3-优先队列\" class=\"headerlink\" title=\"5.3 优先队列\"></a>5.3 优先队列</h4><p>参考Java的<code>PriorityQueue</code> </p>\n<h3 id=\"第-6-章-快速排序\"><a href=\"#第-6-章-快速排序\" class=\"headerlink\" title=\"第 6 章 快速排序\"></a>第 6 章 快速排序</h3>","site":{"data":{}},"excerpt":"<h2 id=\"第一部分-基础知识\"><a href=\"#第一部分-基础知识\" class=\"headerlink\" title=\"第一部分 基础知识\"></a>第一部分 基础知识</h2><h3 id=\"第-2-章-算法基础\"><a href=\"#第-2-章-算法基础\" class=\"headerlink\" title=\"第 2 章 算法基础\"></a>第 2 章 算法基础</h3><h4 id=\"2-1-插入排序\"><a href=\"#2-1-插入排序\" class=\"headerlink\" title=\"2.1 插入排序\"></a>2.1 插入排序</h4><p><img src=\"https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_02.png\" alt=\"algorithm_introduction_02\"></p>","more":"<h4 id=\"2-2-算法分析\"><a href=\"#2-2-算法分析\" class=\"headerlink\" title=\"2.2 算法分析\"></a>2.2 算法分析</h4><ul>\n<li>运行时间：基本操作数或步数</li>\n<li>最坏情况与平均情况分析</li>\n<li>增长量级 </li>\n</ul>\n<h4 id=\"2-3-设计算法\"><a href=\"#2-3-设计算法\" class=\"headerlink\" title=\"2.3 设计算法\"></a>2.3 设计算法</h4><p>分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>\n<p>每层递归都有三个步骤：</p>\n<ol>\n<li>分解原问题为若干子问题</li>\n<li>解决这些子问题</li>\n<li>合并这些子问题的解成原问题的解</li>\n</ol>\n<p><img src=\"https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_03.png\" alt=\"algorithm_introduction_03\"></p>\n<h3 id=\"第-3-章-函数的增长\"><a href=\"#第-3-章-函数的增长\" class=\"headerlink\" title=\"第 3 章 函数的增长\"></a>第 3 章 函数的增长</h3><h3 id=\"第-4-章-分治策略\"><a href=\"#第-4-章-分治策略\" class=\"headerlink\" title=\"第 4 章 分治策略\"></a>第 4 章 分治策略</h3><p>三种求解递归式的方法：</p>\n<ul>\n<li>代入法：猜测一个界，然后用数学归纳法证明这个界是正确的</li>\n<li>递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价</li>\n<li>主方法：可求解如下公式的递归式的界：<script type=\"math/tex; mode=display\">\nT(n) = aT(n/b) + f(n)</script>其中 $a \\ge 1, b \\gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。</li>\n</ul>\n<h4 id=\"4-1-最大字数组问题\"><a href=\"#4-1-最大字数组问题\" class=\"headerlink\" title=\"4.1 最大字数组问题\"></a>4.1 最大字数组问题</h4><ul>\n<li>暴力求解算法<br>两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ </li>\n<li><p>分治策略求解算法<br>将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：</p>\n<ul>\n<li>左字数组</li>\n<li>右字数组</li>\n<li>跨越中点的字数组</li>\n</ul>\n<p><img src=\"https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/algorithm_introduction_04.svg\" alt=\"algorithm_introduction_04\"></p>\n</li>\n</ul>\n<h3 id=\"第-5-章-堆排序\"><a href=\"#第-5-章-堆排序\" class=\"headerlink\" title=\"第 5 章 堆排序\"></a>第 5 章 堆排序</h3><p><img src=\"https://assets-1253328229.cos.ap-shanghai.myqcloud.com/assets/heap_sort.svg\" alt=\"heap_sort\"></p>\n<h4 id=\"5-1-建堆：\"><a href=\"#5-1-建堆：\" class=\"headerlink\" title=\"5.1 建堆：\"></a>5.1 建堆：</h4><ol>\n<li>选取最后一个包含叶子结点的节点（n/2）</li>\n<li>从n/2, (n/2 - 1), (n/2 - 2) … 依次遍历至根节点</li>\n<li>遍历的过程中与子节点进行比较，如果子节点大则进行交换并再次对此子节点进行堆调整</li>\n</ol>\n<h4 id=\"5-2-堆排序\"><a href=\"#5-2-堆排序\" class=\"headerlink\" title=\"5.2 堆排序\"></a>5.2 堆排序</h4><ol>\n<li>建堆，使数组中的最大值位于根节点</li>\n<li>将根节点与最后一个节点互换位置并去除</li>\n<li>堆剩余的数组元素建堆</li>\n<li>重复2，3 直至剩下最后一个元素</li>\n</ol>\n<h4 id=\"5-3-优先队列\"><a href=\"#5-3-优先队列\" class=\"headerlink\" title=\"5.3 优先队列\"></a>5.3 优先队列</h4><p>参考Java的<code>PriorityQueue</code> </p>\n<h3 id=\"第-6-章-快速排序\"><a href=\"#第-6-章-快速排序\" class=\"headerlink\" title=\"第 6 章 快速排序\"></a>第 6 章 快速排序</h3>"},{"title":"伪随机数生成算法","date":"2020-04-27T04:27:26.000Z","_content":"\n# 伪随机数生成算法\n\n## 线性同余法（linear congruential generator, LCG）\n\n$$\n X_{(n+1)} = (aX_n + c) \\bmod m\n$$\n\n<!-- more -->\n\n其中，X 为伪随机序列，\n- $m,\\; m > 0$，模数，也是生成序列的最大周期\n- $a,\\; 0 < a < m$，乘数\n- $c,\\; 0 \\leq c < m$，增量\n- $X_0,\\; 0 \\leq X_0 < m$，种子点\n\n当 $c = 0$ 时，被称为 和同余法（multiplicative congruential generator, MCG），如果 $c \\neq 0$，被称为 乘同余法（mixed congruential generator）\n\n```java\npublic static class LinearCongruentialGenerator {\n\n    private double x = System.currentTimeMillis();\n\n    private double next() {\n        int m = 2 ^ 31;\n        int a = 48271;\n        int c = 0;\n        x = (a * x + c) % m;\n        return x / m;\n    }\n}\n```\n\n**线性同余的参数应该被小心选取**，否则生成的序列非常糟糕，比如当 $a = 11, c = 0, m = 8, X_0 = 1$ 时，得到的序列为 3、1、3、1、3、1、3... 要令LCG 达到最大周期，应符合以下条件：\n1. $A,\\; M$ 互质\n2. $M$ 的所有质因数都能整除 $A - 1$\n3. 若 $M$ 是4 的倍数， $A - 1$ 也是\n4. $A, \\; B, \\; N_0$ 都比 $M$ 小\n5. $A, \\; B$ 是正整数\n\n\n\n","source":"_posts/伪随机数生成算法.md","raw":"---\ntitle: 伪随机数生成算法\ndate: 2020-04-27 12:27:26\ntags:\n- 随机数\n- 算法\ncategories:\n- 算法\n---\n\n# 伪随机数生成算法\n\n## 线性同余法（linear congruential generator, LCG）\n\n$$\n X_{(n+1)} = (aX_n + c) \\bmod m\n$$\n\n<!-- more -->\n\n其中，X 为伪随机序列，\n- $m,\\; m > 0$，模数，也是生成序列的最大周期\n- $a,\\; 0 < a < m$，乘数\n- $c,\\; 0 \\leq c < m$，增量\n- $X_0,\\; 0 \\leq X_0 < m$，种子点\n\n当 $c = 0$ 时，被称为 和同余法（multiplicative congruential generator, MCG），如果 $c \\neq 0$，被称为 乘同余法（mixed congruential generator）\n\n```java\npublic static class LinearCongruentialGenerator {\n\n    private double x = System.currentTimeMillis();\n\n    private double next() {\n        int m = 2 ^ 31;\n        int a = 48271;\n        int c = 0;\n        x = (a * x + c) % m;\n        return x / m;\n    }\n}\n```\n\n**线性同余的参数应该被小心选取**，否则生成的序列非常糟糕，比如当 $a = 11, c = 0, m = 8, X_0 = 1$ 时，得到的序列为 3、1、3、1、3、1、3... 要令LCG 达到最大周期，应符合以下条件：\n1. $A,\\; M$ 互质\n2. $M$ 的所有质因数都能整除 $A - 1$\n3. 若 $M$ 是4 的倍数， $A - 1$ 也是\n4. $A, \\; B, \\; N_0$ 都比 $M$ 小\n5. $A, \\; B$ 是正整数\n\n\n\n","slug":"伪随机数生成算法","published":1,"updated":"2020-05-17T23:59:29.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckabq6ghl000n3fgr9i8zgrip","content":"<h1 id=\"伪随机数生成算法\"><a href=\"#伪随机数生成算法\" class=\"headerlink\" title=\"伪随机数生成算法\"></a>伪随机数生成算法</h1><h2 id=\"线性同余法（linear-congruential-generator-LCG）\"><a href=\"#线性同余法（linear-congruential-generator-LCG）\" class=\"headerlink\" title=\"线性同余法（linear congruential generator, LCG）\"></a>线性同余法（linear congruential generator, LCG）</h2><script type=\"math/tex; mode=display\">\n X_{(n+1)} = (aX_n + c) \\bmod m</script><a id=\"more\"></a>\n<p>其中，X 为伪随机序列，</p>\n<ul>\n<li>$m,\\; m &gt; 0$，模数，也是生成序列的最大周期</li>\n<li>$a,\\; 0 &lt; a &lt; m$，乘数</li>\n<li>$c,\\; 0 \\leq c &lt; m$，增量</li>\n<li>$X_0,\\; 0 \\leq X_0 &lt; m$，种子点</li>\n</ul>\n<p>当 $c = 0$ 时，被称为 和同余法（multiplicative congruential generator, MCG），如果 $c \\neq 0$，被称为 乘同余法（mixed congruential generator）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinearCongruentialGenerator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">double</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">2</span> ^ <span class=\"number\">31</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">48271</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        x = (a * x + c) % m;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x / m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>线性同余的参数应该被小心选取</strong>，否则生成的序列非常糟糕，比如当 $a = 11, c = 0, m = 8, X_0 = 1$ 时，得到的序列为 3、1、3、1、3、1、3… 要令LCG 达到最大周期，应符合以下条件：</p>\n<ol>\n<li>$A,\\; M$ 互质</li>\n<li>$M$ 的所有质因数都能整除 $A - 1$</li>\n<li>若 $M$ 是4 的倍数， $A - 1$ 也是</li>\n<li>$A, \\; B, \\; N_0$ 都比 $M$ 小</li>\n<li>$A, \\; B$ 是正整数</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"伪随机数生成算法\"><a href=\"#伪随机数生成算法\" class=\"headerlink\" title=\"伪随机数生成算法\"></a>伪随机数生成算法</h1><h2 id=\"线性同余法（linear-congruential-generator-LCG）\"><a href=\"#线性同余法（linear-congruential-generator-LCG）\" class=\"headerlink\" title=\"线性同余法（linear congruential generator, LCG）\"></a>线性同余法（linear congruential generator, LCG）</h2><script type=\"math/tex; mode=display\">\n X_{(n+1)} = (aX_n + c) \\bmod m</script>","more":"<p>其中，X 为伪随机序列，</p>\n<ul>\n<li>$m,\\; m &gt; 0$，模数，也是生成序列的最大周期</li>\n<li>$a,\\; 0 &lt; a &lt; m$，乘数</li>\n<li>$c,\\; 0 \\leq c &lt; m$，增量</li>\n<li>$X_0,\\; 0 \\leq X_0 &lt; m$，种子点</li>\n</ul>\n<p>当 $c = 0$ 时，被称为 和同余法（multiplicative congruential generator, MCG），如果 $c \\neq 0$，被称为 乘同余法（mixed congruential generator）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinearCongruentialGenerator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">double</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">2</span> ^ <span class=\"number\">31</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">48271</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        x = (a * x + c) % m;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x / m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>线性同余的参数应该被小心选取</strong>，否则生成的序列非常糟糕，比如当 $a = 11, c = 0, m = 8, X_0 = 1$ 时，得到的序列为 3、1、3、1、3、1、3… 要令LCG 达到最大周期，应符合以下条件：</p>\n<ol>\n<li>$A,\\; M$ 互质</li>\n<li>$M$ 的所有质因数都能整除 $A - 1$</li>\n<li>若 $M$ 是4 的倍数， $A - 1$ 也是</li>\n<li>$A, \\; B, \\; N_0$ 都比 $M$ 小</li>\n<li>$A, \\; B$ 是正整数</li>\n</ol>"},{"title":"Redis开发与运维","date":"2020-04-17T14:37:20.000Z","_content":"\n## 一、初识Redis\n\n### 1.1 Redis特性\n- 速度快：10万/秒\n- 基于键值对的数据结构服务器\n- 丰富的功能\n- 简单稳定\n- 客户端语言多\n- 持久化：RDB 和 AOF\n- 主从复制\n- 高可用和分布式\n<!--more-->\n\n### 1.2 用好Redis的建议\n1. 勿当作黑盒使用\n2. 阅读源码\n\n### 1.3 Redis 基本操作\n\n#### 1.3.1 配置、启动、操作、关闭\n\nRedis 可执行文件说明：\n\n| 可执行文件 | 作用 |\n|--|--|\n| redis-server | 启动Redis |\n| redis-cli | Redis 命令行客户端 |\n| redis-benchmark | Redis 基准测试工具 |\n| redis-check-aof | Redis AOF 持久化文件检测和修复工具 |\n| redis-check-dump | Redis RDB 持久化文件检测和修复工具 |\n| redis-sentinel | 启动 Redis Sentinel |\n\nRedis 基础配置：\n\n| 配置名 | 配置说明 |\n|--|--|\n| port | 端口 |\n| logfile | 日志文件 |\n| dir | Redis 工作目录（存放持久化文件和日志文件）|\n| daemonize | 是否以守护进程的方式启动Redis |\n\n停止 Redis 服务：\n`redis-cli shutdown` 用来停止Redis 服务，三点注意：\n- Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式\n- 除了`shutdown` 命令外，还可以通过`kill` 进程号的方式关掉Redis，但不可使用 `kill -9` 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。\n- `shutdown` 还有一个参数，代表是否在关闭Redis前，生成持久化文件：`redis-cli shutdown nosave|save`\n\n## 二、API的理解和使用\n\n### 2.1 全局命令\n\n| 命令 | 作用 |\n|--|--|\n| keys * | 查看所有键 |\n| dbsize | 键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量 |\n| exists key | 检查键是否存在 |\n| del key [key ...] | 删除键 |\n| expire key seconds | 键过期 |\n| ttl key | 查看键的过期时间 |\n| type key | 键的数据结构类型 |\n| object encoding key | 查询内部编码 |\n\n### 2.2 数据结构和内部编码\n\n```mermaid\n  graph TB\n    key --> string\n    key --> hash\n    key --> list\n    key --> set\n    key --> zset\n    string --> raw\n    string --> int\n    string --> embstr\n    hash --> hashtable_1[hashtable]\n    hash --> ziplist_1[ziplist]\n    list --> linkedlist\n    list --> ziplist_2[ziplist]\n    set --> hashtable_2[hashtable]\n    set --> intset\n    zset --> skiplist\n    zset --> ziplist_3[ziplist]\n```\n\nRedis这样设计的好处：\n- 可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势\n- 多种内部编码实现可以在不同场景下发挥各自的优势\n\n### 2.3 单线程架构\n单线程为什么这么快？\n  - 纯内存访问\n  - 非阻塞I/O\n  - 单线程避免了线程切换和竞态的消耗\n\n### 2.4 字符串\n\n#### 2.4.1 字符串类型常用命令\n| 命令 | 作用 |\n|--|--|\n| set key value [ex seconds] [px milliseconds] [nx xx] | 设置值 |\n| setnx | 存在设置失败 |\n| setex | 存在才能设置成功 |\n| get key | 获取值 |\n| mset key value [key value ...] | 批量设置值 |\n| mget key [key ...] | 批量获取值 |\n| incr key | 自增操作，值不是整数返回错误，键不存在按照 0 自增 |\n| decr key | 自减操作 |\n| incrby decrby incrbyfloat | 根据数值自增自减 |\n\n#### 2.4.2 字符串类型不常用命令\n| 命令 | 作用 |\n|--|--|\n| append key value | 追加值 |\n| strlen key | 字符串长度 |\n| getset key value | 设置并返回原值 |\n| setrange key offset value | 设置指定位置的字符 |\n| getrange key start end | 获取部分字符串 |\n\n#### 2.4.3 字符串内部编码\n  - int：8 个字节的长整型\n  - embstr：小于等于 39 个字节的字符串\n  - raw：大于 39 个字符的字符串\n\n### 2.5 哈希\n\n#### 2.5.1 哈希命令\n| 命令 | 作用 |\n|--|--|\n| hset key field value | 设置值 |\n| hget key field | 获取值 |\n| hdel key field [field ...] | 删除field |\n| hlen key | 计算field 个数 |\n| hmget key field [field ...] | 批量获取field-value |\n| hmset key field value [field value ...] | 批量设置field-value |\n| hexists key field | 判断field 是否存在 |\n| hkeys key | 获取所有field |\n| hvals key | 获取所有value |\n| hgetall key | 获取所有的field-value |\n| hincrby hincrbyfloat key field | field 自增 |\n| hstrlen key field | 计算value 的字符串长度 |\n\n#### 2.5.2 内部编码\n  - ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。\n  - hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。\n\n### 2.6 列表\n\n#### 2.6.1 列表的两个特点：\n  - 列表中的元素是有序的\n  - 列表中的元素可以是重复的\n\n#### 2.6.2 命令\n| 命令 | 作用 |\n|--|--|\n| rpush lpush key value [value ...] | 添加 |\n| linsert key (before after) pivot value | 插入 |\n| lrange key start end | 查找 |\n| lindex key index | 获取列表指定索引下表的元素 |\n| llen key | 获取列表长度 |\n| lpop rpop key | 弹出元素|\n| lrem key count value | 删除指定元素，count>0，从左到右；count<0从右到左 删除最多count个元素；count=0，删除所有|\n| ltrim key start end | 按照索引范围剪切列表 |\n| lset key index newValue | 修改 |\n| blpop brpop key [key ...] timeout | 阻塞操作 |\n\n#### 2.6.3 内部编码\n  - ziplist\n  - linkedlist\n\n#### 2.6.4 使用场景\n  - 消息队列\n  - 文章列表\n  - lpush + lpop = Stack（栈）\n  - lpush + rpop = Queue（队列）\n  - lpush + ltrim = Capped Collection（有限集合）\n  - lpush + brpop = Message Queue（消息队列）\n\n### 2.7 集合\n  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。\n\n#### 2.7.1 命令\n集合内操作：\n\n| 命令 | 作用 |\n|--|--|\n| sadd key ele [ele ...] | 添加元素 |\n| srem key ele [ele ...] | 删除元素 |\n| scard key | 计算元素个数 |\n| sismember key ele | 判断元素是否在集合中 |\n| srandmember key [count:1] | 随机从集合返回指定个数元素 |\n| spop key | 从集合随机弹出一个元素 |\n| smember key | 获取所有元素 |\n\n集合间操作：\n\n| 命令 | 作用 |\n|--|--|\n| sinter key [key ...] | 求多个结合的交集 |\n| suinon key [key ...] | 求多个结合的并集 |\n| sdiff key [key ...] | 求多个集合的差集 |\n| sinterstore sunionstore sdiffstore destination key [key ...] | 将交集、并集、差集的结果保存 |\n\n集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。\n\n#### 2.7.2 内部编码\n  - intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现\n  - hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现\n\n#### 2.7.3 使用场景\n  - 标签\n\n### 2.8 有序集合\n  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。\n\n#### 2.8.1 命令\n集合内：\n\n| 命令 | 作用 |\n|--|--|\n| zadd key score memeber [score memeber ...] | 添加成员 |\n| zcard key | 计算成员个数 |\n| zscore key member | 计算某个成员的分数 |\n| zrank zrevrank key member | 计算成员的排名 |\n| zrem key memeber [member ...] | 删除成员 |\n| zincrby key increment member | 增加成员的分数 |\n| zrange zrevrange key start end [withscores] | 返回指定排名范围的成员 |\n| zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count] | 返回指定分数范围的成员 |\n| zcount key min max | 返回指定分数范围成员个数 |\n| zremrangebyrank key start end | 删除指定排名内的升序元素 |\n| zremrangebyscore key min max | 删除指定分数范围的成员 |\n\nRedis3.2为zadd添加了nx、xx、ch、incr 四个选项：\n  - nx：member 必须不存在才能设置成功，用于添加\n  - xx：member 必须存在才能设置成功，用于更新\n  - ch：返回此次操作后，有序集合元素和分数变化的个数\n  - incr：对score做增加，相当于zincrby\n\n集合间的操作\n  - 交集：\n    `zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`\n    - destination：交集计算结果保存在这个键\n    - numkeys：需要做交集计算键的个数\n    - key[key ...]：需要做交集计算的键\n    - weights weight[weight ...]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1\n    - aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum\n  - 并集：\n    `zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`\n\n#### 2.8.2 内部编码\n  - ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现\n  - skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现\n\n#### 2.8.3 使用场景\n  - 点赞数\n  - 前十名\n  - 用户分数\n\n### 2.9 键管理\n\n#### 2.9.1 单个键管理\n| 命令 | 作用 |\n|--|--|\n| rename key newkey | 键重命名 |\n| renamenx key newkey | newkey 不存在时重命名 |\n| randomkey | 随机返回一个键 |\n| expire key seconds | 键在seconds 秒后过期 |\n| expireat key timestamp | 键在秒级时间戳timestamp 后过期 |\n| pexpire key milliseconds | 键在milliseconds 毫秒后过期 |\n| pexpireat key milliseconds-timestamp | 键在毫秒级时间戳timestamp 后过期 |\n| move key db | 键内部迁移 |\n| dump key | 键值序列化，采用RDB格式 |\n| restore key ttl value | 反序列化键值 |\n| migrate host port (key \"\") destination-db timeout [copy] [replace] [keys key [key ...]] | Redis 实例间进行数据迁移 |\n\nRedis过期命令注意点：\n  - expire key的键不存在，返回结果为 0\n  - 过期时间如果为负值，键会立即被删除\n  - persist 可以将键的过期时间清除\n  - 对于字符串类型键，set 命令会去掉过期时间\n  - Redis 不支持二级数据结构内部元素的过期功能\n  - setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间\n\nmigrate 参数：\n  - host：目标Redis 的IP地址\n  - port：目标Redis 的端口\n  - key|\"\"：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”\n  - destination：目标Redis 的数据库索引\n  - timeout：迁移的超时时间（毫秒）\n  - [copy]：添加后，迁移不删除源键\n  - [replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖\n  - [keys key[key ...]]：迁移多个键\n\n#### 2.9.2 遍历键\n- `keys pattern`：全量遍历键\n  keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：\n    - 在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制\n    - 如果确认键值总数确实比较少，可以执行该命令\n    - 使用scan 命令，可以有效防止阻塞\n- `scan cursor [match pattern] [count number]`：渐进式遍历\n  - curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束\n  - match pattern：可选参数，匹配正则\n  - count number：可选参数，每次要遍历的键个数，默认是 10\n\n除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan\n\n#### 2.9.3 数据库管理\n| 命令 | 作用 |\n|--|--|\n| select dbIndex | 切换数据库，Redis默认配置中有16个数据库 |\n| flushdb | 清除当前数据库 |\n| flushall | 清除所有数据库 |\n\n  **注意**：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：\n  - Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响\n  - 多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库\n  - 部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱\n\n## 三、小功能大用处\n\n### 3.1 慢查询分析\nRedis 提供了`slowlog-log-slower-than` 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数\n```shell\nconfig set slowlog-log-slower-than 20000\nconfig set slowlog-max-len 1000\nconfig rewrite\n# 获取慢查询日志\nslowlog get [n]\n# 获取慢查询日志列表当前的长度\nslowlog len\n# 慢查询日志重置\nslowlog reset\n```\n\n### 3.2 redis-cli 详解\n| 参数 | 作用 |\n|--|--|\n| -r | 命令执行多次 |\n| -i | 每隔几秒执行一次 |\n| -x | 从标准输入读取数据作为最后一个参数 |\n| -c | 连接Redis Cluster 节点时使用 |\n| -a | Redis 配置了命令时使用 |\n| --scan 和 --pattern | 用于扫描指定模式的键 |\n| --slave | 把当前客户端模拟成当前Redis 节点的从节点 |\n| --rdb | 请求Redis实例生成并发送RDB持久化文件保存到本地 |\n| --pipe | 批量执行Redis 命令 |\n| --bigkeys | 使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值 |\n| --eval | 执行Lua 脚本 |\n| --latency | 检测网络延迟 |\n| --latency-history | 分时段了解延迟信息 |\n| --latency-dist | 使用统计图表输出延迟统计信息 |\n| --stat | 实时获取Redis 的重要统计信息 |\n| --no-raw | 要求命令的返回结果必须是原始的格式 |\n| --raw | 要求命令的返回结果是转换后的格式 |\n\n### 3.3 redis-server 详解\n参数 `--test-memory` 用来检测当前系统能否稳定的分配指定容量的内存给Redis\n\n### 3.4 redis-benchmark 详解\nredis-benchmark 可以为Redis做基准性能测试\n\n| 参数 | 作用 |\n|--|--|\n| -c | 客户端的并发数（默认50）|\n| -n | 客户端请求总量（默认100000）|\n| -r | 插入随机的键做测试 |\n| -P | 每个请求pipeline 的数据量（默认1）|\n| -k | 是否使用keepalive，1为使用，0为不使用 |\n| -t | 对指定命令进行基准测试 |\n| --csv | 将结果按照csv格式输出 |\n\n### 3.5 Pipeline\n有效节约RTT（Round Trip Time，往返时间）\n\n### 3.6 事务与Lua\nRedis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。\n\n#### 3.6.1 不同错误下的处理机制\n1. 命令错误：整个事务无法执行\n2. 运行时异常：不支持回滚\n\n#### 3.6.2 Lua\n```lua\n-- 没有local代表是全局变量\nlocal strings val = \"world\"\nprint(val)\n-- 表格，下标从 1 开始\nlocal tables myArray = {\"redis\", \"jedis\", true, 88.0}\nprint(myArray[3])\n-- for循环\nlocal int sum = 0\nfor i = 1, 100\ndo\n    sum = sum + i\nend\nprint(sum)\nfor i = 1, #myArray\ndo\n    print(myArray[i])\nend\n-- ipairs函数，返回索引下标和值\nfor index,value in ipairs(myArray)\ndo\n    print(index)\n    print(value)\nend\n-- while\nlocal int sum = 0\nlocal int i = 0\nwhile i <= 100\ndo\n    sum = sum + 1\n    i = i + 1\nend\nprint(sum)\n-- if else\nfor i = 1, #myArray\ndo\n    if myArray[i] == \"jedis\"\n    then\n        print(\"true\")\n        break\n    else\n        -- do nothing\n    end\nend\n-- 哈希\nlocal tables user_1 = {age = 28, name = \"tom\"}\nprint(\"user_1 age is\" .. user_1[\"age\"])\nfor key,value in pairs(user_1)\ndo print(key .. value)\nend\n-- 函数定义\nfunction contact(str1, str2)\n    return str1 .. str2\nend\nprint(contact(\"hello\", \"world\"))\n```\n\n#### 3.6.3 Redis中使用Lua\n- eval\n  Redis 中执行`eval script key_num keys args`:\n  ```shell\n  127.0.0.1:6379> eval 'return \"hello \" .. KEYS[1] .. ARGV[1]' 1 redis world\n  ```\n  如果Lua 脚本较长，可以使用redis-cli --eval 直接执行文件\n- evalsha\n  首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销\n  ```shell\n  redis-cli script load \"$(cat lua_get.lua)\"\n  evalsha sha1_value key_num keys args\n  ```\n\n#### 3.6.4 Lua的Redis API\nLua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本\n```lua\nredis.call(\"set\", \"hello\", \"world\")\nredis.call(\"get\", \"hello\")\n```\n\n#### 3.6.5 Redis 如何管理Lua脚本\n- `script load script`：将Lua 脚本加载到Redis内存中\n- `script exists sha1`：判断sha1 是否已经加载到Redis内存中\n- `script flush`：清除已经加载的所有Lua脚本\n- `script kill`：用于杀掉正在执行的Lua脚本，Redis 提供了`lua-time-limit` 参数，默认是 5 秒，但只是当Lua 脚本时间超过`lua-time-limit` 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，`script kill` 将不会生效，此时要么等待脚本结束要么使用 `shutdown save` 停掉Redis服务\n\n### 3.7 Bitmaps\n- Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作\n- Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量\n\n#### 3.7.1 Bitmaps命令\n| 命令 | 作用 |\n|--|--|\n| setbit key offset value | 设置值 |\n| getbit key offset | 获取值 |\n| bitcount [start] [end] | 获取Bitmaps 指定范围为 1 的个数 |\n| bitop op destkey key[key ...] | Bitmaps间的运算: and、or、not、xor |\n| bitpos key targetBit [start] [end] | 计算Bitmaps中第一个值为targetBit的偏移量 |\n\n### 3.8 HyperLogLog\nHyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。\n\n| 命令 | 作用 |\n|--|--|\n| pfadd key element [element ...] | 添加 |\n| pfcount key [key ...] | 去重计数，存在一定误差 |\n| pfmerge destkey sourcekey [sourcekey ...] | 合并 |\n\n在选择HyperLogLog 时，需要确认两点：\n- 只是为了计算独立总数，不需要获取单条数据\n- 可以容忍一定误差\n\n### 3.9 发布订阅\n\n| 命令 | 作用 |\n|--|--|\n| publish channel message | 发布消息 |\n| subscribe channel [channel ...] | 订阅消息 |\n| unsubscribe [channel [channel ...]] | 取消订阅 |\n| psubscribe pattern [pattern ...] | 按照模式订阅 |\n| punsubscribe [pattern [pattern ...]] | 按照模式取消订阅 |\n| pubsub channels [pattern] | 查看活跃的频道 |\n| pubsub numsub [channel ...] | 查看频道订阅数 |\n| pubsub numpat | 查看模式订阅数 |\n\n订阅命令的注意点：\n- 客户端执行订阅命令之后进入了了订阅状态，只能接收`subscribe`、`psubscribe`、`unsubscribe`、`punsubscribe`这四个命令\n- 新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化\n\n活跃的频道是指当前频道至少有一个订阅者\n\n### 3.10 GEO（地理信息定位）\nRedis3.2 版本提供了GEO功能。\n\n| 命令 | 作用 |\n|--|--|\n| geoadd key longitude latitude member [longitude latitude memeber ...] | 增加地理位置信息 |\n| geopos key member [memeber ...] | 获取地理位置信息 |\n| geodist key member1 member2 [unit] | 获取两个地理位置的距离 |\n| georadius key longitude latitude radiusm &#124; km &#124; ft &#124; mi [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key] | 获取指定位置范围内的地理信息位置集合 |\n| georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key] | 获取指定位置范围内的成员信息 |\n| geohash key member [member ...] | 获取geohash |\n| zrem key member | 删除地理位置信息 |\n\n参数：\n- withcoord：返回结果中包含经纬度\n- withdist：返回结果中包含离中心节点位置的距离\n- withhash：返回结果中包含geohash\n- COUNT count：指定返回结果的数量\n- asc&#124;desc：返回结果按照离中心节点的距离做升序或者降序\n- store key：将返回结果的地理位置信息保存到指定键\n- storedist key: 将返回结果离中心节点的距离保存到指定键\n\n`geohash`的特点：\n- GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中\n- 字符串越长，表示的位置更精确\n- 两个字符串越相似，它们之间的距离越近\n- geohash编码和经纬度是可以互换的\n\n##  四、客户端\n\n### 4.1 客户端通信协议\n\n1. 客户端与服务器端之间的通信协议建立在TCP之上\n2. Redis制定了RESP（REdis Serialization Protocol）\n\n命令格式（CRLF：`\\r\\n`）：\n\n```\n*<参数数量> CRLF\n$<参数1的字节数量> CRLF\n<参数> CRLF\n$<参数N的字节数量> CRLF\n<参数> CRLF\n```\n\n响应格式：\n\n- `+` ：状态回复\n- `-` ：错误回复\n- `:` ：整数回复\n- `$` ：字符串回复\n- `*` ：多条字符串回复\n\n### 4.2 Java 客户端Jedis\n\n#### 4.2.1 连接池配置\n\n| 参数名 | 含义 | 默认值 |\n|--|--|--|\n| maxActive | 连接池最大连接数 | 8 |\n| maxIdle | 连接池最大空闲的连接数 | 8 |\n| minIdle | 连接池最少空闲的连接数 | 0 |\n| maxWaitMillis | 当连接池资源用尽时的最大等待时间（毫秒） | -1:表示永远不超时 |\n| jmxEnabled | 是否开启jmx 监控，如果应用开启了jmx端口并且jmxEnabled 设置为true，可以通过jconsole 或者 jvisualvm 看到连接池的统计信息 | true |\n| minEvictableIdleTimeMillis | 做空闲连接检测时，每次的采样数 | 3 |\n| testOnBorrow | 向连接池借用连接时是否做连接有效性检测（ping），无效连接会被移除，每次归还还多执行一次ping 命令 | false |\n| testWhileIdle | 向连接池借用连接时是否做空闲检测，空闲超时的连接会被移除 | false |\n| timeBetweenEvictionRunsMillis | 空闲连接的检测周期（毫秒）| -1:表示不做检测 |\n| blockWhenExhausted | 当连接池用尽后，调用者是否要等待，当此参数为true时，maxWaitMillis 才会生效 | true |\n\n### 4.3 客户端管理\n\n#### 4.3.1 客户端API\n\n`client list`：列出与Redis 服务端相连的所有客户端连接信息\n  - id：客户端连接的唯一标识，随着Redis 的连接自增，重启Redis 后重置为 0\n  - addr：客户端连接的ip 和端口\n  - fd：socket的文件描述符，如果fd=-1代表客户端不是外部的，而是Redis内部的伪装客户端\n  - name：客户端的名字\n  - qbuf：输入缓冲区的总容量，输入缓冲区不受maxmemory 控制\n  - qbuf-free：输入缓冲区的剩余容量 \n  - obl：固定输出缓冲区的长度（16KB），使用字节数组，用于返回比较小的执行结果\n  - oll：动态输出缓冲区的长度，使用列表，用于返回比较大的结果\n  - omem：输出缓冲区一共使用的字节数\n\nRedis 没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输入内容大小动态调整，只是要求每个客户端缓冲区的大小不能超过 1 G，超过后将被关闭。与输入缓冲区不同的是，输出缓冲区的容量可以通过`client-output-buffer-limit` 来进行设置：\n```shell\nclient-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>\n```\n  - &lt;class&gt;：客户端类型：normal：普通客户端；slave：slave客户端；pubsub：发布订阅客户端\n  - &lt;hard limit&gt;：如果客户端使用的输出缓冲区大于&lt;hard limit&gt;，客户端会被立即关闭\n  - &lt;soft limit&gt; &lt;soft seconds&gt;：如果客户端使用的输出缓冲区超过了 &lt;soft limit&gt; 并持续了 &lt;soft limit&gt; 秒，客户端会被立即关闭\n\n### 4.4 客户端常见异常\n\n1. 无法从连接池获取到连接：\n   - 连接池中没有可用的连接并且等待了`maxWaitMillis` 后也无可用连接\n   - 设置了`blockWhenExhausted=false` ，当连接池无可用连接直接抛出异常\n2. 客户端读写超时：\n   - 读写时间设置过短\n   - 命令本身比较慢\n   - 客户端与服务器端网络不正常\n   - Redis自身发生阻塞\n3. 客户端连接超时：\n   - 连接超时时间过短\n   - Redis发生阻塞，造成`tcp-backlog` 已满，造成新的连接失败\n   - 客户端与服务器端网络不正常\n4. 客户端缓冲区异常：\n   - 输出缓冲区满\n   - 长时间闲置被服务器端主动断开\n   - 不正常并发读写\n5. Lua脚本正在执行\n6. Redis正在加载持久化文件\n7. Redis使用的内存超过了`maxmemory` \n8. 客户端连接数过大\n\n## 五、持久化\n\n#### 5.1 RDB\n\n##### 5.1.1 触发机制\n\n- 手动触发\n  - `save`：阻塞当前服务器，直到RDB过程完成为止\n  - `bgsave`： fork子进程，RDB持久化过程由子进程完成\n- 自动触发\n  - 使用`save m n` 配置，m 秒内数据集存在n 次修改，自动触发bgsave\n  - 从节点执行全量复制操作，主节点自动执行`bgsave` 生成RDB文件发送给从节点\n  - 执行`debug reload` 命令重新加载Redis时，也会自动触发`save` 操作\n  - 默认情况下执行`shutdown` 命令时，如果没有开启AOF持久化功能则自动执行`bgsave` \n\n##### 5.1.2 RDB的优缺点\n\n优点：\n\n- RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，适用于备份，全量复制\n- Redis加载RDB恢复数据远比AOF的方式快\n\n缺点：\n\n- RDB没办法做到实时持久化/秒级持久化，因为`bgsave` 每次运行都要fork子进程，成本过高\n- RDB使用特定二进制格式保存，可能存在老旧版本Redis无法兼容的问题\n\n#### 5.2 AOF\n\n开启AOF功能：`appendonly yes` ，默认不开启\n\nAOF的工作流程：\n\n- 文件写入：所有的写入命令会追加到aof_buf（缓冲区）中，AOF命令写入的内容是文本协议格式\n- 文件同步：AOF缓冲区根据对应的策略向硬盘做同步操作\n- 文件重写：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的\n- 重启加载：当Redis重启时，可以加载AOF文件进行数据恢复\n\n文件同步策略：\n\n| 策略     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| always   | 命令写入aof_buf后调用系统fsync同步到AOF文件，fsync完成后线程返回 |\n| everysec | 命令写入aof_buf后调用系统write操作，write完成后线程返回，fsync由专门的线程每秒执行一次 |\n| no       | 命令写入aof_buf后调用系统write操作，不对AOF文件做fsync操作   |\n\n系统调用write和fsync区别：\n\n- write 会触发延迟写机制，系统缓冲区同步至硬盘依赖于系统调度机制。\n- fsync针对单个文件操作，做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回\n\n触发AOF重写：\n\n- 手动触发：直接调用`bgrewriteaof` \n- 自动触发：根据`auto-aof-rewrite-min-size` 和 `auto-aof-rewrite-percentage` 参数确定触发时机\n\n`auto-aof-rewrite-min-size` ：表示运行AOF重写时文件最小体积，默认64M\n\n`auto-aof-rewrite-percentage` ：当前AOF文件空间（oaf_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值\n\n自动触发时机=`aof_current_size>auto-aof-rewrite-min-sieze && (aof_current_size - aof_base_size)/aof_base_size >= auto-aof-rewrite_percentage` \n\n#### 5.3 重启加载\n\n```flow\nst=>start: Redis启动\nfail=>end: 启动失败\nsuccess=>end: 启动成功\nopen_AOF=>condition: 开启AOF？\nexists_AOF=>condition: 存在AOF？\nexists_RDB=>condition: 存在RDB？\nload_AOF=>operation: 加载AOF\nload_RDB=>operation: 加载RDB\nis_success=>condition: 成功？\n\nst->open_AOF\nopen_AOF(yes)->exists_AOF\nexists_AOF(yes)->load_AOF->is_success\nexists_AOF(no)->exists_RDB\nopen_AOF(no)->exists_RDB\nexists_RDB(yes)->load_RDB->is_success\nis_success(yes)->success\nis_success(no)->fail\n```\n\n\n\n","source":"_posts/Redis开发与运维.md","raw":"---\ntitle: Redis开发与运维\ndate: 2020-04-17 22:37:20\ntags: Redis\ncategories:\n- 分布式组件\n---\n\n## 一、初识Redis\n\n### 1.1 Redis特性\n- 速度快：10万/秒\n- 基于键值对的数据结构服务器\n- 丰富的功能\n- 简单稳定\n- 客户端语言多\n- 持久化：RDB 和 AOF\n- 主从复制\n- 高可用和分布式\n<!--more-->\n\n### 1.2 用好Redis的建议\n1. 勿当作黑盒使用\n2. 阅读源码\n\n### 1.3 Redis 基本操作\n\n#### 1.3.1 配置、启动、操作、关闭\n\nRedis 可执行文件说明：\n\n| 可执行文件 | 作用 |\n|--|--|\n| redis-server | 启动Redis |\n| redis-cli | Redis 命令行客户端 |\n| redis-benchmark | Redis 基准测试工具 |\n| redis-check-aof | Redis AOF 持久化文件检测和修复工具 |\n| redis-check-dump | Redis RDB 持久化文件检测和修复工具 |\n| redis-sentinel | 启动 Redis Sentinel |\n\nRedis 基础配置：\n\n| 配置名 | 配置说明 |\n|--|--|\n| port | 端口 |\n| logfile | 日志文件 |\n| dir | Redis 工作目录（存放持久化文件和日志文件）|\n| daemonize | 是否以守护进程的方式启动Redis |\n\n停止 Redis 服务：\n`redis-cli shutdown` 用来停止Redis 服务，三点注意：\n- Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式\n- 除了`shutdown` 命令外，还可以通过`kill` 进程号的方式关掉Redis，但不可使用 `kill -9` 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。\n- `shutdown` 还有一个参数，代表是否在关闭Redis前，生成持久化文件：`redis-cli shutdown nosave|save`\n\n## 二、API的理解和使用\n\n### 2.1 全局命令\n\n| 命令 | 作用 |\n|--|--|\n| keys * | 查看所有键 |\n| dbsize | 键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量 |\n| exists key | 检查键是否存在 |\n| del key [key ...] | 删除键 |\n| expire key seconds | 键过期 |\n| ttl key | 查看键的过期时间 |\n| type key | 键的数据结构类型 |\n| object encoding key | 查询内部编码 |\n\n### 2.2 数据结构和内部编码\n\n```mermaid\n  graph TB\n    key --> string\n    key --> hash\n    key --> list\n    key --> set\n    key --> zset\n    string --> raw\n    string --> int\n    string --> embstr\n    hash --> hashtable_1[hashtable]\n    hash --> ziplist_1[ziplist]\n    list --> linkedlist\n    list --> ziplist_2[ziplist]\n    set --> hashtable_2[hashtable]\n    set --> intset\n    zset --> skiplist\n    zset --> ziplist_3[ziplist]\n```\n\nRedis这样设计的好处：\n- 可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势\n- 多种内部编码实现可以在不同场景下发挥各自的优势\n\n### 2.3 单线程架构\n单线程为什么这么快？\n  - 纯内存访问\n  - 非阻塞I/O\n  - 单线程避免了线程切换和竞态的消耗\n\n### 2.4 字符串\n\n#### 2.4.1 字符串类型常用命令\n| 命令 | 作用 |\n|--|--|\n| set key value [ex seconds] [px milliseconds] [nx xx] | 设置值 |\n| setnx | 存在设置失败 |\n| setex | 存在才能设置成功 |\n| get key | 获取值 |\n| mset key value [key value ...] | 批量设置值 |\n| mget key [key ...] | 批量获取值 |\n| incr key | 自增操作，值不是整数返回错误，键不存在按照 0 自增 |\n| decr key | 自减操作 |\n| incrby decrby incrbyfloat | 根据数值自增自减 |\n\n#### 2.4.2 字符串类型不常用命令\n| 命令 | 作用 |\n|--|--|\n| append key value | 追加值 |\n| strlen key | 字符串长度 |\n| getset key value | 设置并返回原值 |\n| setrange key offset value | 设置指定位置的字符 |\n| getrange key start end | 获取部分字符串 |\n\n#### 2.4.3 字符串内部编码\n  - int：8 个字节的长整型\n  - embstr：小于等于 39 个字节的字符串\n  - raw：大于 39 个字符的字符串\n\n### 2.5 哈希\n\n#### 2.5.1 哈希命令\n| 命令 | 作用 |\n|--|--|\n| hset key field value | 设置值 |\n| hget key field | 获取值 |\n| hdel key field [field ...] | 删除field |\n| hlen key | 计算field 个数 |\n| hmget key field [field ...] | 批量获取field-value |\n| hmset key field value [field value ...] | 批量设置field-value |\n| hexists key field | 判断field 是否存在 |\n| hkeys key | 获取所有field |\n| hvals key | 获取所有value |\n| hgetall key | 获取所有的field-value |\n| hincrby hincrbyfloat key field | field 自增 |\n| hstrlen key field | 计算value 的字符串长度 |\n\n#### 2.5.2 内部编码\n  - ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。\n  - hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。\n\n### 2.6 列表\n\n#### 2.6.1 列表的两个特点：\n  - 列表中的元素是有序的\n  - 列表中的元素可以是重复的\n\n#### 2.6.2 命令\n| 命令 | 作用 |\n|--|--|\n| rpush lpush key value [value ...] | 添加 |\n| linsert key (before after) pivot value | 插入 |\n| lrange key start end | 查找 |\n| lindex key index | 获取列表指定索引下表的元素 |\n| llen key | 获取列表长度 |\n| lpop rpop key | 弹出元素|\n| lrem key count value | 删除指定元素，count>0，从左到右；count<0从右到左 删除最多count个元素；count=0，删除所有|\n| ltrim key start end | 按照索引范围剪切列表 |\n| lset key index newValue | 修改 |\n| blpop brpop key [key ...] timeout | 阻塞操作 |\n\n#### 2.6.3 内部编码\n  - ziplist\n  - linkedlist\n\n#### 2.6.4 使用场景\n  - 消息队列\n  - 文章列表\n  - lpush + lpop = Stack（栈）\n  - lpush + rpop = Queue（队列）\n  - lpush + ltrim = Capped Collection（有限集合）\n  - lpush + brpop = Message Queue（消息队列）\n\n### 2.7 集合\n  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。\n\n#### 2.7.1 命令\n集合内操作：\n\n| 命令 | 作用 |\n|--|--|\n| sadd key ele [ele ...] | 添加元素 |\n| srem key ele [ele ...] | 删除元素 |\n| scard key | 计算元素个数 |\n| sismember key ele | 判断元素是否在集合中 |\n| srandmember key [count:1] | 随机从集合返回指定个数元素 |\n| spop key | 从集合随机弹出一个元素 |\n| smember key | 获取所有元素 |\n\n集合间操作：\n\n| 命令 | 作用 |\n|--|--|\n| sinter key [key ...] | 求多个结合的交集 |\n| suinon key [key ...] | 求多个结合的并集 |\n| sdiff key [key ...] | 求多个集合的差集 |\n| sinterstore sunionstore sdiffstore destination key [key ...] | 将交集、并集、差集的结果保存 |\n\n集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。\n\n#### 2.7.2 内部编码\n  - intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现\n  - hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现\n\n#### 2.7.3 使用场景\n  - 标签\n\n### 2.8 有序集合\n  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。\n\n#### 2.8.1 命令\n集合内：\n\n| 命令 | 作用 |\n|--|--|\n| zadd key score memeber [score memeber ...] | 添加成员 |\n| zcard key | 计算成员个数 |\n| zscore key member | 计算某个成员的分数 |\n| zrank zrevrank key member | 计算成员的排名 |\n| zrem key memeber [member ...] | 删除成员 |\n| zincrby key increment member | 增加成员的分数 |\n| zrange zrevrange key start end [withscores] | 返回指定排名范围的成员 |\n| zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count] | 返回指定分数范围的成员 |\n| zcount key min max | 返回指定分数范围成员个数 |\n| zremrangebyrank key start end | 删除指定排名内的升序元素 |\n| zremrangebyscore key min max | 删除指定分数范围的成员 |\n\nRedis3.2为zadd添加了nx、xx、ch、incr 四个选项：\n  - nx：member 必须不存在才能设置成功，用于添加\n  - xx：member 必须存在才能设置成功，用于更新\n  - ch：返回此次操作后，有序集合元素和分数变化的个数\n  - incr：对score做增加，相当于zincrby\n\n集合间的操作\n  - 交集：\n    `zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`\n    - destination：交集计算结果保存在这个键\n    - numkeys：需要做交集计算键的个数\n    - key[key ...]：需要做交集计算的键\n    - weights weight[weight ...]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1\n    - aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum\n  - 并集：\n    `zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`\n\n#### 2.8.2 内部编码\n  - ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现\n  - skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现\n\n#### 2.8.3 使用场景\n  - 点赞数\n  - 前十名\n  - 用户分数\n\n### 2.9 键管理\n\n#### 2.9.1 单个键管理\n| 命令 | 作用 |\n|--|--|\n| rename key newkey | 键重命名 |\n| renamenx key newkey | newkey 不存在时重命名 |\n| randomkey | 随机返回一个键 |\n| expire key seconds | 键在seconds 秒后过期 |\n| expireat key timestamp | 键在秒级时间戳timestamp 后过期 |\n| pexpire key milliseconds | 键在milliseconds 毫秒后过期 |\n| pexpireat key milliseconds-timestamp | 键在毫秒级时间戳timestamp 后过期 |\n| move key db | 键内部迁移 |\n| dump key | 键值序列化，采用RDB格式 |\n| restore key ttl value | 反序列化键值 |\n| migrate host port (key \"\") destination-db timeout [copy] [replace] [keys key [key ...]] | Redis 实例间进行数据迁移 |\n\nRedis过期命令注意点：\n  - expire key的键不存在，返回结果为 0\n  - 过期时间如果为负值，键会立即被删除\n  - persist 可以将键的过期时间清除\n  - 对于字符串类型键，set 命令会去掉过期时间\n  - Redis 不支持二级数据结构内部元素的过期功能\n  - setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间\n\nmigrate 参数：\n  - host：目标Redis 的IP地址\n  - port：目标Redis 的端口\n  - key|\"\"：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”\n  - destination：目标Redis 的数据库索引\n  - timeout：迁移的超时时间（毫秒）\n  - [copy]：添加后，迁移不删除源键\n  - [replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖\n  - [keys key[key ...]]：迁移多个键\n\n#### 2.9.2 遍历键\n- `keys pattern`：全量遍历键\n  keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：\n    - 在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制\n    - 如果确认键值总数确实比较少，可以执行该命令\n    - 使用scan 命令，可以有效防止阻塞\n- `scan cursor [match pattern] [count number]`：渐进式遍历\n  - curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束\n  - match pattern：可选参数，匹配正则\n  - count number：可选参数，每次要遍历的键个数，默认是 10\n\n除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan\n\n#### 2.9.3 数据库管理\n| 命令 | 作用 |\n|--|--|\n| select dbIndex | 切换数据库，Redis默认配置中有16个数据库 |\n| flushdb | 清除当前数据库 |\n| flushall | 清除所有数据库 |\n\n  **注意**：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：\n  - Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响\n  - 多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库\n  - 部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱\n\n## 三、小功能大用处\n\n### 3.1 慢查询分析\nRedis 提供了`slowlog-log-slower-than` 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数\n```shell\nconfig set slowlog-log-slower-than 20000\nconfig set slowlog-max-len 1000\nconfig rewrite\n# 获取慢查询日志\nslowlog get [n]\n# 获取慢查询日志列表当前的长度\nslowlog len\n# 慢查询日志重置\nslowlog reset\n```\n\n### 3.2 redis-cli 详解\n| 参数 | 作用 |\n|--|--|\n| -r | 命令执行多次 |\n| -i | 每隔几秒执行一次 |\n| -x | 从标准输入读取数据作为最后一个参数 |\n| -c | 连接Redis Cluster 节点时使用 |\n| -a | Redis 配置了命令时使用 |\n| --scan 和 --pattern | 用于扫描指定模式的键 |\n| --slave | 把当前客户端模拟成当前Redis 节点的从节点 |\n| --rdb | 请求Redis实例生成并发送RDB持久化文件保存到本地 |\n| --pipe | 批量执行Redis 命令 |\n| --bigkeys | 使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值 |\n| --eval | 执行Lua 脚本 |\n| --latency | 检测网络延迟 |\n| --latency-history | 分时段了解延迟信息 |\n| --latency-dist | 使用统计图表输出延迟统计信息 |\n| --stat | 实时获取Redis 的重要统计信息 |\n| --no-raw | 要求命令的返回结果必须是原始的格式 |\n| --raw | 要求命令的返回结果是转换后的格式 |\n\n### 3.3 redis-server 详解\n参数 `--test-memory` 用来检测当前系统能否稳定的分配指定容量的内存给Redis\n\n### 3.4 redis-benchmark 详解\nredis-benchmark 可以为Redis做基准性能测试\n\n| 参数 | 作用 |\n|--|--|\n| -c | 客户端的并发数（默认50）|\n| -n | 客户端请求总量（默认100000）|\n| -r | 插入随机的键做测试 |\n| -P | 每个请求pipeline 的数据量（默认1）|\n| -k | 是否使用keepalive，1为使用，0为不使用 |\n| -t | 对指定命令进行基准测试 |\n| --csv | 将结果按照csv格式输出 |\n\n### 3.5 Pipeline\n有效节约RTT（Round Trip Time，往返时间）\n\n### 3.6 事务与Lua\nRedis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。\n\n#### 3.6.1 不同错误下的处理机制\n1. 命令错误：整个事务无法执行\n2. 运行时异常：不支持回滚\n\n#### 3.6.2 Lua\n```lua\n-- 没有local代表是全局变量\nlocal strings val = \"world\"\nprint(val)\n-- 表格，下标从 1 开始\nlocal tables myArray = {\"redis\", \"jedis\", true, 88.0}\nprint(myArray[3])\n-- for循环\nlocal int sum = 0\nfor i = 1, 100\ndo\n    sum = sum + i\nend\nprint(sum)\nfor i = 1, #myArray\ndo\n    print(myArray[i])\nend\n-- ipairs函数，返回索引下标和值\nfor index,value in ipairs(myArray)\ndo\n    print(index)\n    print(value)\nend\n-- while\nlocal int sum = 0\nlocal int i = 0\nwhile i <= 100\ndo\n    sum = sum + 1\n    i = i + 1\nend\nprint(sum)\n-- if else\nfor i = 1, #myArray\ndo\n    if myArray[i] == \"jedis\"\n    then\n        print(\"true\")\n        break\n    else\n        -- do nothing\n    end\nend\n-- 哈希\nlocal tables user_1 = {age = 28, name = \"tom\"}\nprint(\"user_1 age is\" .. user_1[\"age\"])\nfor key,value in pairs(user_1)\ndo print(key .. value)\nend\n-- 函数定义\nfunction contact(str1, str2)\n    return str1 .. str2\nend\nprint(contact(\"hello\", \"world\"))\n```\n\n#### 3.6.3 Redis中使用Lua\n- eval\n  Redis 中执行`eval script key_num keys args`:\n  ```shell\n  127.0.0.1:6379> eval 'return \"hello \" .. KEYS[1] .. ARGV[1]' 1 redis world\n  ```\n  如果Lua 脚本较长，可以使用redis-cli --eval 直接执行文件\n- evalsha\n  首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销\n  ```shell\n  redis-cli script load \"$(cat lua_get.lua)\"\n  evalsha sha1_value key_num keys args\n  ```\n\n#### 3.6.4 Lua的Redis API\nLua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本\n```lua\nredis.call(\"set\", \"hello\", \"world\")\nredis.call(\"get\", \"hello\")\n```\n\n#### 3.6.5 Redis 如何管理Lua脚本\n- `script load script`：将Lua 脚本加载到Redis内存中\n- `script exists sha1`：判断sha1 是否已经加载到Redis内存中\n- `script flush`：清除已经加载的所有Lua脚本\n- `script kill`：用于杀掉正在执行的Lua脚本，Redis 提供了`lua-time-limit` 参数，默认是 5 秒，但只是当Lua 脚本时间超过`lua-time-limit` 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，`script kill` 将不会生效，此时要么等待脚本结束要么使用 `shutdown save` 停掉Redis服务\n\n### 3.7 Bitmaps\n- Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作\n- Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量\n\n#### 3.7.1 Bitmaps命令\n| 命令 | 作用 |\n|--|--|\n| setbit key offset value | 设置值 |\n| getbit key offset | 获取值 |\n| bitcount [start] [end] | 获取Bitmaps 指定范围为 1 的个数 |\n| bitop op destkey key[key ...] | Bitmaps间的运算: and、or、not、xor |\n| bitpos key targetBit [start] [end] | 计算Bitmaps中第一个值为targetBit的偏移量 |\n\n### 3.8 HyperLogLog\nHyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。\n\n| 命令 | 作用 |\n|--|--|\n| pfadd key element [element ...] | 添加 |\n| pfcount key [key ...] | 去重计数，存在一定误差 |\n| pfmerge destkey sourcekey [sourcekey ...] | 合并 |\n\n在选择HyperLogLog 时，需要确认两点：\n- 只是为了计算独立总数，不需要获取单条数据\n- 可以容忍一定误差\n\n### 3.9 发布订阅\n\n| 命令 | 作用 |\n|--|--|\n| publish channel message | 发布消息 |\n| subscribe channel [channel ...] | 订阅消息 |\n| unsubscribe [channel [channel ...]] | 取消订阅 |\n| psubscribe pattern [pattern ...] | 按照模式订阅 |\n| punsubscribe [pattern [pattern ...]] | 按照模式取消订阅 |\n| pubsub channels [pattern] | 查看活跃的频道 |\n| pubsub numsub [channel ...] | 查看频道订阅数 |\n| pubsub numpat | 查看模式订阅数 |\n\n订阅命令的注意点：\n- 客户端执行订阅命令之后进入了了订阅状态，只能接收`subscribe`、`psubscribe`、`unsubscribe`、`punsubscribe`这四个命令\n- 新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化\n\n活跃的频道是指当前频道至少有一个订阅者\n\n### 3.10 GEO（地理信息定位）\nRedis3.2 版本提供了GEO功能。\n\n| 命令 | 作用 |\n|--|--|\n| geoadd key longitude latitude member [longitude latitude memeber ...] | 增加地理位置信息 |\n| geopos key member [memeber ...] | 获取地理位置信息 |\n| geodist key member1 member2 [unit] | 获取两个地理位置的距离 |\n| georadius key longitude latitude radiusm &#124; km &#124; ft &#124; mi [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key] | 获取指定位置范围内的地理信息位置集合 |\n| georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key] | 获取指定位置范围内的成员信息 |\n| geohash key member [member ...] | 获取geohash |\n| zrem key member | 删除地理位置信息 |\n\n参数：\n- withcoord：返回结果中包含经纬度\n- withdist：返回结果中包含离中心节点位置的距离\n- withhash：返回结果中包含geohash\n- COUNT count：指定返回结果的数量\n- asc&#124;desc：返回结果按照离中心节点的距离做升序或者降序\n- store key：将返回结果的地理位置信息保存到指定键\n- storedist key: 将返回结果离中心节点的距离保存到指定键\n\n`geohash`的特点：\n- GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中\n- 字符串越长，表示的位置更精确\n- 两个字符串越相似，它们之间的距离越近\n- geohash编码和经纬度是可以互换的\n\n##  四、客户端\n\n### 4.1 客户端通信协议\n\n1. 客户端与服务器端之间的通信协议建立在TCP之上\n2. Redis制定了RESP（REdis Serialization Protocol）\n\n命令格式（CRLF：`\\r\\n`）：\n\n```\n*<参数数量> CRLF\n$<参数1的字节数量> CRLF\n<参数> CRLF\n$<参数N的字节数量> CRLF\n<参数> CRLF\n```\n\n响应格式：\n\n- `+` ：状态回复\n- `-` ：错误回复\n- `:` ：整数回复\n- `$` ：字符串回复\n- `*` ：多条字符串回复\n\n### 4.2 Java 客户端Jedis\n\n#### 4.2.1 连接池配置\n\n| 参数名 | 含义 | 默认值 |\n|--|--|--|\n| maxActive | 连接池最大连接数 | 8 |\n| maxIdle | 连接池最大空闲的连接数 | 8 |\n| minIdle | 连接池最少空闲的连接数 | 0 |\n| maxWaitMillis | 当连接池资源用尽时的最大等待时间（毫秒） | -1:表示永远不超时 |\n| jmxEnabled | 是否开启jmx 监控，如果应用开启了jmx端口并且jmxEnabled 设置为true，可以通过jconsole 或者 jvisualvm 看到连接池的统计信息 | true |\n| minEvictableIdleTimeMillis | 做空闲连接检测时，每次的采样数 | 3 |\n| testOnBorrow | 向连接池借用连接时是否做连接有效性检测（ping），无效连接会被移除，每次归还还多执行一次ping 命令 | false |\n| testWhileIdle | 向连接池借用连接时是否做空闲检测，空闲超时的连接会被移除 | false |\n| timeBetweenEvictionRunsMillis | 空闲连接的检测周期（毫秒）| -1:表示不做检测 |\n| blockWhenExhausted | 当连接池用尽后，调用者是否要等待，当此参数为true时，maxWaitMillis 才会生效 | true |\n\n### 4.3 客户端管理\n\n#### 4.3.1 客户端API\n\n`client list`：列出与Redis 服务端相连的所有客户端连接信息\n  - id：客户端连接的唯一标识，随着Redis 的连接自增，重启Redis 后重置为 0\n  - addr：客户端连接的ip 和端口\n  - fd：socket的文件描述符，如果fd=-1代表客户端不是外部的，而是Redis内部的伪装客户端\n  - name：客户端的名字\n  - qbuf：输入缓冲区的总容量，输入缓冲区不受maxmemory 控制\n  - qbuf-free：输入缓冲区的剩余容量 \n  - obl：固定输出缓冲区的长度（16KB），使用字节数组，用于返回比较小的执行结果\n  - oll：动态输出缓冲区的长度，使用列表，用于返回比较大的结果\n  - omem：输出缓冲区一共使用的字节数\n\nRedis 没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输入内容大小动态调整，只是要求每个客户端缓冲区的大小不能超过 1 G，超过后将被关闭。与输入缓冲区不同的是，输出缓冲区的容量可以通过`client-output-buffer-limit` 来进行设置：\n```shell\nclient-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>\n```\n  - &lt;class&gt;：客户端类型：normal：普通客户端；slave：slave客户端；pubsub：发布订阅客户端\n  - &lt;hard limit&gt;：如果客户端使用的输出缓冲区大于&lt;hard limit&gt;，客户端会被立即关闭\n  - &lt;soft limit&gt; &lt;soft seconds&gt;：如果客户端使用的输出缓冲区超过了 &lt;soft limit&gt; 并持续了 &lt;soft limit&gt; 秒，客户端会被立即关闭\n\n### 4.4 客户端常见异常\n\n1. 无法从连接池获取到连接：\n   - 连接池中没有可用的连接并且等待了`maxWaitMillis` 后也无可用连接\n   - 设置了`blockWhenExhausted=false` ，当连接池无可用连接直接抛出异常\n2. 客户端读写超时：\n   - 读写时间设置过短\n   - 命令本身比较慢\n   - 客户端与服务器端网络不正常\n   - Redis自身发生阻塞\n3. 客户端连接超时：\n   - 连接超时时间过短\n   - Redis发生阻塞，造成`tcp-backlog` 已满，造成新的连接失败\n   - 客户端与服务器端网络不正常\n4. 客户端缓冲区异常：\n   - 输出缓冲区满\n   - 长时间闲置被服务器端主动断开\n   - 不正常并发读写\n5. Lua脚本正在执行\n6. Redis正在加载持久化文件\n7. Redis使用的内存超过了`maxmemory` \n8. 客户端连接数过大\n\n## 五、持久化\n\n#### 5.1 RDB\n\n##### 5.1.1 触发机制\n\n- 手动触发\n  - `save`：阻塞当前服务器，直到RDB过程完成为止\n  - `bgsave`： fork子进程，RDB持久化过程由子进程完成\n- 自动触发\n  - 使用`save m n` 配置，m 秒内数据集存在n 次修改，自动触发bgsave\n  - 从节点执行全量复制操作，主节点自动执行`bgsave` 生成RDB文件发送给从节点\n  - 执行`debug reload` 命令重新加载Redis时，也会自动触发`save` 操作\n  - 默认情况下执行`shutdown` 命令时，如果没有开启AOF持久化功能则自动执行`bgsave` \n\n##### 5.1.2 RDB的优缺点\n\n优点：\n\n- RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，适用于备份，全量复制\n- Redis加载RDB恢复数据远比AOF的方式快\n\n缺点：\n\n- RDB没办法做到实时持久化/秒级持久化，因为`bgsave` 每次运行都要fork子进程，成本过高\n- RDB使用特定二进制格式保存，可能存在老旧版本Redis无法兼容的问题\n\n#### 5.2 AOF\n\n开启AOF功能：`appendonly yes` ，默认不开启\n\nAOF的工作流程：\n\n- 文件写入：所有的写入命令会追加到aof_buf（缓冲区）中，AOF命令写入的内容是文本协议格式\n- 文件同步：AOF缓冲区根据对应的策略向硬盘做同步操作\n- 文件重写：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的\n- 重启加载：当Redis重启时，可以加载AOF文件进行数据恢复\n\n文件同步策略：\n\n| 策略     | 说明                                                         |\n| -------- | ------------------------------------------------------------ |\n| always   | 命令写入aof_buf后调用系统fsync同步到AOF文件，fsync完成后线程返回 |\n| everysec | 命令写入aof_buf后调用系统write操作，write完成后线程返回，fsync由专门的线程每秒执行一次 |\n| no       | 命令写入aof_buf后调用系统write操作，不对AOF文件做fsync操作   |\n\n系统调用write和fsync区别：\n\n- write 会触发延迟写机制，系统缓冲区同步至硬盘依赖于系统调度机制。\n- fsync针对单个文件操作，做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回\n\n触发AOF重写：\n\n- 手动触发：直接调用`bgrewriteaof` \n- 自动触发：根据`auto-aof-rewrite-min-size` 和 `auto-aof-rewrite-percentage` 参数确定触发时机\n\n`auto-aof-rewrite-min-size` ：表示运行AOF重写时文件最小体积，默认64M\n\n`auto-aof-rewrite-percentage` ：当前AOF文件空间（oaf_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值\n\n自动触发时机=`aof_current_size>auto-aof-rewrite-min-sieze && (aof_current_size - aof_base_size)/aof_base_size >= auto-aof-rewrite_percentage` \n\n#### 5.3 重启加载\n\n```flow\nst=>start: Redis启动\nfail=>end: 启动失败\nsuccess=>end: 启动成功\nopen_AOF=>condition: 开启AOF？\nexists_AOF=>condition: 存在AOF？\nexists_RDB=>condition: 存在RDB？\nload_AOF=>operation: 加载AOF\nload_RDB=>operation: 加载RDB\nis_success=>condition: 成功？\n\nst->open_AOF\nopen_AOF(yes)->exists_AOF\nexists_AOF(yes)->load_AOF->is_success\nexists_AOF(no)->exists_RDB\nopen_AOF(no)->exists_RDB\nexists_RDB(yes)->load_RDB->is_success\nis_success(yes)->success\nis_success(no)->fail\n```\n\n\n\n","slug":"Redis开发与运维","published":1,"updated":"2020-05-17T23:59:29.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckabq6ghs000x3fgrf9v88154","content":"<h2 id=\"一、初识Redis\"><a href=\"#一、初识Redis\" class=\"headerlink\" title=\"一、初识Redis\"></a>一、初识Redis</h2><h3 id=\"1-1-Redis特性\"><a href=\"#1-1-Redis特性\" class=\"headerlink\" title=\"1.1 Redis特性\"></a>1.1 Redis特性</h3><ul>\n<li>速度快：10万/秒</li>\n<li>基于键值对的数据结构服务器</li>\n<li>丰富的功能</li>\n<li>简单稳定</li>\n<li>客户端语言多</li>\n<li>持久化：RDB 和 AOF</li>\n<li>主从复制</li>\n<li>高可用和分布式<a id=\"more\"></a>\n</li>\n</ul>\n<h3 id=\"1-2-用好Redis的建议\"><a href=\"#1-2-用好Redis的建议\" class=\"headerlink\" title=\"1.2 用好Redis的建议\"></a>1.2 用好Redis的建议</h3><ol>\n<li>勿当作黑盒使用</li>\n<li>阅读源码</li>\n</ol>\n<h3 id=\"1-3-Redis-基本操作\"><a href=\"#1-3-Redis-基本操作\" class=\"headerlink\" title=\"1.3 Redis 基本操作\"></a>1.3 Redis 基本操作</h3><h4 id=\"1-3-1-配置、启动、操作、关闭\"><a href=\"#1-3-1-配置、启动、操作、关闭\" class=\"headerlink\" title=\"1.3.1 配置、启动、操作、关闭\"></a>1.3.1 配置、启动、操作、关闭</h4><p>Redis 可执行文件说明：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>可执行文件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redis-server</td>\n<td>启动Redis</td>\n</tr>\n<tr>\n<td>redis-cli</td>\n<td>Redis 命令行客户端</td>\n</tr>\n<tr>\n<td>redis-benchmark</td>\n<td>Redis 基准测试工具</td>\n</tr>\n<tr>\n<td>redis-check-aof</td>\n<td>Redis AOF 持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td>redis-check-dump</td>\n<td>Redis RDB 持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td>redis-sentinel</td>\n<td>启动 Redis Sentinel</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis 基础配置：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>配置名</th>\n<th>配置说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>port</td>\n<td>端口</td>\n</tr>\n<tr>\n<td>logfile</td>\n<td>日志文件</td>\n</tr>\n<tr>\n<td>dir</td>\n<td>Redis 工作目录（存放持久化文件和日志文件）</td>\n</tr>\n<tr>\n<td>daemonize</td>\n<td>是否以守护进程的方式启动Redis</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>停止 Redis 服务：<br><code>redis-cli shutdown</code> 用来停止Redis 服务，三点注意：</p>\n<ul>\n<li>Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式</li>\n<li>除了<code>shutdown</code> 命令外，还可以通过<code>kill</code> 进程号的方式关掉Redis，但不可使用 <code>kill -9</code> 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。</li>\n<li><code>shutdown</code> 还有一个参数，代表是否在关闭Redis前，生成持久化文件：<code>redis-cli shutdown nosave|save</code></li>\n</ul>\n<h2 id=\"二、API的理解和使用\"><a href=\"#二、API的理解和使用\" class=\"headerlink\" title=\"二、API的理解和使用\"></a>二、API的理解和使用</h2><h3 id=\"2-1-全局命令\"><a href=\"#2-1-全局命令\" class=\"headerlink\" title=\"2.1 全局命令\"></a>2.1 全局命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>keys *</td>\n<td>查看所有键</td>\n</tr>\n<tr>\n<td>dbsize</td>\n<td>键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量</td>\n</tr>\n<tr>\n<td>exists key</td>\n<td>检查键是否存在</td>\n</tr>\n<tr>\n<td>del key [key …]</td>\n<td>删除键</td>\n</tr>\n<tr>\n<td>expire key seconds</td>\n<td>键过期</td>\n</tr>\n<tr>\n<td>ttl key</td>\n<td>查看键的过期时间</td>\n</tr>\n<tr>\n<td>type key</td>\n<td>键的数据结构类型</td>\n</tr>\n<tr>\n<td>object encoding key</td>\n<td>查询内部编码</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-2-数据结构和内部编码\"><a href=\"#2-2-数据结构和内部编码\" class=\"headerlink\" title=\"2.2 数据结构和内部编码\"></a>2.2 数据结构和内部编码</h3><pre class=\"mermaid\">  graph TB\n    key --> string\n    key --> hash\n    key --> list\n    key --> set\n    key --> zset\n    string --> raw\n    string --> int\n    string --> embstr\n    hash --> hashtable_1[hashtable]\n    hash --> ziplist_1[ziplist]\n    list --> linkedlist\n    list --> ziplist_2[ziplist]\n    set --> hashtable_2[hashtable]\n    set --> intset\n    zset --> skiplist\n    zset --> ziplist_3[ziplist]</pre>\n\n<p>Redis这样设计的好处：</p>\n<ul>\n<li>可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势</li>\n<li>多种内部编码实现可以在不同场景下发挥各自的优势</li>\n</ul>\n<h3 id=\"2-3-单线程架构\"><a href=\"#2-3-单线程架构\" class=\"headerlink\" title=\"2.3 单线程架构\"></a>2.3 单线程架构</h3><p>单线程为什么这么快？</p>\n<ul>\n<li>纯内存访问</li>\n<li>非阻塞I/O</li>\n<li>单线程避免了线程切换和竞态的消耗</li>\n</ul>\n<h3 id=\"2-4-字符串\"><a href=\"#2-4-字符串\" class=\"headerlink\" title=\"2.4 字符串\"></a>2.4 字符串</h3><h4 id=\"2-4-1-字符串类型常用命令\"><a href=\"#2-4-1-字符串类型常用命令\" class=\"headerlink\" title=\"2.4.1 字符串类型常用命令\"></a>2.4.1 字符串类型常用命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set key value [ex seconds] [px milliseconds] [nx xx]</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>setnx</td>\n<td>存在设置失败</td>\n</tr>\n<tr>\n<td>setex</td>\n<td>存在才能设置成功</td>\n</tr>\n<tr>\n<td>get key</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>mset key value [key value …]</td>\n<td>批量设置值</td>\n</tr>\n<tr>\n<td>mget key [key …]</td>\n<td>批量获取值</td>\n</tr>\n<tr>\n<td>incr key</td>\n<td>自增操作，值不是整数返回错误，键不存在按照 0 自增</td>\n</tr>\n<tr>\n<td>decr key</td>\n<td>自减操作</td>\n</tr>\n<tr>\n<td>incrby decrby incrbyfloat</td>\n<td>根据数值自增自减</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-4-2-字符串类型不常用命令\"><a href=\"#2-4-2-字符串类型不常用命令\" class=\"headerlink\" title=\"2.4.2 字符串类型不常用命令\"></a>2.4.2 字符串类型不常用命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>append key value</td>\n<td>追加值</td>\n</tr>\n<tr>\n<td>strlen key</td>\n<td>字符串长度</td>\n</tr>\n<tr>\n<td>getset key value</td>\n<td>设置并返回原值</td>\n</tr>\n<tr>\n<td>setrange key offset value</td>\n<td>设置指定位置的字符</td>\n</tr>\n<tr>\n<td>getrange key start end</td>\n<td>获取部分字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-4-3-字符串内部编码\"><a href=\"#2-4-3-字符串内部编码\" class=\"headerlink\" title=\"2.4.3 字符串内部编码\"></a>2.4.3 字符串内部编码</h4><ul>\n<li>int：8 个字节的长整型</li>\n<li>embstr：小于等于 39 个字节的字符串</li>\n<li>raw：大于 39 个字符的字符串</li>\n</ul>\n<h3 id=\"2-5-哈希\"><a href=\"#2-5-哈希\" class=\"headerlink\" title=\"2.5 哈希\"></a>2.5 哈希</h3><h4 id=\"2-5-1-哈希命令\"><a href=\"#2-5-1-哈希命令\" class=\"headerlink\" title=\"2.5.1 哈希命令\"></a>2.5.1 哈希命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hset key field value</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>hget key field</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>hdel key field [field …]</td>\n<td>删除field</td>\n</tr>\n<tr>\n<td>hlen key</td>\n<td>计算field 个数</td>\n</tr>\n<tr>\n<td>hmget key field [field …]</td>\n<td>批量获取field-value</td>\n</tr>\n<tr>\n<td>hmset key field value [field value …]</td>\n<td>批量设置field-value</td>\n</tr>\n<tr>\n<td>hexists key field</td>\n<td>判断field 是否存在</td>\n</tr>\n<tr>\n<td>hkeys key</td>\n<td>获取所有field</td>\n</tr>\n<tr>\n<td>hvals key</td>\n<td>获取所有value</td>\n</tr>\n<tr>\n<td>hgetall key</td>\n<td>获取所有的field-value</td>\n</tr>\n<tr>\n<td>hincrby hincrbyfloat key field</td>\n<td>field 自增</td>\n</tr>\n<tr>\n<td>hstrlen key field</td>\n<td>计算value 的字符串长度</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-5-2-内部编码\"><a href=\"#2-5-2-内部编码\" class=\"headerlink\" title=\"2.5.2 内部编码\"></a>2.5.2 内部编码</h4><ul>\n<li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。</li>\n<li>hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。</li>\n</ul>\n<h3 id=\"2-6-列表\"><a href=\"#2-6-列表\" class=\"headerlink\" title=\"2.6 列表\"></a>2.6 列表</h3><h4 id=\"2-6-1-列表的两个特点：\"><a href=\"#2-6-1-列表的两个特点：\" class=\"headerlink\" title=\"2.6.1 列表的两个特点：\"></a>2.6.1 列表的两个特点：</h4><ul>\n<li>列表中的元素是有序的</li>\n<li>列表中的元素可以是重复的</li>\n</ul>\n<h4 id=\"2-6-2-命令\"><a href=\"#2-6-2-命令\" class=\"headerlink\" title=\"2.6.2 命令\"></a>2.6.2 命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rpush lpush key value [value …]</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>linsert key (before after) pivot value</td>\n<td>插入</td>\n</tr>\n<tr>\n<td>lrange key start end</td>\n<td>查找</td>\n</tr>\n<tr>\n<td>lindex key index</td>\n<td>获取列表指定索引下表的元素</td>\n</tr>\n<tr>\n<td>llen key</td>\n<td>获取列表长度</td>\n</tr>\n<tr>\n<td>lpop rpop key</td>\n<td>弹出元素</td>\n</tr>\n<tr>\n<td>lrem key count value</td>\n<td>删除指定元素，count&gt;0，从左到右；count&lt;0从右到左 删除最多count个元素；count=0，删除所有</td>\n</tr>\n<tr>\n<td>ltrim key start end</td>\n<td>按照索引范围剪切列表</td>\n</tr>\n<tr>\n<td>lset key index newValue</td>\n<td>修改</td>\n</tr>\n<tr>\n<td>blpop brpop key [key …] timeout</td>\n<td>阻塞操作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-6-3-内部编码\"><a href=\"#2-6-3-内部编码\" class=\"headerlink\" title=\"2.6.3 内部编码\"></a>2.6.3 内部编码</h4><ul>\n<li>ziplist</li>\n<li>linkedlist</li>\n</ul>\n<h4 id=\"2-6-4-使用场景\"><a href=\"#2-6-4-使用场景\" class=\"headerlink\" title=\"2.6.4 使用场景\"></a>2.6.4 使用场景</h4><ul>\n<li>消息队列</li>\n<li>文章列表</li>\n<li>lpush + lpop = Stack（栈）</li>\n<li>lpush + rpop = Queue（队列）</li>\n<li>lpush + ltrim = Capped Collection（有限集合）</li>\n<li>lpush + brpop = Message Queue（消息队列）</li>\n</ul>\n<h3 id=\"2-7-集合\"><a href=\"#2-7-集合\" class=\"headerlink\" title=\"2.7 集合\"></a>2.7 集合</h3><p>  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。</p>\n<h4 id=\"2-7-1-命令\"><a href=\"#2-7-1-命令\" class=\"headerlink\" title=\"2.7.1 命令\"></a>2.7.1 命令</h4><p>集合内操作：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sadd key ele [ele …]</td>\n<td>添加元素</td>\n</tr>\n<tr>\n<td>srem key ele [ele …]</td>\n<td>删除元素</td>\n</tr>\n<tr>\n<td>scard key</td>\n<td>计算元素个数</td>\n</tr>\n<tr>\n<td>sismember key ele</td>\n<td>判断元素是否在集合中</td>\n</tr>\n<tr>\n<td>srandmember key [count:1]</td>\n<td>随机从集合返回指定个数元素</td>\n</tr>\n<tr>\n<td>spop key</td>\n<td>从集合随机弹出一个元素</td>\n</tr>\n<tr>\n<td>smember key</td>\n<td>获取所有元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>集合间操作：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sinter key [key …]</td>\n<td>求多个结合的交集</td>\n</tr>\n<tr>\n<td>suinon key [key …]</td>\n<td>求多个结合的并集</td>\n</tr>\n<tr>\n<td>sdiff key [key …]</td>\n<td>求多个集合的差集</td>\n</tr>\n<tr>\n<td>sinterstore sunionstore sdiffstore destination key [key …]</td>\n<td>将交集、并集、差集的结果保存</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。</p>\n<h4 id=\"2-7-2-内部编码\"><a href=\"#2-7-2-内部编码\" class=\"headerlink\" title=\"2.7.2 内部编码\"></a>2.7.2 内部编码</h4><ul>\n<li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现</li>\n<li>hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现</li>\n</ul>\n<h4 id=\"2-7-3-使用场景\"><a href=\"#2-7-3-使用场景\" class=\"headerlink\" title=\"2.7.3 使用场景\"></a>2.7.3 使用场景</h4><ul>\n<li>标签</li>\n</ul>\n<h3 id=\"2-8-有序集合\"><a href=\"#2-8-有序集合\" class=\"headerlink\" title=\"2.8 有序集合\"></a>2.8 有序集合</h3><p>  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。</p>\n<h4 id=\"2-8-1-命令\"><a href=\"#2-8-1-命令\" class=\"headerlink\" title=\"2.8.1 命令\"></a>2.8.1 命令</h4><p>集合内：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zadd key score memeber [score memeber …]</td>\n<td>添加成员</td>\n</tr>\n<tr>\n<td>zcard key</td>\n<td>计算成员个数</td>\n</tr>\n<tr>\n<td>zscore key member</td>\n<td>计算某个成员的分数</td>\n</tr>\n<tr>\n<td>zrank zrevrank key member</td>\n<td>计算成员的排名</td>\n</tr>\n<tr>\n<td>zrem key memeber [member …]</td>\n<td>删除成员</td>\n</tr>\n<tr>\n<td>zincrby key increment member</td>\n<td>增加成员的分数</td>\n</tr>\n<tr>\n<td>zrange zrevrange key start end [withscores]</td>\n<td>返回指定排名范围的成员</td>\n</tr>\n<tr>\n<td>zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count]</td>\n<td>返回指定分数范围的成员</td>\n</tr>\n<tr>\n<td>zcount key min max</td>\n<td>返回指定分数范围成员个数</td>\n</tr>\n<tr>\n<td>zremrangebyrank key start end</td>\n<td>删除指定排名内的升序元素</td>\n</tr>\n<tr>\n<td>zremrangebyscore key min max</td>\n<td>删除指定分数范围的成员</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis3.2为zadd添加了nx、xx、ch、incr 四个选项：</p>\n<ul>\n<li>nx：member 必须不存在才能设置成功，用于添加</li>\n<li>xx：member 必须存在才能设置成功，用于更新</li>\n<li>ch：返回此次操作后，有序集合元素和分数变化的个数</li>\n<li>incr：对score做增加，相当于zincrby</li>\n</ul>\n<p>集合间的操作</p>\n<ul>\n<li>交集：<br><code>zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><ul>\n<li>destination：交集计算结果保存在这个键</li>\n<li>numkeys：需要做交集计算键的个数</li>\n<li>key[key …]：需要做交集计算的键</li>\n<li>weights weight[weight …]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1</li>\n<li>aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum</li>\n</ul>\n</li>\n<li>并集：<br><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></li>\n</ul>\n<h4 id=\"2-8-2-内部编码\"><a href=\"#2-8-2-内部编码\" class=\"headerlink\" title=\"2.8.2 内部编码\"></a>2.8.2 内部编码</h4><ul>\n<li>ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现</li>\n<li>skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现</li>\n</ul>\n<h4 id=\"2-8-3-使用场景\"><a href=\"#2-8-3-使用场景\" class=\"headerlink\" title=\"2.8.3 使用场景\"></a>2.8.3 使用场景</h4><ul>\n<li>点赞数</li>\n<li>前十名</li>\n<li>用户分数</li>\n</ul>\n<h3 id=\"2-9-键管理\"><a href=\"#2-9-键管理\" class=\"headerlink\" title=\"2.9 键管理\"></a>2.9 键管理</h3><h4 id=\"2-9-1-单个键管理\"><a href=\"#2-9-1-单个键管理\" class=\"headerlink\" title=\"2.9.1 单个键管理\"></a>2.9.1 单个键管理</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rename key newkey</td>\n<td>键重命名</td>\n</tr>\n<tr>\n<td>renamenx key newkey</td>\n<td>newkey 不存在时重命名</td>\n</tr>\n<tr>\n<td>randomkey</td>\n<td>随机返回一个键</td>\n</tr>\n<tr>\n<td>expire key seconds</td>\n<td>键在seconds 秒后过期</td>\n</tr>\n<tr>\n<td>expireat key timestamp</td>\n<td>键在秒级时间戳timestamp 后过期</td>\n</tr>\n<tr>\n<td>pexpire key milliseconds</td>\n<td>键在milliseconds 毫秒后过期</td>\n</tr>\n<tr>\n<td>pexpireat key milliseconds-timestamp</td>\n<td>键在毫秒级时间戳timestamp 后过期</td>\n</tr>\n<tr>\n<td>move key db</td>\n<td>键内部迁移</td>\n</tr>\n<tr>\n<td>dump key</td>\n<td>键值序列化，采用RDB格式</td>\n</tr>\n<tr>\n<td>restore key ttl value</td>\n<td>反序列化键值</td>\n</tr>\n<tr>\n<td>migrate host port (key “”) destination-db timeout [copy] [replace] [keys key [key …]]</td>\n<td>Redis 实例间进行数据迁移</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis过期命令注意点：</p>\n<ul>\n<li>expire key的键不存在，返回结果为 0</li>\n<li>过期时间如果为负值，键会立即被删除</li>\n<li>persist 可以将键的过期时间清除</li>\n<li>对于字符串类型键，set 命令会去掉过期时间</li>\n<li>Redis 不支持二级数据结构内部元素的过期功能</li>\n<li>setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间</li>\n</ul>\n<p>migrate 参数：</p>\n<ul>\n<li>host：目标Redis 的IP地址</li>\n<li>port：目标Redis 的端口</li>\n<li>key|””：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”</li>\n<li>destination：目标Redis 的数据库索引</li>\n<li>timeout：迁移的超时时间（毫秒）</li>\n<li>[copy]：添加后，迁移不删除源键</li>\n<li>[replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖</li>\n<li>[keys key[key …]]：迁移多个键</li>\n</ul>\n<h4 id=\"2-9-2-遍历键\"><a href=\"#2-9-2-遍历键\" class=\"headerlink\" title=\"2.9.2 遍历键\"></a>2.9.2 遍历键</h4><ul>\n<li><code>keys pattern</code>：全量遍历键<br>keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：<ul>\n<li>在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制</li>\n<li>如果确认键值总数确实比较少，可以执行该命令</li>\n<li>使用scan 命令，可以有效防止阻塞</li>\n</ul>\n</li>\n<li><code>scan cursor [match pattern] [count number]</code>：渐进式遍历<ul>\n<li>curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束</li>\n<li>match pattern：可选参数，匹配正则</li>\n<li>count number：可选参数，每次要遍历的键个数，默认是 10</li>\n</ul>\n</li>\n</ul>\n<p>除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan</p>\n<h4 id=\"2-9-3-数据库管理\"><a href=\"#2-9-3-数据库管理\" class=\"headerlink\" title=\"2.9.3 数据库管理\"></a>2.9.3 数据库管理</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>select dbIndex</td>\n<td>切换数据库，Redis默认配置中有16个数据库</td>\n</tr>\n<tr>\n<td>flushdb</td>\n<td>清除当前数据库</td>\n</tr>\n<tr>\n<td>flushall</td>\n<td>清除所有数据库</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>  <strong>注意</strong>：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：</p>\n<ul>\n<li>Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响</li>\n<li>多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库</li>\n<li>部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱</li>\n</ul>\n<h2 id=\"三、小功能大用处\"><a href=\"#三、小功能大用处\" class=\"headerlink\" title=\"三、小功能大用处\"></a>三、小功能大用处</h2><h3 id=\"3-1-慢查询分析\"><a href=\"#3-1-慢查询分析\" class=\"headerlink\" title=\"3.1 慢查询分析\"></a>3.1 慢查询分析</h3><p>Redis 提供了<code>slowlog-log-slower-than</code> 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config set slowlog-log-slower-than 20000</span><br><span class=\"line\">config set slowlog-max-len 1000</span><br><span class=\"line\">config rewrite</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取慢查询日志</span></span><br><span class=\"line\">slowlog get [n]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取慢查询日志列表当前的长度</span></span><br><span class=\"line\">slowlog len</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 慢查询日志重置</span></span><br><span class=\"line\">slowlog reset</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-2-redis-cli-详解\"><a href=\"#3-2-redis-cli-详解\" class=\"headerlink\" title=\"3.2 redis-cli 详解\"></a>3.2 redis-cli 详解</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-r</td>\n<td>命令执行多次</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>每隔几秒执行一次</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>从标准输入读取数据作为最后一个参数</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>连接Redis Cluster 节点时使用</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>Redis 配置了命令时使用</td>\n</tr>\n<tr>\n<td>—scan 和 —pattern</td>\n<td>用于扫描指定模式的键</td>\n</tr>\n<tr>\n<td>—slave</td>\n<td>把当前客户端模拟成当前Redis 节点的从节点</td>\n</tr>\n<tr>\n<td>—rdb</td>\n<td>请求Redis实例生成并发送RDB持久化文件保存到本地</td>\n</tr>\n<tr>\n<td>—pipe</td>\n<td>批量执行Redis 命令</td>\n</tr>\n<tr>\n<td>—bigkeys</td>\n<td>使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值</td>\n</tr>\n<tr>\n<td>—eval</td>\n<td>执行Lua 脚本</td>\n</tr>\n<tr>\n<td>—latency</td>\n<td>检测网络延迟</td>\n</tr>\n<tr>\n<td>—latency-history</td>\n<td>分时段了解延迟信息</td>\n</tr>\n<tr>\n<td>—latency-dist</td>\n<td>使用统计图表输出延迟统计信息</td>\n</tr>\n<tr>\n<td>—stat</td>\n<td>实时获取Redis 的重要统计信息</td>\n</tr>\n<tr>\n<td>—no-raw</td>\n<td>要求命令的返回结果必须是原始的格式</td>\n</tr>\n<tr>\n<td>—raw</td>\n<td>要求命令的返回结果是转换后的格式</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-3-redis-server-详解\"><a href=\"#3-3-redis-server-详解\" class=\"headerlink\" title=\"3.3 redis-server 详解\"></a>3.3 redis-server 详解</h3><p>参数 <code>--test-memory</code> 用来检测当前系统能否稳定的分配指定容量的内存给Redis</p>\n<h3 id=\"3-4-redis-benchmark-详解\"><a href=\"#3-4-redis-benchmark-详解\" class=\"headerlink\" title=\"3.4 redis-benchmark 详解\"></a>3.4 redis-benchmark 详解</h3><p>redis-benchmark 可以为Redis做基准性能测试</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>客户端的并发数（默认50）</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>客户端请求总量（默认100000）</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>插入随机的键做测试</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>每个请求pipeline 的数据量（默认1）</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>是否使用keepalive，1为使用，0为不使用</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>对指定命令进行基准测试</td>\n</tr>\n<tr>\n<td>—csv</td>\n<td>将结果按照csv格式输出</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-5-Pipeline\"><a href=\"#3-5-Pipeline\" class=\"headerlink\" title=\"3.5 Pipeline\"></a>3.5 Pipeline</h3><p>有效节约RTT（Round Trip Time，往返时间）</p>\n<h3 id=\"3-6-事务与Lua\"><a href=\"#3-6-事务与Lua\" class=\"headerlink\" title=\"3.6 事务与Lua\"></a>3.6 事务与Lua</h3><p>Redis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。</p>\n<h4 id=\"3-6-1-不同错误下的处理机制\"><a href=\"#3-6-1-不同错误下的处理机制\" class=\"headerlink\" title=\"3.6.1 不同错误下的处理机制\"></a>3.6.1 不同错误下的处理机制</h4><ol>\n<li>命令错误：整个事务无法执行</li>\n<li>运行时异常：不支持回滚</li>\n</ol>\n<h4 id=\"3-6-2-Lua\"><a href=\"#3-6-2-Lua\" class=\"headerlink\" title=\"3.6.2 Lua\"></a>3.6.2 Lua</h4><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 没有local代表是全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> strings val = <span class=\"string\">\"world\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(val)</span><br><span class=\"line\"><span class=\"comment\">-- 表格，下标从 1 开始</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> tables myArray = &#123;<span class=\"string\">\"redis\"</span>, <span class=\"string\">\"jedis\"</span>, <span class=\"literal\">true</span>, <span class=\"number\">88.0</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myArray[<span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">-- for循环</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    sum = sum + i</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #myArray</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(myArray[i])</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- ipairs函数，返回索引下标和值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,value <span class=\"keyword\">in</span> <span class=\"built_in\">ipairs</span>(myArray)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(index)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- while</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt;= <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    sum = sum + <span class=\"number\">1</span></span><br><span class=\"line\">    i = i + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum)</span><br><span class=\"line\"><span class=\"comment\">-- if else</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #myArray</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> myArray[i] == <span class=\"string\">\"jedis\"</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"true\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">-- do nothing</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 哈希</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> tables user_1 = &#123;age = <span class=\"number\">28</span>, name = <span class=\"string\">\"tom\"</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"user_1 age is\"</span> .. user_1[<span class=\"string\">\"age\"</span>])</span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(user_1)</span><br><span class=\"line\"><span class=\"keyword\">do</span> <span class=\"built_in\">print</span>(key .. value)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">contact</span><span class=\"params\">(str1, str2)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str1 .. str2</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(contact(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-6-3-Redis中使用Lua\"><a href=\"#3-6-3-Redis中使用Lua\" class=\"headerlink\" title=\"3.6.3 Redis中使用Lua\"></a>3.6.3 Redis中使用Lua</h4><ul>\n<li>eval<br>Redis 中执行<code>eval script key_num keys args</code>:<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; eval 'return \"hello \" .. KEYS[1] .. ARGV[1]' 1 redis world</span><br></pre></td></tr></table></figure>\n如果Lua 脚本较长，可以使用redis-cli —eval 直接执行文件</li>\n<li>evalsha<br>首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli script load \"$(cat lua_get.lua)\"</span><br><span class=\"line\">evalsha sha1_value key_num keys args</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-6-4-Lua的Redis-API\"><a href=\"#3-6-4-Lua的Redis-API\" class=\"headerlink\" title=\"3.6.4 Lua的Redis API\"></a>3.6.4 Lua的Redis API</h4><p>Lua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis.call(<span class=\"string\">\"set\"</span>, <span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>)</span><br><span class=\"line\">redis.call(<span class=\"string\">\"get\"</span>, <span class=\"string\">\"hello\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-6-5-Redis-如何管理Lua脚本\"><a href=\"#3-6-5-Redis-如何管理Lua脚本\" class=\"headerlink\" title=\"3.6.5 Redis 如何管理Lua脚本\"></a>3.6.5 Redis 如何管理Lua脚本</h4><ul>\n<li><code>script load script</code>：将Lua 脚本加载到Redis内存中</li>\n<li><code>script exists sha1</code>：判断sha1 是否已经加载到Redis内存中</li>\n<li><code>script flush</code>：清除已经加载的所有Lua脚本</li>\n<li><code>script kill</code>：用于杀掉正在执行的Lua脚本，Redis 提供了<code>lua-time-limit</code> 参数，默认是 5 秒，但只是当Lua 脚本时间超过<code>lua-time-limit</code> 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，<code>script kill</code> 将不会生效，此时要么等待脚本结束要么使用 <code>shutdown save</code> 停掉Redis服务</li>\n</ul>\n<h3 id=\"3-7-Bitmaps\"><a href=\"#3-7-Bitmaps\" class=\"headerlink\" title=\"3.7 Bitmaps\"></a>3.7 Bitmaps</h3><ul>\n<li>Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作</li>\n<li>Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量</li>\n</ul>\n<h4 id=\"3-7-1-Bitmaps命令\"><a href=\"#3-7-1-Bitmaps命令\" class=\"headerlink\" title=\"3.7.1 Bitmaps命令\"></a>3.7.1 Bitmaps命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setbit key offset value</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>getbit key offset</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>bitcount [start] [end]</td>\n<td>获取Bitmaps 指定范围为 1 的个数</td>\n</tr>\n<tr>\n<td>bitop op destkey key[key …]</td>\n<td>Bitmaps间的运算: and、or、not、xor</td>\n</tr>\n<tr>\n<td>bitpos key targetBit [start] [end]</td>\n<td>计算Bitmaps中第一个值为targetBit的偏移量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-8-HyperLogLog\"><a href=\"#3-8-HyperLogLog\" class=\"headerlink\" title=\"3.8 HyperLogLog\"></a>3.8 HyperLogLog</h3><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pfadd key element [element …]</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>pfcount key [key …]</td>\n<td>去重计数，存在一定误差</td>\n</tr>\n<tr>\n<td>pfmerge destkey sourcekey [sourcekey …]</td>\n<td>合并</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在选择HyperLogLog 时，需要确认两点：</p>\n<ul>\n<li>只是为了计算独立总数，不需要获取单条数据</li>\n<li>可以容忍一定误差</li>\n</ul>\n<h3 id=\"3-9-发布订阅\"><a href=\"#3-9-发布订阅\" class=\"headerlink\" title=\"3.9 发布订阅\"></a>3.9 发布订阅</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>publish channel message</td>\n<td>发布消息</td>\n</tr>\n<tr>\n<td>subscribe channel [channel …]</td>\n<td>订阅消息</td>\n</tr>\n<tr>\n<td>unsubscribe [channel [channel …]]</td>\n<td>取消订阅</td>\n</tr>\n<tr>\n<td>psubscribe pattern [pattern …]</td>\n<td>按照模式订阅</td>\n</tr>\n<tr>\n<td>punsubscribe [pattern [pattern …]]</td>\n<td>按照模式取消订阅</td>\n</tr>\n<tr>\n<td>pubsub channels [pattern]</td>\n<td>查看活跃的频道</td>\n</tr>\n<tr>\n<td>pubsub numsub [channel …]</td>\n<td>查看频道订阅数</td>\n</tr>\n<tr>\n<td>pubsub numpat</td>\n<td>查看模式订阅数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>订阅命令的注意点：</p>\n<ul>\n<li>客户端执行订阅命令之后进入了了订阅状态，只能接收<code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>这四个命令</li>\n<li>新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化</li>\n</ul>\n<p>活跃的频道是指当前频道至少有一个订阅者</p>\n<h3 id=\"3-10-GEO（地理信息定位）\"><a href=\"#3-10-GEO（地理信息定位）\" class=\"headerlink\" title=\"3.10 GEO（地理信息定位）\"></a>3.10 GEO（地理信息定位）</h3><p>Redis3.2 版本提供了GEO功能。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>geoadd key longitude latitude member [longitude latitude memeber …]</td>\n<td>增加地理位置信息</td>\n</tr>\n<tr>\n<td>geopos key member [memeber …]</td>\n<td>获取地理位置信息</td>\n</tr>\n<tr>\n<td>geodist key member1 member2 [unit]</td>\n<td>获取两个地理位置的距离</td>\n</tr>\n<tr>\n<td>georadius key longitude latitude radiusm &#124; km &#124; ft &#124; mi [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>\n<td>获取指定位置范围内的地理信息位置集合</td>\n</tr>\n<tr>\n<td>georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>\n<td>获取指定位置范围内的成员信息</td>\n</tr>\n<tr>\n<td>geohash key member [member …]</td>\n<td>获取geohash</td>\n</tr>\n<tr>\n<td>zrem key member</td>\n<td>删除地理位置信息</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>参数：</p>\n<ul>\n<li>withcoord：返回结果中包含经纬度</li>\n<li>withdist：返回结果中包含离中心节点位置的距离</li>\n<li>withhash：返回结果中包含geohash</li>\n<li>COUNT count：指定返回结果的数量</li>\n<li>asc&#124;desc：返回结果按照离中心节点的距离做升序或者降序</li>\n<li>store key：将返回结果的地理位置信息保存到指定键</li>\n<li>storedist key: 将返回结果离中心节点的距离保存到指定键</li>\n</ul>\n<p><code>geohash</code>的特点：</p>\n<ul>\n<li>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中</li>\n<li>字符串越长，表示的位置更精确</li>\n<li>两个字符串越相似，它们之间的距离越近</li>\n<li>geohash编码和经纬度是可以互换的</li>\n</ul>\n<h2 id=\"四、客户端\"><a href=\"#四、客户端\" class=\"headerlink\" title=\"四、客户端\"></a>四、客户端</h2><h3 id=\"4-1-客户端通信协议\"><a href=\"#4-1-客户端通信协议\" class=\"headerlink\" title=\"4.1 客户端通信协议\"></a>4.1 客户端通信协议</h3><ol>\n<li>客户端与服务器端之间的通信协议建立在TCP之上</li>\n<li>Redis制定了RESP（REdis Serialization Protocol）</li>\n</ol>\n<p>命令格式（CRLF：<code>\\r\\n</code>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&lt;参数数量&gt; CRLF</span><br><span class=\"line\">$&lt;参数1的字节数量&gt; CRLF</span><br><span class=\"line\">&lt;参数&gt; CRLF</span><br><span class=\"line\">$&lt;参数N的字节数量&gt; CRLF</span><br><span class=\"line\">&lt;参数&gt; CRLF</span><br></pre></td></tr></table></figure>\n<p>响应格式：</p>\n<ul>\n<li><code>+</code> ：状态回复</li>\n<li><code>-</code> ：错误回复</li>\n<li><code>:</code> ：整数回复</li>\n<li><code>$</code> ：字符串回复</li>\n<li><code>*</code> ：多条字符串回复</li>\n</ul>\n<h3 id=\"4-2-Java-客户端Jedis\"><a href=\"#4-2-Java-客户端Jedis\" class=\"headerlink\" title=\"4.2 Java 客户端Jedis\"></a>4.2 Java 客户端Jedis</h3><h4 id=\"4-2-1-连接池配置\"><a href=\"#4-2-1-连接池配置\" class=\"headerlink\" title=\"4.2.1 连接池配置\"></a>4.2.1 连接池配置</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>含义</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>maxActive</td>\n<td>连接池最大连接数</td>\n<td>8</td>\n</tr>\n<tr>\n<td>maxIdle</td>\n<td>连接池最大空闲的连接数</td>\n<td>8</td>\n</tr>\n<tr>\n<td>minIdle</td>\n<td>连接池最少空闲的连接数</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxWaitMillis</td>\n<td>当连接池资源用尽时的最大等待时间（毫秒）</td>\n<td>-1:表示永远不超时</td>\n</tr>\n<tr>\n<td>jmxEnabled</td>\n<td>是否开启jmx 监控，如果应用开启了jmx端口并且jmxEnabled 设置为true，可以通过jconsole 或者 jvisualvm 看到连接池的统计信息</td>\n<td>true</td>\n</tr>\n<tr>\n<td>minEvictableIdleTimeMillis</td>\n<td>做空闲连接检测时，每次的采样数</td>\n<td>3</td>\n</tr>\n<tr>\n<td>testOnBorrow</td>\n<td>向连接池借用连接时是否做连接有效性检测（ping），无效连接会被移除，每次归还还多执行一次ping 命令</td>\n<td>false</td>\n</tr>\n<tr>\n<td>testWhileIdle</td>\n<td>向连接池借用连接时是否做空闲检测，空闲超时的连接会被移除</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeBetweenEvictionRunsMillis</td>\n<td>空闲连接的检测周期（毫秒）</td>\n<td>-1:表示不做检测</td>\n</tr>\n<tr>\n<td>blockWhenExhausted</td>\n<td>当连接池用尽后，调用者是否要等待，当此参数为true时，maxWaitMillis 才会生效</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"4-3-客户端管理\"><a href=\"#4-3-客户端管理\" class=\"headerlink\" title=\"4.3 客户端管理\"></a>4.3 客户端管理</h3><h4 id=\"4-3-1-客户端API\"><a href=\"#4-3-1-客户端API\" class=\"headerlink\" title=\"4.3.1 客户端API\"></a>4.3.1 客户端API</h4><p><code>client list</code>：列出与Redis 服务端相连的所有客户端连接信息</p>\n<ul>\n<li>id：客户端连接的唯一标识，随着Redis 的连接自增，重启Redis 后重置为 0</li>\n<li>addr：客户端连接的ip 和端口</li>\n<li>fd：socket的文件描述符，如果fd=-1代表客户端不是外部的，而是Redis内部的伪装客户端</li>\n<li>name：客户端的名字</li>\n<li>qbuf：输入缓冲区的总容量，输入缓冲区不受maxmemory 控制</li>\n<li>qbuf-free：输入缓冲区的剩余容量 </li>\n<li>obl：固定输出缓冲区的长度（16KB），使用字节数组，用于返回比较小的执行结果</li>\n<li>oll：动态输出缓冲区的长度，使用列表，用于返回比较大的结果</li>\n<li>omem：输出缓冲区一共使用的字节数</li>\n</ul>\n<p>Redis 没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输入内容大小动态调整，只是要求每个客户端缓冲区的大小不能超过 1 G，超过后将被关闭。与输入缓冲区不同的是，输出缓冲区的容量可以通过<code>client-output-buffer-limit</code> 来进行设置：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>&lt;class&gt;：客户端类型：normal：普通客户端；slave：slave客户端；pubsub：发布订阅客户端</li>\n<li>&lt;hard limit&gt;：如果客户端使用的输出缓冲区大于&lt;hard limit&gt;，客户端会被立即关闭</li>\n<li>&lt;soft limit&gt; &lt;soft seconds&gt;：如果客户端使用的输出缓冲区超过了 &lt;soft limit&gt; 并持续了 &lt;soft limit&gt; 秒，客户端会被立即关闭</li>\n</ul>\n<h3 id=\"4-4-客户端常见异常\"><a href=\"#4-4-客户端常见异常\" class=\"headerlink\" title=\"4.4 客户端常见异常\"></a>4.4 客户端常见异常</h3><ol>\n<li>无法从连接池获取到连接：<ul>\n<li>连接池中没有可用的连接并且等待了<code>maxWaitMillis</code> 后也无可用连接</li>\n<li>设置了<code>blockWhenExhausted=false</code> ，当连接池无可用连接直接抛出异常</li>\n</ul>\n</li>\n<li>客户端读写超时：<ul>\n<li>读写时间设置过短</li>\n<li>命令本身比较慢</li>\n<li>客户端与服务器端网络不正常</li>\n<li>Redis自身发生阻塞</li>\n</ul>\n</li>\n<li>客户端连接超时：<ul>\n<li>连接超时时间过短</li>\n<li>Redis发生阻塞，造成<code>tcp-backlog</code> 已满，造成新的连接失败</li>\n<li>客户端与服务器端网络不正常</li>\n</ul>\n</li>\n<li>客户端缓冲区异常：<ul>\n<li>输出缓冲区满</li>\n<li>长时间闲置被服务器端主动断开</li>\n<li>不正常并发读写</li>\n</ul>\n</li>\n<li>Lua脚本正在执行</li>\n<li>Redis正在加载持久化文件</li>\n<li>Redis使用的内存超过了<code>maxmemory</code> </li>\n<li>客户端连接数过大</li>\n</ol>\n<h2 id=\"五、持久化\"><a href=\"#五、持久化\" class=\"headerlink\" title=\"五、持久化\"></a>五、持久化</h2><h4 id=\"5-1-RDB\"><a href=\"#5-1-RDB\" class=\"headerlink\" title=\"5.1 RDB\"></a>5.1 RDB</h4><h5 id=\"5-1-1-触发机制\"><a href=\"#5-1-1-触发机制\" class=\"headerlink\" title=\"5.1.1 触发机制\"></a>5.1.1 触发机制</h5><ul>\n<li>手动触发<ul>\n<li><code>save</code>：阻塞当前服务器，直到RDB过程完成为止</li>\n<li><code>bgsave</code>： fork子进程，RDB持久化过程由子进程完成</li>\n</ul>\n</li>\n<li>自动触发<ul>\n<li>使用<code>save m n</code> 配置，m 秒内数据集存在n 次修改，自动触发bgsave</li>\n<li>从节点执行全量复制操作，主节点自动执行<code>bgsave</code> 生成RDB文件发送给从节点</li>\n<li>执行<code>debug reload</code> 命令重新加载Redis时，也会自动触发<code>save</code> 操作</li>\n<li>默认情况下执行<code>shutdown</code> 命令时，如果没有开启AOF持久化功能则自动执行<code>bgsave</code> </li>\n</ul>\n</li>\n</ul>\n<h5 id=\"5-1-2-RDB的优缺点\"><a href=\"#5-1-2-RDB的优缺点\" class=\"headerlink\" title=\"5.1.2 RDB的优缺点\"></a>5.1.2 RDB的优缺点</h5><p>优点：</p>\n<ul>\n<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，适用于备份，全量复制</li>\n<li>Redis加载RDB恢复数据远比AOF的方式快</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>RDB没办法做到实时持久化/秒级持久化，因为<code>bgsave</code> 每次运行都要fork子进程，成本过高</li>\n<li>RDB使用特定二进制格式保存，可能存在老旧版本Redis无法兼容的问题</li>\n</ul>\n<h4 id=\"5-2-AOF\"><a href=\"#5-2-AOF\" class=\"headerlink\" title=\"5.2 AOF\"></a>5.2 AOF</h4><p>开启AOF功能：<code>appendonly yes</code> ，默认不开启</p>\n<p>AOF的工作流程：</p>\n<ul>\n<li>文件写入：所有的写入命令会追加到aof_buf（缓冲区）中，AOF命令写入的内容是文本协议格式</li>\n<li>文件同步：AOF缓冲区根据对应的策略向硬盘做同步操作</li>\n<li>文件重写：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的</li>\n<li>重启加载：当Redis重启时，可以加载AOF文件进行数据恢复</li>\n</ul>\n<p>文件同步策略：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>always</td>\n<td>命令写入aof_buf后调用系统fsync同步到AOF文件，fsync完成后线程返回</td>\n</tr>\n<tr>\n<td>everysec</td>\n<td>命令写入aof_buf后调用系统write操作，write完成后线程返回，fsync由专门的线程每秒执行一次</td>\n</tr>\n<tr>\n<td>no</td>\n<td>命令写入aof_buf后调用系统write操作，不对AOF文件做fsync操作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>系统调用write和fsync区别：</p>\n<ul>\n<li>write 会触发延迟写机制，系统缓冲区同步至硬盘依赖于系统调度机制。</li>\n<li>fsync针对单个文件操作，做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回</li>\n</ul>\n<p>触发AOF重写：</p>\n<ul>\n<li>手动触发：直接调用<code>bgrewriteaof</code> </li>\n<li>自动触发：根据<code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 参数确定触发时机</li>\n</ul>\n<p><code>auto-aof-rewrite-min-size</code> ：表示运行AOF重写时文件最小体积，默认64M</p>\n<p><code>auto-aof-rewrite-percentage</code> ：当前AOF文件空间（oaf_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值</p>\n<p>自动触发时机=<code>aof_current_size&gt;auto-aof-rewrite-min-sieze &amp;&amp; (aof_current_size - aof_base_size)/aof_base_size &gt;= auto-aof-rewrite_percentage</code> </p>\n<h4 id=\"5-3-重启加载\"><a href=\"#5-3-重启加载\" class=\"headerlink\" title=\"5.3 重启加载\"></a>5.3 重启加载</h4><div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n\n\n<p><script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: Redis启动\nfail=>end: 启动失败\nsuccess=>end: 启动成功\nopen_AOF=>condition: 开启AOF？\nexists_AOF=>condition: 存在AOF？\nexists_RDB=>condition: 存在RDB？\nload_AOF=>operation: 加载AOF\nload_RDB=>operation: 加载RDB\nis_success=>condition: 成功？\n\nst->open_AOF\nopen_AOF(yes)->exists_AOF\nexists_AOF(yes)->load_AOF->is_success\nexists_AOF(no)->exists_RDB\nopen_AOF(no)->exists_RDB\nexists_RDB(yes)->load_RDB->is_success\nis_success(yes)->success\nis_success(no)->fail</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、初识Redis\"><a href=\"#一、初识Redis\" class=\"headerlink\" title=\"一、初识Redis\"></a>一、初识Redis</h2><h3 id=\"1-1-Redis特性\"><a href=\"#1-1-Redis特性\" class=\"headerlink\" title=\"1.1 Redis特性\"></a>1.1 Redis特性</h3><ul>\n<li>速度快：10万/秒</li>\n<li>基于键值对的数据结构服务器</li>\n<li>丰富的功能</li>\n<li>简单稳定</li>\n<li>客户端语言多</li>\n<li>持久化：RDB 和 AOF</li>\n<li>主从复制</li>\n<li>高可用和分布式","more":"</li>\n</ul>\n<h3 id=\"1-2-用好Redis的建议\"><a href=\"#1-2-用好Redis的建议\" class=\"headerlink\" title=\"1.2 用好Redis的建议\"></a>1.2 用好Redis的建议</h3><ol>\n<li>勿当作黑盒使用</li>\n<li>阅读源码</li>\n</ol>\n<h3 id=\"1-3-Redis-基本操作\"><a href=\"#1-3-Redis-基本操作\" class=\"headerlink\" title=\"1.3 Redis 基本操作\"></a>1.3 Redis 基本操作</h3><h4 id=\"1-3-1-配置、启动、操作、关闭\"><a href=\"#1-3-1-配置、启动、操作、关闭\" class=\"headerlink\" title=\"1.3.1 配置、启动、操作、关闭\"></a>1.3.1 配置、启动、操作、关闭</h4><p>Redis 可执行文件说明：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>可执行文件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redis-server</td>\n<td>启动Redis</td>\n</tr>\n<tr>\n<td>redis-cli</td>\n<td>Redis 命令行客户端</td>\n</tr>\n<tr>\n<td>redis-benchmark</td>\n<td>Redis 基准测试工具</td>\n</tr>\n<tr>\n<td>redis-check-aof</td>\n<td>Redis AOF 持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td>redis-check-dump</td>\n<td>Redis RDB 持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td>redis-sentinel</td>\n<td>启动 Redis Sentinel</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis 基础配置：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>配置名</th>\n<th>配置说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>port</td>\n<td>端口</td>\n</tr>\n<tr>\n<td>logfile</td>\n<td>日志文件</td>\n</tr>\n<tr>\n<td>dir</td>\n<td>Redis 工作目录（存放持久化文件和日志文件）</td>\n</tr>\n<tr>\n<td>daemonize</td>\n<td>是否以守护进程的方式启动Redis</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>停止 Redis 服务：<br><code>redis-cli shutdown</code> 用来停止Redis 服务，三点注意：</p>\n<ul>\n<li>Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式</li>\n<li>除了<code>shutdown</code> 命令外，还可以通过<code>kill</code> 进程号的方式关掉Redis，但不可使用 <code>kill -9</code> 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。</li>\n<li><code>shutdown</code> 还有一个参数，代表是否在关闭Redis前，生成持久化文件：<code>redis-cli shutdown nosave|save</code></li>\n</ul>\n<h2 id=\"二、API的理解和使用\"><a href=\"#二、API的理解和使用\" class=\"headerlink\" title=\"二、API的理解和使用\"></a>二、API的理解和使用</h2><h3 id=\"2-1-全局命令\"><a href=\"#2-1-全局命令\" class=\"headerlink\" title=\"2.1 全局命令\"></a>2.1 全局命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>keys *</td>\n<td>查看所有键</td>\n</tr>\n<tr>\n<td>dbsize</td>\n<td>键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量</td>\n</tr>\n<tr>\n<td>exists key</td>\n<td>检查键是否存在</td>\n</tr>\n<tr>\n<td>del key [key …]</td>\n<td>删除键</td>\n</tr>\n<tr>\n<td>expire key seconds</td>\n<td>键过期</td>\n</tr>\n<tr>\n<td>ttl key</td>\n<td>查看键的过期时间</td>\n</tr>\n<tr>\n<td>type key</td>\n<td>键的数据结构类型</td>\n</tr>\n<tr>\n<td>object encoding key</td>\n<td>查询内部编码</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"2-2-数据结构和内部编码\"><a href=\"#2-2-数据结构和内部编码\" class=\"headerlink\" title=\"2.2 数据结构和内部编码\"></a>2.2 数据结构和内部编码</h3><pre class=\"mermaid\">  graph TB\n    key --> string\n    key --> hash\n    key --> list\n    key --> set\n    key --> zset\n    string --> raw\n    string --> int\n    string --> embstr\n    hash --> hashtable_1[hashtable]\n    hash --> ziplist_1[ziplist]\n    list --> linkedlist\n    list --> ziplist_2[ziplist]\n    set --> hashtable_2[hashtable]\n    set --> intset\n    zset --> skiplist\n    zset --> ziplist_3[ziplist]</pre>\n\n<p>Redis这样设计的好处：</p>\n<ul>\n<li>可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势</li>\n<li>多种内部编码实现可以在不同场景下发挥各自的优势</li>\n</ul>\n<h3 id=\"2-3-单线程架构\"><a href=\"#2-3-单线程架构\" class=\"headerlink\" title=\"2.3 单线程架构\"></a>2.3 单线程架构</h3><p>单线程为什么这么快？</p>\n<ul>\n<li>纯内存访问</li>\n<li>非阻塞I/O</li>\n<li>单线程避免了线程切换和竞态的消耗</li>\n</ul>\n<h3 id=\"2-4-字符串\"><a href=\"#2-4-字符串\" class=\"headerlink\" title=\"2.4 字符串\"></a>2.4 字符串</h3><h4 id=\"2-4-1-字符串类型常用命令\"><a href=\"#2-4-1-字符串类型常用命令\" class=\"headerlink\" title=\"2.4.1 字符串类型常用命令\"></a>2.4.1 字符串类型常用命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set key value [ex seconds] [px milliseconds] [nx xx]</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>setnx</td>\n<td>存在设置失败</td>\n</tr>\n<tr>\n<td>setex</td>\n<td>存在才能设置成功</td>\n</tr>\n<tr>\n<td>get key</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>mset key value [key value …]</td>\n<td>批量设置值</td>\n</tr>\n<tr>\n<td>mget key [key …]</td>\n<td>批量获取值</td>\n</tr>\n<tr>\n<td>incr key</td>\n<td>自增操作，值不是整数返回错误，键不存在按照 0 自增</td>\n</tr>\n<tr>\n<td>decr key</td>\n<td>自减操作</td>\n</tr>\n<tr>\n<td>incrby decrby incrbyfloat</td>\n<td>根据数值自增自减</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-4-2-字符串类型不常用命令\"><a href=\"#2-4-2-字符串类型不常用命令\" class=\"headerlink\" title=\"2.4.2 字符串类型不常用命令\"></a>2.4.2 字符串类型不常用命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>append key value</td>\n<td>追加值</td>\n</tr>\n<tr>\n<td>strlen key</td>\n<td>字符串长度</td>\n</tr>\n<tr>\n<td>getset key value</td>\n<td>设置并返回原值</td>\n</tr>\n<tr>\n<td>setrange key offset value</td>\n<td>设置指定位置的字符</td>\n</tr>\n<tr>\n<td>getrange key start end</td>\n<td>获取部分字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-4-3-字符串内部编码\"><a href=\"#2-4-3-字符串内部编码\" class=\"headerlink\" title=\"2.4.3 字符串内部编码\"></a>2.4.3 字符串内部编码</h4><ul>\n<li>int：8 个字节的长整型</li>\n<li>embstr：小于等于 39 个字节的字符串</li>\n<li>raw：大于 39 个字符的字符串</li>\n</ul>\n<h3 id=\"2-5-哈希\"><a href=\"#2-5-哈希\" class=\"headerlink\" title=\"2.5 哈希\"></a>2.5 哈希</h3><h4 id=\"2-5-1-哈希命令\"><a href=\"#2-5-1-哈希命令\" class=\"headerlink\" title=\"2.5.1 哈希命令\"></a>2.5.1 哈希命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hset key field value</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>hget key field</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>hdel key field [field …]</td>\n<td>删除field</td>\n</tr>\n<tr>\n<td>hlen key</td>\n<td>计算field 个数</td>\n</tr>\n<tr>\n<td>hmget key field [field …]</td>\n<td>批量获取field-value</td>\n</tr>\n<tr>\n<td>hmset key field value [field value …]</td>\n<td>批量设置field-value</td>\n</tr>\n<tr>\n<td>hexists key field</td>\n<td>判断field 是否存在</td>\n</tr>\n<tr>\n<td>hkeys key</td>\n<td>获取所有field</td>\n</tr>\n<tr>\n<td>hvals key</td>\n<td>获取所有value</td>\n</tr>\n<tr>\n<td>hgetall key</td>\n<td>获取所有的field-value</td>\n</tr>\n<tr>\n<td>hincrby hincrbyfloat key field</td>\n<td>field 自增</td>\n</tr>\n<tr>\n<td>hstrlen key field</td>\n<td>计算value 的字符串长度</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-5-2-内部编码\"><a href=\"#2-5-2-内部编码\" class=\"headerlink\" title=\"2.5.2 内部编码\"></a>2.5.2 内部编码</h4><ul>\n<li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。</li>\n<li>hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。</li>\n</ul>\n<h3 id=\"2-6-列表\"><a href=\"#2-6-列表\" class=\"headerlink\" title=\"2.6 列表\"></a>2.6 列表</h3><h4 id=\"2-6-1-列表的两个特点：\"><a href=\"#2-6-1-列表的两个特点：\" class=\"headerlink\" title=\"2.6.1 列表的两个特点：\"></a>2.6.1 列表的两个特点：</h4><ul>\n<li>列表中的元素是有序的</li>\n<li>列表中的元素可以是重复的</li>\n</ul>\n<h4 id=\"2-6-2-命令\"><a href=\"#2-6-2-命令\" class=\"headerlink\" title=\"2.6.2 命令\"></a>2.6.2 命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rpush lpush key value [value …]</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>linsert key (before after) pivot value</td>\n<td>插入</td>\n</tr>\n<tr>\n<td>lrange key start end</td>\n<td>查找</td>\n</tr>\n<tr>\n<td>lindex key index</td>\n<td>获取列表指定索引下表的元素</td>\n</tr>\n<tr>\n<td>llen key</td>\n<td>获取列表长度</td>\n</tr>\n<tr>\n<td>lpop rpop key</td>\n<td>弹出元素</td>\n</tr>\n<tr>\n<td>lrem key count value</td>\n<td>删除指定元素，count&gt;0，从左到右；count&lt;0从右到左 删除最多count个元素；count=0，删除所有</td>\n</tr>\n<tr>\n<td>ltrim key start end</td>\n<td>按照索引范围剪切列表</td>\n</tr>\n<tr>\n<td>lset key index newValue</td>\n<td>修改</td>\n</tr>\n<tr>\n<td>blpop brpop key [key …] timeout</td>\n<td>阻塞操作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"2-6-3-内部编码\"><a href=\"#2-6-3-内部编码\" class=\"headerlink\" title=\"2.6.3 内部编码\"></a>2.6.3 内部编码</h4><ul>\n<li>ziplist</li>\n<li>linkedlist</li>\n</ul>\n<h4 id=\"2-6-4-使用场景\"><a href=\"#2-6-4-使用场景\" class=\"headerlink\" title=\"2.6.4 使用场景\"></a>2.6.4 使用场景</h4><ul>\n<li>消息队列</li>\n<li>文章列表</li>\n<li>lpush + lpop = Stack（栈）</li>\n<li>lpush + rpop = Queue（队列）</li>\n<li>lpush + ltrim = Capped Collection（有限集合）</li>\n<li>lpush + brpop = Message Queue（消息队列）</li>\n</ul>\n<h3 id=\"2-7-集合\"><a href=\"#2-7-集合\" class=\"headerlink\" title=\"2.7 集合\"></a>2.7 集合</h3><p>  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。</p>\n<h4 id=\"2-7-1-命令\"><a href=\"#2-7-1-命令\" class=\"headerlink\" title=\"2.7.1 命令\"></a>2.7.1 命令</h4><p>集合内操作：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sadd key ele [ele …]</td>\n<td>添加元素</td>\n</tr>\n<tr>\n<td>srem key ele [ele …]</td>\n<td>删除元素</td>\n</tr>\n<tr>\n<td>scard key</td>\n<td>计算元素个数</td>\n</tr>\n<tr>\n<td>sismember key ele</td>\n<td>判断元素是否在集合中</td>\n</tr>\n<tr>\n<td>srandmember key [count:1]</td>\n<td>随机从集合返回指定个数元素</td>\n</tr>\n<tr>\n<td>spop key</td>\n<td>从集合随机弹出一个元素</td>\n</tr>\n<tr>\n<td>smember key</td>\n<td>获取所有元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>集合间操作：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sinter key [key …]</td>\n<td>求多个结合的交集</td>\n</tr>\n<tr>\n<td>suinon key [key …]</td>\n<td>求多个结合的并集</td>\n</tr>\n<tr>\n<td>sdiff key [key …]</td>\n<td>求多个集合的差集</td>\n</tr>\n<tr>\n<td>sinterstore sunionstore sdiffstore destination key [key …]</td>\n<td>将交集、并集、差集的结果保存</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。</p>\n<h4 id=\"2-7-2-内部编码\"><a href=\"#2-7-2-内部编码\" class=\"headerlink\" title=\"2.7.2 内部编码\"></a>2.7.2 内部编码</h4><ul>\n<li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现</li>\n<li>hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现</li>\n</ul>\n<h4 id=\"2-7-3-使用场景\"><a href=\"#2-7-3-使用场景\" class=\"headerlink\" title=\"2.7.3 使用场景\"></a>2.7.3 使用场景</h4><ul>\n<li>标签</li>\n</ul>\n<h3 id=\"2-8-有序集合\"><a href=\"#2-8-有序集合\" class=\"headerlink\" title=\"2.8 有序集合\"></a>2.8 有序集合</h3><p>  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。</p>\n<h4 id=\"2-8-1-命令\"><a href=\"#2-8-1-命令\" class=\"headerlink\" title=\"2.8.1 命令\"></a>2.8.1 命令</h4><p>集合内：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zadd key score memeber [score memeber …]</td>\n<td>添加成员</td>\n</tr>\n<tr>\n<td>zcard key</td>\n<td>计算成员个数</td>\n</tr>\n<tr>\n<td>zscore key member</td>\n<td>计算某个成员的分数</td>\n</tr>\n<tr>\n<td>zrank zrevrank key member</td>\n<td>计算成员的排名</td>\n</tr>\n<tr>\n<td>zrem key memeber [member …]</td>\n<td>删除成员</td>\n</tr>\n<tr>\n<td>zincrby key increment member</td>\n<td>增加成员的分数</td>\n</tr>\n<tr>\n<td>zrange zrevrange key start end [withscores]</td>\n<td>返回指定排名范围的成员</td>\n</tr>\n<tr>\n<td>zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count]</td>\n<td>返回指定分数范围的成员</td>\n</tr>\n<tr>\n<td>zcount key min max</td>\n<td>返回指定分数范围成员个数</td>\n</tr>\n<tr>\n<td>zremrangebyrank key start end</td>\n<td>删除指定排名内的升序元素</td>\n</tr>\n<tr>\n<td>zremrangebyscore key min max</td>\n<td>删除指定分数范围的成员</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis3.2为zadd添加了nx、xx、ch、incr 四个选项：</p>\n<ul>\n<li>nx：member 必须不存在才能设置成功，用于添加</li>\n<li>xx：member 必须存在才能设置成功，用于更新</li>\n<li>ch：返回此次操作后，有序集合元素和分数变化的个数</li>\n<li>incr：对score做增加，相当于zincrby</li>\n</ul>\n<p>集合间的操作</p>\n<ul>\n<li>交集：<br><code>zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><ul>\n<li>destination：交集计算结果保存在这个键</li>\n<li>numkeys：需要做交集计算键的个数</li>\n<li>key[key …]：需要做交集计算的键</li>\n<li>weights weight[weight …]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1</li>\n<li>aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum</li>\n</ul>\n</li>\n<li>并集：<br><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></li>\n</ul>\n<h4 id=\"2-8-2-内部编码\"><a href=\"#2-8-2-内部编码\" class=\"headerlink\" title=\"2.8.2 内部编码\"></a>2.8.2 内部编码</h4><ul>\n<li>ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现</li>\n<li>skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现</li>\n</ul>\n<h4 id=\"2-8-3-使用场景\"><a href=\"#2-8-3-使用场景\" class=\"headerlink\" title=\"2.8.3 使用场景\"></a>2.8.3 使用场景</h4><ul>\n<li>点赞数</li>\n<li>前十名</li>\n<li>用户分数</li>\n</ul>\n<h3 id=\"2-9-键管理\"><a href=\"#2-9-键管理\" class=\"headerlink\" title=\"2.9 键管理\"></a>2.9 键管理</h3><h4 id=\"2-9-1-单个键管理\"><a href=\"#2-9-1-单个键管理\" class=\"headerlink\" title=\"2.9.1 单个键管理\"></a>2.9.1 单个键管理</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rename key newkey</td>\n<td>键重命名</td>\n</tr>\n<tr>\n<td>renamenx key newkey</td>\n<td>newkey 不存在时重命名</td>\n</tr>\n<tr>\n<td>randomkey</td>\n<td>随机返回一个键</td>\n</tr>\n<tr>\n<td>expire key seconds</td>\n<td>键在seconds 秒后过期</td>\n</tr>\n<tr>\n<td>expireat key timestamp</td>\n<td>键在秒级时间戳timestamp 后过期</td>\n</tr>\n<tr>\n<td>pexpire key milliseconds</td>\n<td>键在milliseconds 毫秒后过期</td>\n</tr>\n<tr>\n<td>pexpireat key milliseconds-timestamp</td>\n<td>键在毫秒级时间戳timestamp 后过期</td>\n</tr>\n<tr>\n<td>move key db</td>\n<td>键内部迁移</td>\n</tr>\n<tr>\n<td>dump key</td>\n<td>键值序列化，采用RDB格式</td>\n</tr>\n<tr>\n<td>restore key ttl value</td>\n<td>反序列化键值</td>\n</tr>\n<tr>\n<td>migrate host port (key “”) destination-db timeout [copy] [replace] [keys key [key …]]</td>\n<td>Redis 实例间进行数据迁移</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis过期命令注意点：</p>\n<ul>\n<li>expire key的键不存在，返回结果为 0</li>\n<li>过期时间如果为负值，键会立即被删除</li>\n<li>persist 可以将键的过期时间清除</li>\n<li>对于字符串类型键，set 命令会去掉过期时间</li>\n<li>Redis 不支持二级数据结构内部元素的过期功能</li>\n<li>setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间</li>\n</ul>\n<p>migrate 参数：</p>\n<ul>\n<li>host：目标Redis 的IP地址</li>\n<li>port：目标Redis 的端口</li>\n<li>key|””：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”</li>\n<li>destination：目标Redis 的数据库索引</li>\n<li>timeout：迁移的超时时间（毫秒）</li>\n<li>[copy]：添加后，迁移不删除源键</li>\n<li>[replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖</li>\n<li>[keys key[key …]]：迁移多个键</li>\n</ul>\n<h4 id=\"2-9-2-遍历键\"><a href=\"#2-9-2-遍历键\" class=\"headerlink\" title=\"2.9.2 遍历键\"></a>2.9.2 遍历键</h4><ul>\n<li><code>keys pattern</code>：全量遍历键<br>keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：<ul>\n<li>在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制</li>\n<li>如果确认键值总数确实比较少，可以执行该命令</li>\n<li>使用scan 命令，可以有效防止阻塞</li>\n</ul>\n</li>\n<li><code>scan cursor [match pattern] [count number]</code>：渐进式遍历<ul>\n<li>curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束</li>\n<li>match pattern：可选参数，匹配正则</li>\n<li>count number：可选参数，每次要遍历的键个数，默认是 10</li>\n</ul>\n</li>\n</ul>\n<p>除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan</p>\n<h4 id=\"2-9-3-数据库管理\"><a href=\"#2-9-3-数据库管理\" class=\"headerlink\" title=\"2.9.3 数据库管理\"></a>2.9.3 数据库管理</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>select dbIndex</td>\n<td>切换数据库，Redis默认配置中有16个数据库</td>\n</tr>\n<tr>\n<td>flushdb</td>\n<td>清除当前数据库</td>\n</tr>\n<tr>\n<td>flushall</td>\n<td>清除所有数据库</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>  <strong>注意</strong>：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：</p>\n<ul>\n<li>Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响</li>\n<li>多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库</li>\n<li>部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱</li>\n</ul>\n<h2 id=\"三、小功能大用处\"><a href=\"#三、小功能大用处\" class=\"headerlink\" title=\"三、小功能大用处\"></a>三、小功能大用处</h2><h3 id=\"3-1-慢查询分析\"><a href=\"#3-1-慢查询分析\" class=\"headerlink\" title=\"3.1 慢查询分析\"></a>3.1 慢查询分析</h3><p>Redis 提供了<code>slowlog-log-slower-than</code> 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config set slowlog-log-slower-than 20000</span><br><span class=\"line\">config set slowlog-max-len 1000</span><br><span class=\"line\">config rewrite</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取慢查询日志</span></span><br><span class=\"line\">slowlog get [n]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取慢查询日志列表当前的长度</span></span><br><span class=\"line\">slowlog len</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 慢查询日志重置</span></span><br><span class=\"line\">slowlog reset</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-2-redis-cli-详解\"><a href=\"#3-2-redis-cli-详解\" class=\"headerlink\" title=\"3.2 redis-cli 详解\"></a>3.2 redis-cli 详解</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-r</td>\n<td>命令执行多次</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>每隔几秒执行一次</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>从标准输入读取数据作为最后一个参数</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>连接Redis Cluster 节点时使用</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>Redis 配置了命令时使用</td>\n</tr>\n<tr>\n<td>—scan 和 —pattern</td>\n<td>用于扫描指定模式的键</td>\n</tr>\n<tr>\n<td>—slave</td>\n<td>把当前客户端模拟成当前Redis 节点的从节点</td>\n</tr>\n<tr>\n<td>—rdb</td>\n<td>请求Redis实例生成并发送RDB持久化文件保存到本地</td>\n</tr>\n<tr>\n<td>—pipe</td>\n<td>批量执行Redis 命令</td>\n</tr>\n<tr>\n<td>—bigkeys</td>\n<td>使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值</td>\n</tr>\n<tr>\n<td>—eval</td>\n<td>执行Lua 脚本</td>\n</tr>\n<tr>\n<td>—latency</td>\n<td>检测网络延迟</td>\n</tr>\n<tr>\n<td>—latency-history</td>\n<td>分时段了解延迟信息</td>\n</tr>\n<tr>\n<td>—latency-dist</td>\n<td>使用统计图表输出延迟统计信息</td>\n</tr>\n<tr>\n<td>—stat</td>\n<td>实时获取Redis 的重要统计信息</td>\n</tr>\n<tr>\n<td>—no-raw</td>\n<td>要求命令的返回结果必须是原始的格式</td>\n</tr>\n<tr>\n<td>—raw</td>\n<td>要求命令的返回结果是转换后的格式</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-3-redis-server-详解\"><a href=\"#3-3-redis-server-详解\" class=\"headerlink\" title=\"3.3 redis-server 详解\"></a>3.3 redis-server 详解</h3><p>参数 <code>--test-memory</code> 用来检测当前系统能否稳定的分配指定容量的内存给Redis</p>\n<h3 id=\"3-4-redis-benchmark-详解\"><a href=\"#3-4-redis-benchmark-详解\" class=\"headerlink\" title=\"3.4 redis-benchmark 详解\"></a>3.4 redis-benchmark 详解</h3><p>redis-benchmark 可以为Redis做基准性能测试</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>客户端的并发数（默认50）</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>客户端请求总量（默认100000）</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>插入随机的键做测试</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>每个请求pipeline 的数据量（默认1）</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>是否使用keepalive，1为使用，0为不使用</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>对指定命令进行基准测试</td>\n</tr>\n<tr>\n<td>—csv</td>\n<td>将结果按照csv格式输出</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-5-Pipeline\"><a href=\"#3-5-Pipeline\" class=\"headerlink\" title=\"3.5 Pipeline\"></a>3.5 Pipeline</h3><p>有效节约RTT（Round Trip Time，往返时间）</p>\n<h3 id=\"3-6-事务与Lua\"><a href=\"#3-6-事务与Lua\" class=\"headerlink\" title=\"3.6 事务与Lua\"></a>3.6 事务与Lua</h3><p>Redis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。</p>\n<h4 id=\"3-6-1-不同错误下的处理机制\"><a href=\"#3-6-1-不同错误下的处理机制\" class=\"headerlink\" title=\"3.6.1 不同错误下的处理机制\"></a>3.6.1 不同错误下的处理机制</h4><ol>\n<li>命令错误：整个事务无法执行</li>\n<li>运行时异常：不支持回滚</li>\n</ol>\n<h4 id=\"3-6-2-Lua\"><a href=\"#3-6-2-Lua\" class=\"headerlink\" title=\"3.6.2 Lua\"></a>3.6.2 Lua</h4><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 没有local代表是全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> strings val = <span class=\"string\">\"world\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(val)</span><br><span class=\"line\"><span class=\"comment\">-- 表格，下标从 1 开始</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> tables myArray = &#123;<span class=\"string\">\"redis\"</span>, <span class=\"string\">\"jedis\"</span>, <span class=\"literal\">true</span>, <span class=\"number\">88.0</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myArray[<span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">-- for循环</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    sum = sum + i</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #myArray</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(myArray[i])</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- ipairs函数，返回索引下标和值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,value <span class=\"keyword\">in</span> <span class=\"built_in\">ipairs</span>(myArray)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(index)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- while</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt;= <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    sum = sum + <span class=\"number\">1</span></span><br><span class=\"line\">    i = i + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum)</span><br><span class=\"line\"><span class=\"comment\">-- if else</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #myArray</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> myArray[i] == <span class=\"string\">\"jedis\"</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"true\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">-- do nothing</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 哈希</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> tables user_1 = &#123;age = <span class=\"number\">28</span>, name = <span class=\"string\">\"tom\"</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"user_1 age is\"</span> .. user_1[<span class=\"string\">\"age\"</span>])</span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(user_1)</span><br><span class=\"line\"><span class=\"keyword\">do</span> <span class=\"built_in\">print</span>(key .. value)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">contact</span><span class=\"params\">(str1, str2)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str1 .. str2</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(contact(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-6-3-Redis中使用Lua\"><a href=\"#3-6-3-Redis中使用Lua\" class=\"headerlink\" title=\"3.6.3 Redis中使用Lua\"></a>3.6.3 Redis中使用Lua</h4><ul>\n<li>eval<br>Redis 中执行<code>eval script key_num keys args</code>:<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; eval 'return \"hello \" .. KEYS[1] .. ARGV[1]' 1 redis world</span><br></pre></td></tr></table></figure>\n如果Lua 脚本较长，可以使用redis-cli —eval 直接执行文件</li>\n<li>evalsha<br>首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli script load \"$(cat lua_get.lua)\"</span><br><span class=\"line\">evalsha sha1_value key_num keys args</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-6-4-Lua的Redis-API\"><a href=\"#3-6-4-Lua的Redis-API\" class=\"headerlink\" title=\"3.6.4 Lua的Redis API\"></a>3.6.4 Lua的Redis API</h4><p>Lua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis.call(<span class=\"string\">\"set\"</span>, <span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>)</span><br><span class=\"line\">redis.call(<span class=\"string\">\"get\"</span>, <span class=\"string\">\"hello\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-6-5-Redis-如何管理Lua脚本\"><a href=\"#3-6-5-Redis-如何管理Lua脚本\" class=\"headerlink\" title=\"3.6.5 Redis 如何管理Lua脚本\"></a>3.6.5 Redis 如何管理Lua脚本</h4><ul>\n<li><code>script load script</code>：将Lua 脚本加载到Redis内存中</li>\n<li><code>script exists sha1</code>：判断sha1 是否已经加载到Redis内存中</li>\n<li><code>script flush</code>：清除已经加载的所有Lua脚本</li>\n<li><code>script kill</code>：用于杀掉正在执行的Lua脚本，Redis 提供了<code>lua-time-limit</code> 参数，默认是 5 秒，但只是当Lua 脚本时间超过<code>lua-time-limit</code> 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，<code>script kill</code> 将不会生效，此时要么等待脚本结束要么使用 <code>shutdown save</code> 停掉Redis服务</li>\n</ul>\n<h3 id=\"3-7-Bitmaps\"><a href=\"#3-7-Bitmaps\" class=\"headerlink\" title=\"3.7 Bitmaps\"></a>3.7 Bitmaps</h3><ul>\n<li>Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作</li>\n<li>Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量</li>\n</ul>\n<h4 id=\"3-7-1-Bitmaps命令\"><a href=\"#3-7-1-Bitmaps命令\" class=\"headerlink\" title=\"3.7.1 Bitmaps命令\"></a>3.7.1 Bitmaps命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setbit key offset value</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>getbit key offset</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>bitcount [start] [end]</td>\n<td>获取Bitmaps 指定范围为 1 的个数</td>\n</tr>\n<tr>\n<td>bitop op destkey key[key …]</td>\n<td>Bitmaps间的运算: and、or、not、xor</td>\n</tr>\n<tr>\n<td>bitpos key targetBit [start] [end]</td>\n<td>计算Bitmaps中第一个值为targetBit的偏移量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-8-HyperLogLog\"><a href=\"#3-8-HyperLogLog\" class=\"headerlink\" title=\"3.8 HyperLogLog\"></a>3.8 HyperLogLog</h3><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pfadd key element [element …]</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>pfcount key [key …]</td>\n<td>去重计数，存在一定误差</td>\n</tr>\n<tr>\n<td>pfmerge destkey sourcekey [sourcekey …]</td>\n<td>合并</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在选择HyperLogLog 时，需要确认两点：</p>\n<ul>\n<li>只是为了计算独立总数，不需要获取单条数据</li>\n<li>可以容忍一定误差</li>\n</ul>\n<h3 id=\"3-9-发布订阅\"><a href=\"#3-9-发布订阅\" class=\"headerlink\" title=\"3.9 发布订阅\"></a>3.9 发布订阅</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>publish channel message</td>\n<td>发布消息</td>\n</tr>\n<tr>\n<td>subscribe channel [channel …]</td>\n<td>订阅消息</td>\n</tr>\n<tr>\n<td>unsubscribe [channel [channel …]]</td>\n<td>取消订阅</td>\n</tr>\n<tr>\n<td>psubscribe pattern [pattern …]</td>\n<td>按照模式订阅</td>\n</tr>\n<tr>\n<td>punsubscribe [pattern [pattern …]]</td>\n<td>按照模式取消订阅</td>\n</tr>\n<tr>\n<td>pubsub channels [pattern]</td>\n<td>查看活跃的频道</td>\n</tr>\n<tr>\n<td>pubsub numsub [channel …]</td>\n<td>查看频道订阅数</td>\n</tr>\n<tr>\n<td>pubsub numpat</td>\n<td>查看模式订阅数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>订阅命令的注意点：</p>\n<ul>\n<li>客户端执行订阅命令之后进入了了订阅状态，只能接收<code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>这四个命令</li>\n<li>新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化</li>\n</ul>\n<p>活跃的频道是指当前频道至少有一个订阅者</p>\n<h3 id=\"3-10-GEO（地理信息定位）\"><a href=\"#3-10-GEO（地理信息定位）\" class=\"headerlink\" title=\"3.10 GEO（地理信息定位）\"></a>3.10 GEO（地理信息定位）</h3><p>Redis3.2 版本提供了GEO功能。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>geoadd key longitude latitude member [longitude latitude memeber …]</td>\n<td>增加地理位置信息</td>\n</tr>\n<tr>\n<td>geopos key member [memeber …]</td>\n<td>获取地理位置信息</td>\n</tr>\n<tr>\n<td>geodist key member1 member2 [unit]</td>\n<td>获取两个地理位置的距离</td>\n</tr>\n<tr>\n<td>georadius key longitude latitude radiusm &#124; km &#124; ft &#124; mi [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>\n<td>获取指定位置范围内的地理信息位置集合</td>\n</tr>\n<tr>\n<td>georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>\n<td>获取指定位置范围内的成员信息</td>\n</tr>\n<tr>\n<td>geohash key member [member …]</td>\n<td>获取geohash</td>\n</tr>\n<tr>\n<td>zrem key member</td>\n<td>删除地理位置信息</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>参数：</p>\n<ul>\n<li>withcoord：返回结果中包含经纬度</li>\n<li>withdist：返回结果中包含离中心节点位置的距离</li>\n<li>withhash：返回结果中包含geohash</li>\n<li>COUNT count：指定返回结果的数量</li>\n<li>asc&#124;desc：返回结果按照离中心节点的距离做升序或者降序</li>\n<li>store key：将返回结果的地理位置信息保存到指定键</li>\n<li>storedist key: 将返回结果离中心节点的距离保存到指定键</li>\n</ul>\n<p><code>geohash</code>的特点：</p>\n<ul>\n<li>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中</li>\n<li>字符串越长，表示的位置更精确</li>\n<li>两个字符串越相似，它们之间的距离越近</li>\n<li>geohash编码和经纬度是可以互换的</li>\n</ul>\n<h2 id=\"四、客户端\"><a href=\"#四、客户端\" class=\"headerlink\" title=\"四、客户端\"></a>四、客户端</h2><h3 id=\"4-1-客户端通信协议\"><a href=\"#4-1-客户端通信协议\" class=\"headerlink\" title=\"4.1 客户端通信协议\"></a>4.1 客户端通信协议</h3><ol>\n<li>客户端与服务器端之间的通信协议建立在TCP之上</li>\n<li>Redis制定了RESP（REdis Serialization Protocol）</li>\n</ol>\n<p>命令格式（CRLF：<code>\\r\\n</code>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&lt;参数数量&gt; CRLF</span><br><span class=\"line\">$&lt;参数1的字节数量&gt; CRLF</span><br><span class=\"line\">&lt;参数&gt; CRLF</span><br><span class=\"line\">$&lt;参数N的字节数量&gt; CRLF</span><br><span class=\"line\">&lt;参数&gt; CRLF</span><br></pre></td></tr></table></figure>\n<p>响应格式：</p>\n<ul>\n<li><code>+</code> ：状态回复</li>\n<li><code>-</code> ：错误回复</li>\n<li><code>:</code> ：整数回复</li>\n<li><code>$</code> ：字符串回复</li>\n<li><code>*</code> ：多条字符串回复</li>\n</ul>\n<h3 id=\"4-2-Java-客户端Jedis\"><a href=\"#4-2-Java-客户端Jedis\" class=\"headerlink\" title=\"4.2 Java 客户端Jedis\"></a>4.2 Java 客户端Jedis</h3><h4 id=\"4-2-1-连接池配置\"><a href=\"#4-2-1-连接池配置\" class=\"headerlink\" title=\"4.2.1 连接池配置\"></a>4.2.1 连接池配置</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>含义</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>maxActive</td>\n<td>连接池最大连接数</td>\n<td>8</td>\n</tr>\n<tr>\n<td>maxIdle</td>\n<td>连接池最大空闲的连接数</td>\n<td>8</td>\n</tr>\n<tr>\n<td>minIdle</td>\n<td>连接池最少空闲的连接数</td>\n<td>0</td>\n</tr>\n<tr>\n<td>maxWaitMillis</td>\n<td>当连接池资源用尽时的最大等待时间（毫秒）</td>\n<td>-1:表示永远不超时</td>\n</tr>\n<tr>\n<td>jmxEnabled</td>\n<td>是否开启jmx 监控，如果应用开启了jmx端口并且jmxEnabled 设置为true，可以通过jconsole 或者 jvisualvm 看到连接池的统计信息</td>\n<td>true</td>\n</tr>\n<tr>\n<td>minEvictableIdleTimeMillis</td>\n<td>做空闲连接检测时，每次的采样数</td>\n<td>3</td>\n</tr>\n<tr>\n<td>testOnBorrow</td>\n<td>向连接池借用连接时是否做连接有效性检测（ping），无效连接会被移除，每次归还还多执行一次ping 命令</td>\n<td>false</td>\n</tr>\n<tr>\n<td>testWhileIdle</td>\n<td>向连接池借用连接时是否做空闲检测，空闲超时的连接会被移除</td>\n<td>false</td>\n</tr>\n<tr>\n<td>timeBetweenEvictionRunsMillis</td>\n<td>空闲连接的检测周期（毫秒）</td>\n<td>-1:表示不做检测</td>\n</tr>\n<tr>\n<td>blockWhenExhausted</td>\n<td>当连接池用尽后，调用者是否要等待，当此参数为true时，maxWaitMillis 才会生效</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"4-3-客户端管理\"><a href=\"#4-3-客户端管理\" class=\"headerlink\" title=\"4.3 客户端管理\"></a>4.3 客户端管理</h3><h4 id=\"4-3-1-客户端API\"><a href=\"#4-3-1-客户端API\" class=\"headerlink\" title=\"4.3.1 客户端API\"></a>4.3.1 客户端API</h4><p><code>client list</code>：列出与Redis 服务端相连的所有客户端连接信息</p>\n<ul>\n<li>id：客户端连接的唯一标识，随着Redis 的连接自增，重启Redis 后重置为 0</li>\n<li>addr：客户端连接的ip 和端口</li>\n<li>fd：socket的文件描述符，如果fd=-1代表客户端不是外部的，而是Redis内部的伪装客户端</li>\n<li>name：客户端的名字</li>\n<li>qbuf：输入缓冲区的总容量，输入缓冲区不受maxmemory 控制</li>\n<li>qbuf-free：输入缓冲区的剩余容量 </li>\n<li>obl：固定输出缓冲区的长度（16KB），使用字节数组，用于返回比较小的执行结果</li>\n<li>oll：动态输出缓冲区的长度，使用列表，用于返回比较大的结果</li>\n<li>omem：输出缓冲区一共使用的字节数</li>\n</ul>\n<p>Redis 没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输入内容大小动态调整，只是要求每个客户端缓冲区的大小不能超过 1 G，超过后将被关闭。与输入缓冲区不同的是，输出缓冲区的容量可以通过<code>client-output-buffer-limit</code> 来进行设置：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>&lt;class&gt;：客户端类型：normal：普通客户端；slave：slave客户端；pubsub：发布订阅客户端</li>\n<li>&lt;hard limit&gt;：如果客户端使用的输出缓冲区大于&lt;hard limit&gt;，客户端会被立即关闭</li>\n<li>&lt;soft limit&gt; &lt;soft seconds&gt;：如果客户端使用的输出缓冲区超过了 &lt;soft limit&gt; 并持续了 &lt;soft limit&gt; 秒，客户端会被立即关闭</li>\n</ul>\n<h3 id=\"4-4-客户端常见异常\"><a href=\"#4-4-客户端常见异常\" class=\"headerlink\" title=\"4.4 客户端常见异常\"></a>4.4 客户端常见异常</h3><ol>\n<li>无法从连接池获取到连接：<ul>\n<li>连接池中没有可用的连接并且等待了<code>maxWaitMillis</code> 后也无可用连接</li>\n<li>设置了<code>blockWhenExhausted=false</code> ，当连接池无可用连接直接抛出异常</li>\n</ul>\n</li>\n<li>客户端读写超时：<ul>\n<li>读写时间设置过短</li>\n<li>命令本身比较慢</li>\n<li>客户端与服务器端网络不正常</li>\n<li>Redis自身发生阻塞</li>\n</ul>\n</li>\n<li>客户端连接超时：<ul>\n<li>连接超时时间过短</li>\n<li>Redis发生阻塞，造成<code>tcp-backlog</code> 已满，造成新的连接失败</li>\n<li>客户端与服务器端网络不正常</li>\n</ul>\n</li>\n<li>客户端缓冲区异常：<ul>\n<li>输出缓冲区满</li>\n<li>长时间闲置被服务器端主动断开</li>\n<li>不正常并发读写</li>\n</ul>\n</li>\n<li>Lua脚本正在执行</li>\n<li>Redis正在加载持久化文件</li>\n<li>Redis使用的内存超过了<code>maxmemory</code> </li>\n<li>客户端连接数过大</li>\n</ol>\n<h2 id=\"五、持久化\"><a href=\"#五、持久化\" class=\"headerlink\" title=\"五、持久化\"></a>五、持久化</h2><h4 id=\"5-1-RDB\"><a href=\"#5-1-RDB\" class=\"headerlink\" title=\"5.1 RDB\"></a>5.1 RDB</h4><h5 id=\"5-1-1-触发机制\"><a href=\"#5-1-1-触发机制\" class=\"headerlink\" title=\"5.1.1 触发机制\"></a>5.1.1 触发机制</h5><ul>\n<li>手动触发<ul>\n<li><code>save</code>：阻塞当前服务器，直到RDB过程完成为止</li>\n<li><code>bgsave</code>： fork子进程，RDB持久化过程由子进程完成</li>\n</ul>\n</li>\n<li>自动触发<ul>\n<li>使用<code>save m n</code> 配置，m 秒内数据集存在n 次修改，自动触发bgsave</li>\n<li>从节点执行全量复制操作，主节点自动执行<code>bgsave</code> 生成RDB文件发送给从节点</li>\n<li>执行<code>debug reload</code> 命令重新加载Redis时，也会自动触发<code>save</code> 操作</li>\n<li>默认情况下执行<code>shutdown</code> 命令时，如果没有开启AOF持久化功能则自动执行<code>bgsave</code> </li>\n</ul>\n</li>\n</ul>\n<h5 id=\"5-1-2-RDB的优缺点\"><a href=\"#5-1-2-RDB的优缺点\" class=\"headerlink\" title=\"5.1.2 RDB的优缺点\"></a>5.1.2 RDB的优缺点</h5><p>优点：</p>\n<ul>\n<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，适用于备份，全量复制</li>\n<li>Redis加载RDB恢复数据远比AOF的方式快</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>RDB没办法做到实时持久化/秒级持久化，因为<code>bgsave</code> 每次运行都要fork子进程，成本过高</li>\n<li>RDB使用特定二进制格式保存，可能存在老旧版本Redis无法兼容的问题</li>\n</ul>\n<h4 id=\"5-2-AOF\"><a href=\"#5-2-AOF\" class=\"headerlink\" title=\"5.2 AOF\"></a>5.2 AOF</h4><p>开启AOF功能：<code>appendonly yes</code> ，默认不开启</p>\n<p>AOF的工作流程：</p>\n<ul>\n<li>文件写入：所有的写入命令会追加到aof_buf（缓冲区）中，AOF命令写入的内容是文本协议格式</li>\n<li>文件同步：AOF缓冲区根据对应的策略向硬盘做同步操作</li>\n<li>文件重写：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的</li>\n<li>重启加载：当Redis重启时，可以加载AOF文件进行数据恢复</li>\n</ul>\n<p>文件同步策略：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>策略</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>always</td>\n<td>命令写入aof_buf后调用系统fsync同步到AOF文件，fsync完成后线程返回</td>\n</tr>\n<tr>\n<td>everysec</td>\n<td>命令写入aof_buf后调用系统write操作，write完成后线程返回，fsync由专门的线程每秒执行一次</td>\n</tr>\n<tr>\n<td>no</td>\n<td>命令写入aof_buf后调用系统write操作，不对AOF文件做fsync操作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>系统调用write和fsync区别：</p>\n<ul>\n<li>write 会触发延迟写机制，系统缓冲区同步至硬盘依赖于系统调度机制。</li>\n<li>fsync针对单个文件操作，做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回</li>\n</ul>\n<p>触发AOF重写：</p>\n<ul>\n<li>手动触发：直接调用<code>bgrewriteaof</code> </li>\n<li>自动触发：根据<code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 参数确定触发时机</li>\n</ul>\n<p><code>auto-aof-rewrite-min-size</code> ：表示运行AOF重写时文件最小体积，默认64M</p>\n<p><code>auto-aof-rewrite-percentage</code> ：当前AOF文件空间（oaf_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值</p>\n<p>自动触发时机=<code>aof_current_size&gt;auto-aof-rewrite-min-sieze &amp;&amp; (aof_current_size - aof_base_size)/aof_base_size &gt;= auto-aof-rewrite_percentage</code> </p>\n<h4 id=\"5-3-重启加载\"><a href=\"#5-3-重启加载\" class=\"headerlink\" title=\"5.3 重启加载\"></a>5.3 重启加载</h4><div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n\n\n<p><script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: Redis启动\nfail=>end: 启动失败\nsuccess=>end: 启动成功\nopen_AOF=>condition: 开启AOF？\nexists_AOF=>condition: 存在AOF？\nexists_RDB=>condition: 存在RDB？\nload_AOF=>operation: 加载AOF\nload_RDB=>operation: 加载RDB\nis_success=>condition: 成功？\n\nst->open_AOF\nopen_AOF(yes)->exists_AOF\nexists_AOF(yes)->load_AOF->is_success\nexists_AOF(no)->exists_RDB\nopen_AOF(no)->exists_RDB\nexists_RDB(yes)->load_RDB->is_success\nis_success(yes)->success\nis_success(no)->fail</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckabq6gh400013fgr48642rg8","category_id":"ckabq6gha00043fgr1eir061j","_id":"ckabq6ghc00083fgr95ivax1b"},{"post_id":"ckabq6ggw00003fgrgb7xa4fk","category_id":"ckabq6gh700023fgr24tk3xh4","_id":"ckabq6ghd000a3fgr0puahya8"},{"post_id":"ckabq6ggw00003fgrgb7xa4fk","category_id":"ckabq6ghb00063fgr9hct56pf","_id":"ckabq6ghe000c3fgr72oia75y"},{"post_id":"ckabq6ghk000l3fgrcyz4fqg3","category_id":"ckabq6ghm000o3fgr32q81t1c","_id":"ckabq6ghq000u3fgrclfc4xpy"},{"post_id":"ckabq6ghl000n3fgr9i8zgrip","category_id":"ckabq6ghm000o3fgr32q81t1c","_id":"ckabq6ghq000w3fgrg39h7e03"},{"post_id":"ckabq6ghs000x3fgrf9v88154","category_id":"ckabq6ght000y3fgr41bo1amb","_id":"ckabq6ghu00113fgrhloqb7tf"}],"PostTag":[{"post_id":"ckabq6ggw00003fgrgb7xa4fk","tag_id":"ckabq6gh800033fgrffkea1kb","_id":"ckabq6ghe000d3fgr37uw4shc"},{"post_id":"ckabq6ggw00003fgrgb7xa4fk","tag_id":"ckabq6gha00053fgr7vmof2e2","_id":"ckabq6ghf000e3fgrbluw6xke"},{"post_id":"ckabq6ggw00003fgrgb7xa4fk","tag_id":"ckabq6ghb00073fgrcpy123ov","_id":"ckabq6ghg000g3fgr8ik15tvj"},{"post_id":"ckabq6ggw00003fgrgb7xa4fk","tag_id":"ckabq6ghc00093fgrfqp1fych","_id":"ckabq6ghg000h3fgrcch690p9"},{"post_id":"ckabq6gh400013fgr48642rg8","tag_id":"ckabq6ghd000b3fgrc8831149","_id":"ckabq6ghh000i3fgrgkgwawl1"},{"post_id":"ckabq6gh400013fgr48642rg8","tag_id":"ckabq6ghf000f3fgre0ml950p","_id":"ckabq6ghh000j3fgrbl6vhcq6"},{"post_id":"ckabq6ghk000l3fgrcyz4fqg3","tag_id":"ckabq6ghc00093fgrfqp1fych","_id":"ckabq6ghm000p3fgr60t8cvhk"},{"post_id":"ckabq6ghl000n3fgr9i8zgrip","tag_id":"ckabq6ghn000r3fgr36xp59r6","_id":"ckabq6ghq000t3fgr6e12fqhr"},{"post_id":"ckabq6ghl000n3fgr9i8zgrip","tag_id":"ckabq6ghc00093fgrfqp1fych","_id":"ckabq6ghq000v3fgr7gkp7aao"},{"post_id":"ckabq6ghs000x3fgrf9v88154","tag_id":"ckabq6ght000z3fgr0kwb3h5b","_id":"ckabq6ghu00103fgr08gk2hbz"}],"Tag":[{"name":"同余","_id":"ckabq6gh800033fgrffkea1kb"},{"name":"一次不定方程","_id":"ckabq6gha00053fgr7vmof2e2"},{"name":"欧几里得","_id":"ckabq6ghb00073fgrcpy123ov"},{"name":"算法","_id":"ckabq6ghc00093fgrfqp1fych"},{"name":"hexo","_id":"ckabq6ghd000b3fgrc8831149"},{"name":"markdown","_id":"ckabq6ghf000f3fgre0ml950p"},{"name":"随机数","_id":"ckabq6ghn000r3fgr36xp59r6"},{"name":"Redis","_id":"ckabq6ght000z3fgr0kwb3h5b"}]}}