{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/assets/algorithm/04.svg","path":"assets/algorithm/04.svg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"source/assets/algorithm/03.png","path":"assets/algorithm/03.png","modified":0,"renderable":0},{"_id":"source/assets/algorithm/01.png","path":"assets/algorithm/01.png","modified":0,"renderable":0},{"_id":"source/assets/algorithm/02.png","path":"assets/algorithm/02.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1587055855329},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1587055855330},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1587055855329},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1587055855337},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1587055855339},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1587055855336},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1587055855337},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1587055855340},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1587055855338},{"_id":"themes/next/_config.yml","hash":"c1cb0cc65aea367bdd8db847422229ff062530c3","modified":1587427071893},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1587055855394},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1587055855356},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1587054800229},{"_id":"source/categories/index.md","hash":"51ff0ae81f57c8e58464c6fb32b430573aa33e22","modified":1587181459930},{"_id":"source/_posts/算法导论.md","hash":"074fda82363a7fdf738eb84c712a8f9cb55c167f","modified":1587599296417},{"_id":"source/_posts/Redis开发与运维.md","hash":"4dce42dba05557dc544f70f4b04f1a106007b077","modified":1587703437610},{"_id":"source/tags/index.md","hash":"4c5aeb7a632cb63bae0b5c187c8950fe6037463e","modified":1587181721224},{"_id":"source/about/index.md","hash":"dca949d158de1ea08a7389821f840fa8419653be","modified":1587099531131},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1587055855330},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1587055855333},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1587055855330},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1587055855333},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1587055855333},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1587055855334},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1587055855333},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1587055855335},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1587055855335},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1587055855335},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1587055855334},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1587055855342},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1587055855342},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1587055855343},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1587055855343},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1587055855344},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1587055855341},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1587055855342},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1587055855401},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1587055855343},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1587055855345},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1587055855356},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1587055855357},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1587055855357},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1587055855357},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1587055855358},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1587055855358},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1587055855358},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1587055855358},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1587055855359},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1587055855359},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1587055855359},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1587055855359},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1587055855360},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1587055855360},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1587055855361},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1587055855361},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1587055855362},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1587055855357},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1587055855363},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1587055855362},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1587055855363},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1587055855363},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1587055855362},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1587055855392},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1587055855390},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1587055855391},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1587055855390},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1587055855393},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1587055855393},{"_id":"source/assets/algorithm/04.svg","hash":"66ec2cae90df9579e07f2be76f3e60d6cfdec1e4","modified":1587376462561},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1587055855331},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1587055855331},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1587055855331},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1587055855331},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1587055855346},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1587055855345},{"_id":"themes/next/scripts/events/index.js","hash":"bf5e93f9209d111a014a7a6a17e86c05be552d13","modified":1587055855395},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1587055855346},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1587055855346},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1587055855347},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1587055855353},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1587055855352},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1587055855352},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1587055855351},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1587055855354},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1587055855355},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1587055855355},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1587055855356},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1587055855398},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1587055855398},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1587055855398},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1587055855399},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1587055855399},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1587055855400},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1587055855400},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1587055855400},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1587055855401},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1587055855401},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1587055855402},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1587055855402},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1587055855402},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1587055855402},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1587055855403},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1587055855403},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1587055855403},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1587055855404},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1587055855404},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1587055855405},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1587055855460},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1587055855441},{"_id":"themes/next/source/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1587055855467},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1587055855468},{"_id":"themes/next/source/js/local-search.js","hash":"d6673063958127a03881dab2f0376a47f5e08a88","modified":1587055855468},{"_id":"themes/next/source/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1587055855469},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1587055855469},{"_id":"themes/next/source/js/utils.js","hash":"91d174e12c61c332f3b06085d635c2b0f686a758","modified":1587055855471},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1587055855472},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1587055855461},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1587055855461},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1587055855463},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1587055855462},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1587055855463},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1587055855463},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1587055855464},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1587055855464},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1587055855465},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1587055855465},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1587055855466},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1587055855466},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1587055855466},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1587055855365},{"_id":"themes/next/layout/_partials/footer.swig","hash":"700c3e7bd449bce51f6faee42c052e13ed5f8b3e","modified":1587055855366},{"_id":"source/assets/algorithm/03.png","hash":"49be660d577b7757cfd954c1b45dd95ac7ae67d7","modified":1587376462561},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1587055855369},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1587055855370},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1587055855374},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1587055855364},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1587055855364},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1587055855365},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1587055855381},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1587055855384},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1587055855383},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1587055855378},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1587055855374},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1587055855374},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1587055855375},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1587055855376},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1587055855377},{"_id":"source/assets/algorithm/01.png","hash":"a8d86fa0c263caa76780166efb208ebb9d1cdf73","modified":1587376462560},{"_id":"source/assets/algorithm/02.png","hash":"445c721e21315bf93c0ffddf5f2bfa6fe4615df1","modified":1587376462560},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1587055855395},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1587055855395},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1587055855395},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1587055855396},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1587055855396},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1587055855397},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1587055855397},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1587055855397},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1587055855397},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1587055855397},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1587055855398},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1587055855454},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1587055855459},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1587055855455},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1587055855454},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1587055855460},{"_id":"themes/next/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1587055855470},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1587055855471},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1587055855482},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1587055855479},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1587055855367},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1587055855368},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1587055855368},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1587055855368},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1587055855369},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1587055855367},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1587055855367},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1587055855370},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1587055855371},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1587055855369},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1587055855371},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1587055855371},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1587055855372},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1587055855371},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1587055855373},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1587055855373},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1587055855372},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1587055855372},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1587055855377},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1587055855378},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1587055855378},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1587055855378},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1587055855380},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1587055855379},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1587055855380},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1587055855380},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1587055855381},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1587055855379},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1587055855381},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1587055855379},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1587055855382},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1587055855382},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1587055855383},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1587055855385},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1587055855386},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1587055855386},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1587055855390},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1587055855390},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1587055855375},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1587055855387},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1587055855387},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1587055855388},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1587055855389},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1587055855389},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1587055855375},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1587055855376},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1587055855376},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1587055855376},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1587055855409},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1587055855409},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1587055855409},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1587055855421},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1587055855442},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1587055855445},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1587055855446},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1587055855446},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1587055855447},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1587055855446},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1587055855449},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1587055855448},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1587055855448},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1587055855450},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1587055855450},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1587055855450},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1587055855429},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1587055855430},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1587055855430},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1587055855433},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1587055855435},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1587055855434},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b3bea92eef0e1fe2e7e294dac2184d16b5b8d666","modified":1587055855436},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1587055855441},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1587055855451},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1587055855452},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1587055855452},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1587055855453},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1587055855453},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1587055855453},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1587055855426},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1587055855426},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1587055855473},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1587055855474},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1587055855475},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1587055855473},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1587055855413},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1587055855414},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1587055855414},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1587055855413},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1587055855414},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1587055855422},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1587055855422},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1587055855422},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1587055855423},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1587055855416},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1587055855415},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1587055855423},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1587055855417},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1587055855417},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1587055855418},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1587055855419},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1587055855419},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1587055855420},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1587055855419},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1587055855420},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1587055855421},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1587055855420},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1587055855431},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1587055855432},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1587055855420},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1587055855433},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1587055855432},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1587055855436},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1587055855439},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1587055855438},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1587055855439},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1587055855439},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1587055855440},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1587055855437},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1587055855423},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1587055855424},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1587055855424},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1587055855425},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1587055855424},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1587055855425},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1587055855425},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1587055855427},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1587055855427},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1587055855427},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1587055855426},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1587055855428},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1587055855429},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1587055855424},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1587055855429},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1587055855428},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1587055855429},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1587055855428},{"_id":"public/categories/index.html","hash":"95cc07c9fcd8554d655ff3ef40ec0d71399acad4","modified":1587599328008},{"_id":"public/tags/index.html","hash":"03742803a44dc0b278acdbae05cce5a8dff8e10c","modified":1587599328008},{"_id":"public/about/index.html","hash":"d008636952fa4c0fb2806f16d3989f54e42e2347","modified":1587599328008},{"_id":"public/archives/index.html","hash":"8316dfc2af8be3c2578ed324f26d555637c15446","modified":1587599328008},{"_id":"public/archives/2020/index.html","hash":"b7e3e4d17cf47e40a030eff55e3b97bea63813fd","modified":1587599328008},{"_id":"public/archives/2020/04/index.html","hash":"8fb379442f13d52d40bc52d02fa1002bd1e55687","modified":1587599328008},{"_id":"public/categories/算法/index.html","hash":"466cc33d25608cda1627eef8a7f56187e633fe56","modified":1587599328008},{"_id":"public/categories/分布式组件/index.html","hash":"c6301284afb639b913c1c9ae8de9bce67f1f025a","modified":1587599328008},{"_id":"public/tags/算法/index.html","hash":"79bb497ecd1938beb344334a3355c48df7fca968","modified":1587599328008},{"_id":"public/tags/Redis/index.html","hash":"bd730b0f6602143c1f783bcce4e9e45202a6f0f3","modified":1587599328008},{"_id":"public/2020/04/20/算法导论/index.html","hash":"972f7f1dcee3cf256ce207761c4fc00c4a3c31ca","modified":1587599328008},{"_id":"public/2020/04/17/Redis开发与运维/index.html","hash":"47d50d40f16b37c79d023301390771e2652100ef","modified":1587599328008},{"_id":"public/2020/04/17/hello-world/index.html","hash":"3f6bc1a7718d88e112135a15684245acbef53c89","modified":1587599328008},{"_id":"public/index.html","hash":"f93051d2f71316bdad90786ba0f6f5da87aa8952","modified":1587599328008},{"_id":"public/assets/algorithm/04.svg","hash":"66ec2cae90df9579e07f2be76f3e60d6cfdec1e4","modified":1587599328008},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1587599328008},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1587599328008},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1587599328008},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1587599328008},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1587599328008},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1587599328008},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1587599328008},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1587599328008},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1587599328008},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1587599328008},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1587599328008},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1587599328008},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1587599328008},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1587599328008},{"_id":"public/assets/algorithm/01.png","hash":"a8d86fa0c263caa76780166efb208ebb9d1cdf73","modified":1587599328008},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1587599328008},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1587599328008},{"_id":"public/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1587599328008},{"_id":"public/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1587599328008},{"_id":"public/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1587599328008},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1587599328008},{"_id":"public/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1587599328008},{"_id":"public/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1587599328008},{"_id":"public/css/main.css","hash":"daaea4a60cb1dfd8d10a7e036d0167e076c155a1","modified":1587599328008},{"_id":"public/assets/algorithm/03.png","hash":"49be660d577b7757cfd954c1b45dd95ac7ae67d7","modified":1587599328008},{"_id":"public/assets/algorithm/02.png","hash":"445c721e21315bf93c0ffddf5f2bfa6fe4615df1","modified":1587599328008},{"_id":"public/js/local-search.js","hash":"d6673063958127a03881dab2f0376a47f5e08a88","modified":1587599328008},{"_id":"public/js/utils.js","hash":"91d174e12c61c332f3b06085d635c2b0f686a758","modified":1587599328008},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1587599328008},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1587599328008},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1587599328008},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1587599328008},{"_id":"source/_posts/.Redis开发与运维.md.swp","hash":"4a3b1bee13cbe8dbd9458f1d6e2ee3536e13f364","modified":1587703103487}],"Category":[{"name":"算法","_id":"ck9bzne4r0004hywi6vn13x8a"},{"name":"分布式组件","_id":"ck9bzne7s000ahywi9jso82id"}],"Data":[],"Page":[{"title":"categories","date":"2020-04-18T03:43:49.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-04-18 11:43:49\ntype: \"categories\"\n---\n","updated":"2020-04-18T03:44:19.930Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck9bzne4e0001hywi6im7a0il","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-04-18T03:48:23.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-04-18 11:48:23\ntype: \"tags\"\n---\n","updated":"2020-04-18T03:48:41.224Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck9bzne4m0003hywifyrm6uli","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"About me","date":"2020-04-17T04:37:08.000Z","_content":":email: wangchao_mooniew@163.com\n","source":"about/index.md","raw":"---\ntitle: About me\ndate: 2020-04-17 12:37:08\n---\n:email: wangchao_mooniew@163.com\n","updated":"2020-04-17T04:58:51.131Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck9bzne6k0008hywiehn549a1","content":"<p>:email: wangchao_mooniew@163.com</p>\n","site":{"data":{}},"excerpt":"","more":"<p>:email: wangchao_mooniew@163.com</p>\n"}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-04-16T16:33:20.229Z","updated":"2020-04-16T16:33:20.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9bzne420000hywi9yooau1i","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"算法导论","date":"2020-04-20T09:41:44.000Z","_content":"\n## 第一部分 基础知识\n\n### 算法基础\n\n#### 插入排序\n\n ![insert_sort](/assets/algorithm/02.png)\n\n<!-- more -->\n\n#### 算法分析\n\n- 运行时间：基本操作数或步数\n- 最坏情况与平均情况分析\n- 增长量级 \n\n#### 设计算法\n\n分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。\n\n每层递归都有三个步骤：\n\n1. 分解原问题为若干子问题\n2. 解决这些子问题\n3. 合并这些子问题的解成原问题的解\n\n![merge_sort](/assets/algorithm/03.png)\n\n### 函数的增长\n\n### 分治策略\n\n三种求解递归式的方法：\n- 代入法：猜测一个界，然后用数学归纳法证明这个界是正确的\n- 递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价\n- 主方法：可求解如下公式的递归式的界：\n  $$\n  T(n) = aT(n/b) + f(n)\n  $$\n  其中 $a \\ge 1, b \\gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。\n\n#### 最大字数组问题\n- 暴力求解算法\n  两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ \n- 分治策略求解算法\n  将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：\n  - 左字数组\n  - 右字数组\n  - 跨越中点的字数组\n\n  ![04.svg](/assets/algorithm/04.svg) \n\n\n\n\n","source":"_posts/算法导论.md","raw":"---\ntitle: 算法导论\ndate: 2020-04-20 17:41:44\ntags: 算法\ncategories:\n- 算法\n---\n\n## 第一部分 基础知识\n\n### 算法基础\n\n#### 插入排序\n\n ![insert_sort](/assets/algorithm/02.png)\n\n<!-- more -->\n\n#### 算法分析\n\n- 运行时间：基本操作数或步数\n- 最坏情况与平均情况分析\n- 增长量级 \n\n#### 设计算法\n\n分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。\n\n每层递归都有三个步骤：\n\n1. 分解原问题为若干子问题\n2. 解决这些子问题\n3. 合并这些子问题的解成原问题的解\n\n![merge_sort](/assets/algorithm/03.png)\n\n### 函数的增长\n\n### 分治策略\n\n三种求解递归式的方法：\n- 代入法：猜测一个界，然后用数学归纳法证明这个界是正确的\n- 递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价\n- 主方法：可求解如下公式的递归式的界：\n  $$\n  T(n) = aT(n/b) + f(n)\n  $$\n  其中 $a \\ge 1, b \\gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。\n\n#### 最大字数组问题\n- 暴力求解算法\n  两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ \n- 分治策略求解算法\n  将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：\n  - 左字数组\n  - 右字数组\n  - 跨越中点的字数组\n\n  ![04.svg](/assets/algorithm/04.svg) \n\n\n\n\n","slug":"算法导论","published":1,"updated":"2020-04-22T23:48:16.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9bzne4h0002hywi5uupgmlh","content":"<h2 id=\"第一部分-基础知识\"><a href=\"#第一部分-基础知识\" class=\"headerlink\" title=\"第一部分 基础知识\"></a>第一部分 基础知识</h2><h3 id=\"算法基础\"><a href=\"#算法基础\" class=\"headerlink\" title=\"算法基础\"></a>算法基础</h3><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p> <img src=\"/assets/algorithm/02.png\" alt=\"insert_sort\"></p>\n<a id=\"more\"></a>\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>运行时间：基本操作数或步数</li>\n<li>最坏情况与平均情况分析</li>\n<li>增长量级 </li>\n</ul>\n<h4 id=\"设计算法\"><a href=\"#设计算法\" class=\"headerlink\" title=\"设计算法\"></a>设计算法</h4><p>分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>\n<p>每层递归都有三个步骤：</p>\n<ol>\n<li>分解原问题为若干子问题</li>\n<li>解决这些子问题</li>\n<li>合并这些子问题的解成原问题的解</li>\n</ol>\n<p><img src=\"/assets/algorithm/03.png\" alt=\"merge_sort\"></p>\n<h3 id=\"函数的增长\"><a href=\"#函数的增长\" class=\"headerlink\" title=\"函数的增长\"></a>函数的增长</h3><h3 id=\"分治策略\"><a href=\"#分治策略\" class=\"headerlink\" title=\"分治策略\"></a>分治策略</h3><p>三种求解递归式的方法：</p>\n<ul>\n<li>代入法：猜测一个界，然后用数学归纳法证明这个界是正确的</li>\n<li>递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价</li>\n<li>主方法：可求解如下公式的递归式的界：<script type=\"math/tex; mode=display\">\nT(n) = aT(n/b) + f(n)</script>其中 $a \\ge 1, b \\gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。</li>\n</ul>\n<h4 id=\"最大字数组问题\"><a href=\"#最大字数组问题\" class=\"headerlink\" title=\"最大字数组问题\"></a>最大字数组问题</h4><ul>\n<li>暴力求解算法<br>两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ </li>\n<li><p>分治策略求解算法<br>将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：</p>\n<ul>\n<li>左字数组</li>\n<li>右字数组</li>\n<li>跨越中点的字数组</li>\n</ul>\n<p><img src=\"/assets/algorithm/04.svg\" alt=\"04.svg\"> </p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"第一部分-基础知识\"><a href=\"#第一部分-基础知识\" class=\"headerlink\" title=\"第一部分 基础知识\"></a>第一部分 基础知识</h2><h3 id=\"算法基础\"><a href=\"#算法基础\" class=\"headerlink\" title=\"算法基础\"></a>算法基础</h3><h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p> <img src=\"/assets/algorithm/02.png\" alt=\"insert_sort\"></p>","more":"<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>运行时间：基本操作数或步数</li>\n<li>最坏情况与平均情况分析</li>\n<li>增长量级 </li>\n</ul>\n<h4 id=\"设计算法\"><a href=\"#设计算法\" class=\"headerlink\" title=\"设计算法\"></a>设计算法</h4><p>分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>\n<p>每层递归都有三个步骤：</p>\n<ol>\n<li>分解原问题为若干子问题</li>\n<li>解决这些子问题</li>\n<li>合并这些子问题的解成原问题的解</li>\n</ol>\n<p><img src=\"/assets/algorithm/03.png\" alt=\"merge_sort\"></p>\n<h3 id=\"函数的增长\"><a href=\"#函数的增长\" class=\"headerlink\" title=\"函数的增长\"></a>函数的增长</h3><h3 id=\"分治策略\"><a href=\"#分治策略\" class=\"headerlink\" title=\"分治策略\"></a>分治策略</h3><p>三种求解递归式的方法：</p>\n<ul>\n<li>代入法：猜测一个界，然后用数学归纳法证明这个界是正确的</li>\n<li>递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价</li>\n<li>主方法：可求解如下公式的递归式的界：<script type=\"math/tex; mode=display\">\nT(n) = aT(n/b) + f(n)</script>其中 $a \\ge 1, b \\gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。</li>\n</ul>\n<h4 id=\"最大字数组问题\"><a href=\"#最大字数组问题\" class=\"headerlink\" title=\"最大字数组问题\"></a>最大字数组问题</h4><ul>\n<li>暴力求解算法<br>两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ </li>\n<li><p>分治策略求解算法<br>将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：</p>\n<ul>\n<li>左字数组</li>\n<li>右字数组</li>\n<li>跨越中点的字数组</li>\n</ul>\n<p><img src=\"/assets/algorithm/04.svg\" alt=\"04.svg\"> </p>\n</li>\n</ul>"},{"title":"Redis开发与运维","date":"2020-04-17T14:37:20.000Z","_content":"\n## 初识Redis\n\n### Redis特性\n- 速度快：10万/秒\n- 基于键值对的数据结构服务器\n- 丰富的功能\n- 简单稳定\n- 客户端语言多\n- 持久化：RDB 和 AOF\n- 主从复制\n- 高可用和分布式\n<!--more-->\n\n速度快的原因：\n  - 数据存放于内存中\n  - C语言编写\n  - 单线程，避免多线程产生的竞争问题\n\nReids的功能：\n  - 键过期功能\n  - 发布订阅功能\n  - 支持Lua 脚本\n  - 提供了简单的事务\n  - 提供了流水线（Pipeline）功能\n\n### 用好Redis的建议\n1. 勿当作黑盒使用\n2. 阅读源码\n\n### Redis 基本操作\n\n#### 安装\n  - Linux 上通过源码安装\n  - Mac 上通过Brew 安装\n\n#### 配置、启动、操作、关闭\n\nRedis 可执行文件说明：\n\n| 可执行文件 | 作用 |\n|--|--|\n| redis-server | 启动Redis |\n| redis-cli | Redis 命令行客户端 |\n| redis-benchmark | Redis 基准测试工具 |\n| redis-check-aof | Redis AOF 持久化文件检测和修复工具 |\n| redis-check-dump | Redis RDB 持久化文件检测和修复工具 |\n| redis-sentinel | 启动 Redis Sentinel |\n\nRedis 基础配置：\n\n| 配置名 | 配置说明 |\n|--|--|\n| port | 端口 |\n| logfile | 日志文件 |\n| dir | Redis 工作目录（存放持久化文件和日志文件）|\n| daemonize | 是否以守护进程的方式启动Redis |\n\n停止 Redis 服务：\n`redis-cli shutdown` 用来停止Redis 服务，三点注意：\n- Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式\n- 除了`shutdown` 命令外，还可以通过`kill` 进程号的方式关掉Redis，但不可使用 `kill -9` 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。\n- `shutdown` 还有一个参数，代表是否在关闭Redis前，生成持久化文件：`redis-cli shutdown nosave|save`\n\n### Redis 版本\n  版本号第二位如果是奇数为非稳定版本，偶数代表稳定版本\n\n## API的理解和使用\n\n### 全局命令\n\n| 命令 | 作用 |\n|--|--|\n| keys * | 查看所有键 |\n| dbsize | 键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量 |\n| exists key | 检查键是否存在 |\n| del key [key ...] | 删除键 |\n| expire key seconds | 键过期 |\n| ttl key | 查看键的过期时间 |\n| type key | 键的数据结构类型 |\n| object encoding key | 查询内部编码 |\n\n### 数据结构和内部编码\n\n```mermaid\n  graph TB\n    key --> string\n    key --> hash\n    key --> list\n    key --> set\n    key --> zset\n    string --> raw\n    string --> int\n    string --> embstr\n    hash --> hashtable_1[hashtable]\n    hash --> ziplist_1[ziplist]\n    list --> linkedlist\n    list --> ziplist_2[ziplist]\n    set --> hashtable_2[hashtable]\n    set --> intset\n    zset --> skiplist\n    zset --> ziplist_3[ziplist]\n```\n\nRedis这样设计的好处：\n- 可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势\n- 多种内部编码实现可以在不同场景下发挥各自的优势\n\n### 单线程架构\n单线程为什么这么快？\n  - 纯内存访问\n  - 非阻塞I/O\n  - 单线程避免了线程切换和竞态的消耗\n\n### 字符串\n\n#### 字符串类型常用命令\n| 命令 | 作用 |\n|--|--|\n| set key value [ex seconds] [px milliseconds] [nx xx] | 设置值 |\n| setnx | 存在设置失败 |\n| setex | 存在才能设置成功 |\n| get key | 获取值 |\n| mset key value [key value ...] | 批量设置值 |\n| mget key [key ...] | 批量获取值 |\n| incr key | 自增操作，值不是整数返回错误，键不存在按照 0 自增 |\n| decr key | 自减操作 |\n| incrby decrby incrbyfloat | 根据数值自增自减 |\n\n#### 字符串类型不常用命令\n| 命令 | 作用 |\n|--|--|\n| append key value | 追加值 |\n| strlen key | 字符串长度 |\n| getset key value | 设置并返回原值 |\n| setrange key offset value | 设置指定位置的字符 |\n| getrange key start end | 获取部分字符串 |\n\n#### 字符串内部编码\n  - int：8 个字节的长整型\n  - embstr：小于等于 39 个字节的字符串\n  - raw：大于 39 个字符的字符串\n\n### 哈希\n\n#### 哈希命令\n| 命令 | 作用 |\n|--|--|\n| hset key field value | 设置值 |\n| hget key field | 获取值 |\n| hdel key field [field ...] | 删除field |\n| hlen key | 计算field 个数 |\n| hmget key field [field ...] | 批量获取field-value |\n| hmset key field value [field value ...] | 批量设置field-value |\n| hexists key field | 判断field 是否存在 |\n| hkeys key | 获取所有field |\n| hvals key | 获取所有value |\n| hgetall key | 获取所有的field-value |\n| hincrby hincrbyfloat key field | field 自增 |\n| hstrlen key field | 计算value 的字符串长度 |\n\n#### 内部编码\n  - ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有指都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。\n  - hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。\n\n### 列表\n\n#### 列表的两个特点：\n  - 列表中的元素是有序的\n  - 列表中的元素可以是重复的\n\n#### 命令\n| 命令 | 作用 |\n|--|--|\n| rpush lpush key value [value ...] | 添加 |\n| linsert key (before after) pivot value | 插入 |\n| lrange key start end | 查找 |\n| lindex key index | 获取列表指定索引下表的元素 |\n| llen key | 获取列表长度 |\n| lpop rpop key | 弹出元素|\n| lrem key count value | 删除指定元素，count>0，从左到右；count<0从右到左 删除最多count个元素；count=0，删除所有|\n| ltrim key start end | 按照索引范围剪切列表 |\n| lset key index newValue | 修改 |\n| blpop brpop key [key ...] timeout | 阻塞操作 |\n\n#### 内部编码\n  - ziplist\n  - linkedlist\n\n#### 使用场景\n  - 消息队列\n  - 文章列表\n  - lpush + lpop = Stack（栈）\n  - lpush + rpop = Queue（队列）\n  - lpush + ltrim = Capped Collection（有限集合）\n  - lpush + brpop = Message Queue（消息队列）\n\n### 集合\n  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。\n\n#### 命令\n集合内操作：\n\n| 命令 | 作用 |\n|--|--|\n| sadd key ele [ele ...] | 添加元素 |\n| srem key ele [ele ...] | 删除元素 |\n| scard key | 计算元素个数 |\n| sismember key ele | 判断元素是否在集合中 |\n| srandmember key [count:1] | 随机从集合返回指定个数元素 |\n| spop key | 从集合随机弹出一个元素 |\n| smember key | 获取所有元素 |\n\n集合间操作：\n\n| 命令 | 作用 |\n|--|--|\n| sinter key [key ...] | 求多个结合的交集 |\n| suinon key [key ...] | 求多个结合的并集 |\n| sdiff key [key ...] | 求多个集合的差集 |\n| sinterstore sunionstore sdiffstore destination key [key ...] | 将交集、并集、差集的结果保存 |\n\n集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。\n\n#### 内部编码\n  - intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现\n  - hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现\n\n#### 使用场景\n  - 标签\n\n### 有序集合\n  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。\n\n#### 命令\n集合内：\n\n| 命令 | 作用 |\n|--|--|\n| zadd key score memeber [score memeber ...] | 添加成员 |\n| zcard key | 计算成员个数 |\n| zscore key member | 计算某个成员的分数 |\n| zrank zrevrank key member | 计算成员的排名 |\n| zrem key memeber [member ...] | 删除成员 |\n| zincrby key increment member | 增加成员的分数 |\n| zrange zrevrange key start end [withscores] | 返回指定排名范围的成员 |\n| zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count] | 返回指定分数范围的成员 |\n| zcount key min max | 返回指定分数范围成员个数 |\n| zremrangebyrank key start end | 删除指定排名内的升序元素 |\n| zremrangebyscore key min max | 删除指定分数范围的成员 |\n\nRedis3.2为zadd添加了nx、xx、ch、incr 四个选项：\n  - nx：member 必须不存在才能设置成功，用于添加\n  - xx：member 必须存在才能设置成功，用于更新\n  - ch：返回此次操作后，有序集合元素和分数变化的个数\n  - incr：对score做增加，相当于zincrby\n\n集合间的操作\n  - 交集：\n    `zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`\n    - destination：交集计算结果保存在这个键\n    - numkeys：需要做交集计算键的个数\n    - key[key ...]：需要做交集计算的键\n    - weights weight[weight ...]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1\n    - aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum\n  - 并集：\n    `zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`\n\n#### 内部编码\n  - ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现\n  - skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现\n\n#### 使用场景\n  - 点赞数\n  - 前十名\n  - 用户分数\n\n### 键管理\n\n#### 单个键管理\n| 命令 | 作用 |\n|--|--|\n| rename key newkey | 键重命名 |\n| renamenx key newkey | newkey 不存在时重命名 |\n| randomkey | 随机返回一个键 |\n| expire key seconds | 键在seconds 秒后过期 |\n| expireat key timestamp | 键在秒级时间戳timestamp 后过期 |\n| pexpire key milliseconds | 键在milliseconds 毫秒后过期 |\n| pexpireat key milliseconds-timestamp | 键在毫秒级时间戳timestamp 后过期 |\n| move key db | 键内部迁移 |\n| dump key | 键值序列化，采用RDB格式 |\n| restore key ttl value | 反序列化键值 |\n| migrate host port (key \"\") destination-db timeout [copy] [replace] [keys key [key ...]] | Redis 实例间进行数据迁移 |\n\nRedis过期命令注意点：\n  - expire key的键不存在，返回结果为 0\n  - 过期时间如果为负值，键会立即被删除\n  - persist 可以将键的过期时间清除\n  - 对于字符串类型键，set 命令会去掉过期时间\n  - Redis 不支持二级数据结构内部元素的过期功能\n  - setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间\n\nmigrate 参数：\n  - host：目标Redis 的IP地址\n  - port：目标Redis 的端口\n  - key|\"\"：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”\n  - destination：目标Redis 的数据库索引\n  - timeout：迁移的超时时间（毫秒）\n  - [copy]：添加后，迁移不删除源键\n  - [replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖\n  - [keys key[key ...]]：迁移多个键\n\n#### 遍历键\n- `keys pattern`：全量遍历键\n  keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：\n    - 在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制\n    - 如果确认键值总数确实比较少，可以执行该命令\n    - 使用scan 命令，可以有效防止阻塞\n- `scan cursor [match pattern] [count number]`：渐进式遍历\n  - curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束\n  - match pattern：可选参数，匹配正则\n  - count number：可选参数，每次要遍历的键个数，默认是 10\n\n除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan\n\n#### 数据库管理\n| 命令 | 作用 |\n|--|--|\n| select dbIndex | 切换数据库，Redis默认配置中有16个数据库 |\n| flushdb | 清除当前数据库 |\n| flushall | 清除所有数据库 |\n\n  **注意**：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：\n  - Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响\n  - 多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库\n  - 部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱\n\n## 小功能大用处\n\n### 慢查询分析\nRedis 提供了`slowlog-log-slower-than` 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数\n```shell\nconfig set slowlog-log-slower-than 20000\nconfig set slowlog-max-len 1000\nconfig rewrite\n# 获取慢查询日志\nslowlog get [n]\n# 获取慢查询日志列表当前的长度\nslowlog len\n# 慢查询日志重置\nslowlog reset\n```\n\n### redis-cli 详解\n| 参数 | 作用 |\n|--|--|\n| -r | 命令执行多次 |\n| -i | 每隔几秒执行一次 |\n| -x | 从标准输入读取数据作为最后一个参数 |\n| -c | 连接Redis Cluster 节点时使用 |\n| -a | Redis 配置了命令时使用 |\n| --scan 和 --pattern | 用于扫描指定模式的键 |\n| --slave | 把当前客户端模拟成当前Redis 节点的从节点 |\n| --rdb | 请求Redis实例生成并发送RDB持久化文件保存到本地 |\n| --pipe | 批量执行Redis 命令 |\n| --bigkeys | 使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值 |\n| --eval | 执行Lua 脚本 |\n| --latency | 检测网络延迟 |\n| --latency-history | 分时段了解延迟信息 |\n| --latency-dist | 使用统计图表输出延迟统计信息 |\n| --stat | 实时获取Redis 的重要统计信息 |\n| --no-raw | 要求命令的返回结果必须是原始的格式 |\n| --raw | 要求命令的返回结果是转换后的格式 |\n\n### redis-server 详解\n参数 `--test-memory` 用来检测当前系统能否稳定的分配指定容量的内存给Redis\n\n### redis-benchmark 详解\nredis-benchmark 可以为Redis做基准性能测试\n\n| 参数 | 作用 |\n|--|--|\n| -c | 客户端的并发数（默认50）|\n| -n | 客户端请求总量（默认100000）|\n| -r | 插入随机的键做测试 |\n| -P | 每个请求pipeline 的数据量（默认1）|\n| -k | 是否使用keepalive，1为使用，0为不使用 |\n| -t | 对指定命令进行基准测试 |\n| --csv | 将结果按照csv格式输出 |\n\n### Pipeline\n有效节约RTT（Round Trip Time，往返时间）\n\n### 事务与Lua\nRedis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。\n\n#### 不同错误下的处理机制\n1. 命令错误：整个事务无法执行\n2. 运行时异常：不支持回滚\n\n#### Lua\n```lua\n-- 没有local代表是全局变量\nlocal strings val = \"world\"\nprint(val)\n-- 表格，下标从 1 开始\nlocal tables myArray = {\"redis\", \"jedis\", true, 88.0}\nprint(myArray[3])\n-- for循环\nlocal int sum = 0\nfor i = 1, 100\ndo\n    sum = sum + i\nend\nprint(sum)\nfor i = 1, #myArray\ndo\n    print(myArray[i])\nend\n-- ipairs函数，返回索引下标和值\nfor index,value in ipairs(myArray)\ndo\n    print(index)\n    print(value)\nend\n-- while\nlocal int sum = 0\nlocal int i = 0\nwhile i <= 100\ndo\n    sum = sum + 1\n    i = i + 1\nend\nprint(sum)\n-- if else\nfor i = 1, #myArray\ndo\n    if myArray[i] == \"jedis\"\n    then\n        print(\"true\")\n        break\n    else\n        -- do nothing\n    end\nend\n-- 哈希\nlocal tables user_1 = {age = 28, name = \"tom\"}\nprint(\"user_1 age is\" .. user_1[\"age\"])\nfor key,value in pairs(user_1)\ndo print(key .. value)\nend\n-- 函数定义\nfunction contact(str1, str2)\n    return str1 .. str2\nend\nprint(contact(\"hello\", \"world\"))\n```\n\n#### Redis中使用Lua\n- eval\n  Redis 中执行`eval script key_num keys args`:\n  ```shell\n  127.0.0.1:6379> eval 'return \"hello \" .. KEYS[1] .. ARGV[1]' 1 redis world\n  ```\n  如果Lua 脚本较长，可以使用redis-cli --eval 直接执行文件\n- evalsha\n  首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销\n  ```shell\n  redis-cli script load \"$(cat lua_get.lua)\"\n  evalsha sha1_value key_num keys args\n  ```\n\n#### Lua的Redis API\nLua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本\n```lua\nredis.call(\"set\", \"hello\", \"world\")\nredis.call(\"get\", \"hello\")\n```\n\n#### Redis 如何管理Lua脚本\n- `script load script`：将Lua 脚本加载到Redis内存中\n- `script exists sha1`：判断sha1 是否已经加载到Redis内存中\n- `script flush`：清除已经加载的所有Lua脚本\n- `script kill`：用于杀掉正在执行的Lua脚本，Redis 提供了`lua-time-limit` 参数，默认是 5 秒，但只是当Lua 脚本时间超过`lua-time-limit` 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，`script kill` 将不会生效，此时要么等待脚本结束要么使用 `shutdown save` 停掉Redis服务\n\n### Bitmaps\n- Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作\n- Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量\n\n#### Bitmaps命令\n| 命令 | 作用 |\n|--|--|\n| setbit key offset value | 设置值 |\n| getbit key offset | 获取值 |\n| bitcount [start] [end] | 获取Bitmaps 指定范围为 1 的个数 |\n| bitop op destkey key[key ...] | Bitmaps间的运算: and、or、not、xor |\n| bitpos key targetBit [start] [end] | 计算Bitmaps中第一个值为targetBit的偏移量 |\n\n### HyperLogLog\nHyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。\n\n| 命令 | 作用 |\n|--|--|\n| pfadd key element [element ...] | 添加 |\n| pfcount key [key ...] | 去重计数，存在一定误差 |\n| pfmerge destkey sourcekey [sourcekey ...] | 合并 |\n\n在选择HyperLogLog 时，需要确认两点：\n- 只是为了计算独立总数，不需要获取单条数据\n- 可以容忍一定误差\n\n### 发布订阅\n\n| 命令 | 作用 |\n|--|--|\n| publish channel message | 发布消息 |\n| subscribe channel [channel ...] | 订阅消息 |\n| unsubscribe [channel [channel ...]] | 取消订阅 |\n| psubscribe pattern [pattern ...] | 按照模式订阅 |\n| punsubscribe [pattern [pattern ...]] | 按照模式取消订阅 |\n| pubsub channels [pattern] | 查看活跃的频道 |\n| pubsub numsub [channel ...] | 查看频道订阅数 |\n| pubsub numpat | 查看模式订阅数 |\n\n订阅命令的注意点：\n- 客户端执行订阅命令之后进入了了订阅状态，只能接收`subscribe`、`psubscribe`、`unsubscribe`、`punsubscribe`这四个命令\n- 新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化\n\n活跃的频道是指当前频道至少有一个订阅者\n\n### GEO（地理信息定位）\nRedis3.2 版本提供了GEO功能。\n\n| 命令 | 作用 |\n|--|--|\n| geoadd key longitude latitude member [longitude latitude memeber ...] | 增加地理位置信息 |\n| geopos key member [memeber ...] | 获取地理位置信息 |\n| geodist key member1 member2 [unit] | 获取两个地理位置的距离 |\n| georadius key longitude latitude (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key] | 获取指定位置范围内的地理信息位置集合 |\n| georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key] | 获取指定位置范围内的成员信息 |\n| geohash key member [member ...] | 获取geohash |\n| zrem key member | 删除地理位置信息 |\n\n参数：\n- withcoord：返回结果中包含经纬度\n- withdist：返回结果中包含离中心节点位置的距离\n- withhash：返回结果中包含geohash\n- COUNT count：指定返回结果的数量\n- asc\\|desc：返回结果按照离中心节点的距离做升序或者降序\n- store key：将返回结果的地理位置信息保存到指定键\n- storedist key: 将返回结果离中心节点的距离保存到指定键\n\n`geohash`的特点：\n- GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中\n- 字符串越长，表示的位置更精确\n- 两个字符串越相似，它们之间的距离越近\n- geohash编码和经纬度是可以互换的\n\n## 客户端\n\n","source":"_posts/Redis开发与运维.md","raw":"---\ntitle: Redis开发与运维\ndate: 2020-04-17 22:37:20\ntags: Redis\ncategories:\n- 分布式组件\n---\n\n## 初识Redis\n\n### Redis特性\n- 速度快：10万/秒\n- 基于键值对的数据结构服务器\n- 丰富的功能\n- 简单稳定\n- 客户端语言多\n- 持久化：RDB 和 AOF\n- 主从复制\n- 高可用和分布式\n<!--more-->\n\n速度快的原因：\n  - 数据存放于内存中\n  - C语言编写\n  - 单线程，避免多线程产生的竞争问题\n\nReids的功能：\n  - 键过期功能\n  - 发布订阅功能\n  - 支持Lua 脚本\n  - 提供了简单的事务\n  - 提供了流水线（Pipeline）功能\n\n### 用好Redis的建议\n1. 勿当作黑盒使用\n2. 阅读源码\n\n### Redis 基本操作\n\n#### 安装\n  - Linux 上通过源码安装\n  - Mac 上通过Brew 安装\n\n#### 配置、启动、操作、关闭\n\nRedis 可执行文件说明：\n\n| 可执行文件 | 作用 |\n|--|--|\n| redis-server | 启动Redis |\n| redis-cli | Redis 命令行客户端 |\n| redis-benchmark | Redis 基准测试工具 |\n| redis-check-aof | Redis AOF 持久化文件检测和修复工具 |\n| redis-check-dump | Redis RDB 持久化文件检测和修复工具 |\n| redis-sentinel | 启动 Redis Sentinel |\n\nRedis 基础配置：\n\n| 配置名 | 配置说明 |\n|--|--|\n| port | 端口 |\n| logfile | 日志文件 |\n| dir | Redis 工作目录（存放持久化文件和日志文件）|\n| daemonize | 是否以守护进程的方式启动Redis |\n\n停止 Redis 服务：\n`redis-cli shutdown` 用来停止Redis 服务，三点注意：\n- Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式\n- 除了`shutdown` 命令外，还可以通过`kill` 进程号的方式关掉Redis，但不可使用 `kill -9` 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。\n- `shutdown` 还有一个参数，代表是否在关闭Redis前，生成持久化文件：`redis-cli shutdown nosave|save`\n\n### Redis 版本\n  版本号第二位如果是奇数为非稳定版本，偶数代表稳定版本\n\n## API的理解和使用\n\n### 全局命令\n\n| 命令 | 作用 |\n|--|--|\n| keys * | 查看所有键 |\n| dbsize | 键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量 |\n| exists key | 检查键是否存在 |\n| del key [key ...] | 删除键 |\n| expire key seconds | 键过期 |\n| ttl key | 查看键的过期时间 |\n| type key | 键的数据结构类型 |\n| object encoding key | 查询内部编码 |\n\n### 数据结构和内部编码\n\n```mermaid\n  graph TB\n    key --> string\n    key --> hash\n    key --> list\n    key --> set\n    key --> zset\n    string --> raw\n    string --> int\n    string --> embstr\n    hash --> hashtable_1[hashtable]\n    hash --> ziplist_1[ziplist]\n    list --> linkedlist\n    list --> ziplist_2[ziplist]\n    set --> hashtable_2[hashtable]\n    set --> intset\n    zset --> skiplist\n    zset --> ziplist_3[ziplist]\n```\n\nRedis这样设计的好处：\n- 可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势\n- 多种内部编码实现可以在不同场景下发挥各自的优势\n\n### 单线程架构\n单线程为什么这么快？\n  - 纯内存访问\n  - 非阻塞I/O\n  - 单线程避免了线程切换和竞态的消耗\n\n### 字符串\n\n#### 字符串类型常用命令\n| 命令 | 作用 |\n|--|--|\n| set key value [ex seconds] [px milliseconds] [nx xx] | 设置值 |\n| setnx | 存在设置失败 |\n| setex | 存在才能设置成功 |\n| get key | 获取值 |\n| mset key value [key value ...] | 批量设置值 |\n| mget key [key ...] | 批量获取值 |\n| incr key | 自增操作，值不是整数返回错误，键不存在按照 0 自增 |\n| decr key | 自减操作 |\n| incrby decrby incrbyfloat | 根据数值自增自减 |\n\n#### 字符串类型不常用命令\n| 命令 | 作用 |\n|--|--|\n| append key value | 追加值 |\n| strlen key | 字符串长度 |\n| getset key value | 设置并返回原值 |\n| setrange key offset value | 设置指定位置的字符 |\n| getrange key start end | 获取部分字符串 |\n\n#### 字符串内部编码\n  - int：8 个字节的长整型\n  - embstr：小于等于 39 个字节的字符串\n  - raw：大于 39 个字符的字符串\n\n### 哈希\n\n#### 哈希命令\n| 命令 | 作用 |\n|--|--|\n| hset key field value | 设置值 |\n| hget key field | 获取值 |\n| hdel key field [field ...] | 删除field |\n| hlen key | 计算field 个数 |\n| hmget key field [field ...] | 批量获取field-value |\n| hmset key field value [field value ...] | 批量设置field-value |\n| hexists key field | 判断field 是否存在 |\n| hkeys key | 获取所有field |\n| hvals key | 获取所有value |\n| hgetall key | 获取所有的field-value |\n| hincrby hincrbyfloat key field | field 自增 |\n| hstrlen key field | 计算value 的字符串长度 |\n\n#### 内部编码\n  - ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有指都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。\n  - hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。\n\n### 列表\n\n#### 列表的两个特点：\n  - 列表中的元素是有序的\n  - 列表中的元素可以是重复的\n\n#### 命令\n| 命令 | 作用 |\n|--|--|\n| rpush lpush key value [value ...] | 添加 |\n| linsert key (before after) pivot value | 插入 |\n| lrange key start end | 查找 |\n| lindex key index | 获取列表指定索引下表的元素 |\n| llen key | 获取列表长度 |\n| lpop rpop key | 弹出元素|\n| lrem key count value | 删除指定元素，count>0，从左到右；count<0从右到左 删除最多count个元素；count=0，删除所有|\n| ltrim key start end | 按照索引范围剪切列表 |\n| lset key index newValue | 修改 |\n| blpop brpop key [key ...] timeout | 阻塞操作 |\n\n#### 内部编码\n  - ziplist\n  - linkedlist\n\n#### 使用场景\n  - 消息队列\n  - 文章列表\n  - lpush + lpop = Stack（栈）\n  - lpush + rpop = Queue（队列）\n  - lpush + ltrim = Capped Collection（有限集合）\n  - lpush + brpop = Message Queue（消息队列）\n\n### 集合\n  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。\n\n#### 命令\n集合内操作：\n\n| 命令 | 作用 |\n|--|--|\n| sadd key ele [ele ...] | 添加元素 |\n| srem key ele [ele ...] | 删除元素 |\n| scard key | 计算元素个数 |\n| sismember key ele | 判断元素是否在集合中 |\n| srandmember key [count:1] | 随机从集合返回指定个数元素 |\n| spop key | 从集合随机弹出一个元素 |\n| smember key | 获取所有元素 |\n\n集合间操作：\n\n| 命令 | 作用 |\n|--|--|\n| sinter key [key ...] | 求多个结合的交集 |\n| suinon key [key ...] | 求多个结合的并集 |\n| sdiff key [key ...] | 求多个集合的差集 |\n| sinterstore sunionstore sdiffstore destination key [key ...] | 将交集、并集、差集的结果保存 |\n\n集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。\n\n#### 内部编码\n  - intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现\n  - hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现\n\n#### 使用场景\n  - 标签\n\n### 有序集合\n  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。\n\n#### 命令\n集合内：\n\n| 命令 | 作用 |\n|--|--|\n| zadd key score memeber [score memeber ...] | 添加成员 |\n| zcard key | 计算成员个数 |\n| zscore key member | 计算某个成员的分数 |\n| zrank zrevrank key member | 计算成员的排名 |\n| zrem key memeber [member ...] | 删除成员 |\n| zincrby key increment member | 增加成员的分数 |\n| zrange zrevrange key start end [withscores] | 返回指定排名范围的成员 |\n| zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count] | 返回指定分数范围的成员 |\n| zcount key min max | 返回指定分数范围成员个数 |\n| zremrangebyrank key start end | 删除指定排名内的升序元素 |\n| zremrangebyscore key min max | 删除指定分数范围的成员 |\n\nRedis3.2为zadd添加了nx、xx、ch、incr 四个选项：\n  - nx：member 必须不存在才能设置成功，用于添加\n  - xx：member 必须存在才能设置成功，用于更新\n  - ch：返回此次操作后，有序集合元素和分数变化的个数\n  - incr：对score做增加，相当于zincrby\n\n集合间的操作\n  - 交集：\n    `zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`\n    - destination：交集计算结果保存在这个键\n    - numkeys：需要做交集计算键的个数\n    - key[key ...]：需要做交集计算的键\n    - weights weight[weight ...]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1\n    - aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum\n  - 并集：\n    `zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]`\n\n#### 内部编码\n  - ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现\n  - skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现\n\n#### 使用场景\n  - 点赞数\n  - 前十名\n  - 用户分数\n\n### 键管理\n\n#### 单个键管理\n| 命令 | 作用 |\n|--|--|\n| rename key newkey | 键重命名 |\n| renamenx key newkey | newkey 不存在时重命名 |\n| randomkey | 随机返回一个键 |\n| expire key seconds | 键在seconds 秒后过期 |\n| expireat key timestamp | 键在秒级时间戳timestamp 后过期 |\n| pexpire key milliseconds | 键在milliseconds 毫秒后过期 |\n| pexpireat key milliseconds-timestamp | 键在毫秒级时间戳timestamp 后过期 |\n| move key db | 键内部迁移 |\n| dump key | 键值序列化，采用RDB格式 |\n| restore key ttl value | 反序列化键值 |\n| migrate host port (key \"\") destination-db timeout [copy] [replace] [keys key [key ...]] | Redis 实例间进行数据迁移 |\n\nRedis过期命令注意点：\n  - expire key的键不存在，返回结果为 0\n  - 过期时间如果为负值，键会立即被删除\n  - persist 可以将键的过期时间清除\n  - 对于字符串类型键，set 命令会去掉过期时间\n  - Redis 不支持二级数据结构内部元素的过期功能\n  - setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间\n\nmigrate 参数：\n  - host：目标Redis 的IP地址\n  - port：目标Redis 的端口\n  - key|\"\"：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”\n  - destination：目标Redis 的数据库索引\n  - timeout：迁移的超时时间（毫秒）\n  - [copy]：添加后，迁移不删除源键\n  - [replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖\n  - [keys key[key ...]]：迁移多个键\n\n#### 遍历键\n- `keys pattern`：全量遍历键\n  keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：\n    - 在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制\n    - 如果确认键值总数确实比较少，可以执行该命令\n    - 使用scan 命令，可以有效防止阻塞\n- `scan cursor [match pattern] [count number]`：渐进式遍历\n  - curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束\n  - match pattern：可选参数，匹配正则\n  - count number：可选参数，每次要遍历的键个数，默认是 10\n\n除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan\n\n#### 数据库管理\n| 命令 | 作用 |\n|--|--|\n| select dbIndex | 切换数据库，Redis默认配置中有16个数据库 |\n| flushdb | 清除当前数据库 |\n| flushall | 清除所有数据库 |\n\n  **注意**：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：\n  - Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响\n  - 多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库\n  - 部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱\n\n## 小功能大用处\n\n### 慢查询分析\nRedis 提供了`slowlog-log-slower-than` 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数\n```shell\nconfig set slowlog-log-slower-than 20000\nconfig set slowlog-max-len 1000\nconfig rewrite\n# 获取慢查询日志\nslowlog get [n]\n# 获取慢查询日志列表当前的长度\nslowlog len\n# 慢查询日志重置\nslowlog reset\n```\n\n### redis-cli 详解\n| 参数 | 作用 |\n|--|--|\n| -r | 命令执行多次 |\n| -i | 每隔几秒执行一次 |\n| -x | 从标准输入读取数据作为最后一个参数 |\n| -c | 连接Redis Cluster 节点时使用 |\n| -a | Redis 配置了命令时使用 |\n| --scan 和 --pattern | 用于扫描指定模式的键 |\n| --slave | 把当前客户端模拟成当前Redis 节点的从节点 |\n| --rdb | 请求Redis实例生成并发送RDB持久化文件保存到本地 |\n| --pipe | 批量执行Redis 命令 |\n| --bigkeys | 使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值 |\n| --eval | 执行Lua 脚本 |\n| --latency | 检测网络延迟 |\n| --latency-history | 分时段了解延迟信息 |\n| --latency-dist | 使用统计图表输出延迟统计信息 |\n| --stat | 实时获取Redis 的重要统计信息 |\n| --no-raw | 要求命令的返回结果必须是原始的格式 |\n| --raw | 要求命令的返回结果是转换后的格式 |\n\n### redis-server 详解\n参数 `--test-memory` 用来检测当前系统能否稳定的分配指定容量的内存给Redis\n\n### redis-benchmark 详解\nredis-benchmark 可以为Redis做基准性能测试\n\n| 参数 | 作用 |\n|--|--|\n| -c | 客户端的并发数（默认50）|\n| -n | 客户端请求总量（默认100000）|\n| -r | 插入随机的键做测试 |\n| -P | 每个请求pipeline 的数据量（默认1）|\n| -k | 是否使用keepalive，1为使用，0为不使用 |\n| -t | 对指定命令进行基准测试 |\n| --csv | 将结果按照csv格式输出 |\n\n### Pipeline\n有效节约RTT（Round Trip Time，往返时间）\n\n### 事务与Lua\nRedis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。\n\n#### 不同错误下的处理机制\n1. 命令错误：整个事务无法执行\n2. 运行时异常：不支持回滚\n\n#### Lua\n```lua\n-- 没有local代表是全局变量\nlocal strings val = \"world\"\nprint(val)\n-- 表格，下标从 1 开始\nlocal tables myArray = {\"redis\", \"jedis\", true, 88.0}\nprint(myArray[3])\n-- for循环\nlocal int sum = 0\nfor i = 1, 100\ndo\n    sum = sum + i\nend\nprint(sum)\nfor i = 1, #myArray\ndo\n    print(myArray[i])\nend\n-- ipairs函数，返回索引下标和值\nfor index,value in ipairs(myArray)\ndo\n    print(index)\n    print(value)\nend\n-- while\nlocal int sum = 0\nlocal int i = 0\nwhile i <= 100\ndo\n    sum = sum + 1\n    i = i + 1\nend\nprint(sum)\n-- if else\nfor i = 1, #myArray\ndo\n    if myArray[i] == \"jedis\"\n    then\n        print(\"true\")\n        break\n    else\n        -- do nothing\n    end\nend\n-- 哈希\nlocal tables user_1 = {age = 28, name = \"tom\"}\nprint(\"user_1 age is\" .. user_1[\"age\"])\nfor key,value in pairs(user_1)\ndo print(key .. value)\nend\n-- 函数定义\nfunction contact(str1, str2)\n    return str1 .. str2\nend\nprint(contact(\"hello\", \"world\"))\n```\n\n#### Redis中使用Lua\n- eval\n  Redis 中执行`eval script key_num keys args`:\n  ```shell\n  127.0.0.1:6379> eval 'return \"hello \" .. KEYS[1] .. ARGV[1]' 1 redis world\n  ```\n  如果Lua 脚本较长，可以使用redis-cli --eval 直接执行文件\n- evalsha\n  首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销\n  ```shell\n  redis-cli script load \"$(cat lua_get.lua)\"\n  evalsha sha1_value key_num keys args\n  ```\n\n#### Lua的Redis API\nLua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本\n```lua\nredis.call(\"set\", \"hello\", \"world\")\nredis.call(\"get\", \"hello\")\n```\n\n#### Redis 如何管理Lua脚本\n- `script load script`：将Lua 脚本加载到Redis内存中\n- `script exists sha1`：判断sha1 是否已经加载到Redis内存中\n- `script flush`：清除已经加载的所有Lua脚本\n- `script kill`：用于杀掉正在执行的Lua脚本，Redis 提供了`lua-time-limit` 参数，默认是 5 秒，但只是当Lua 脚本时间超过`lua-time-limit` 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，`script kill` 将不会生效，此时要么等待脚本结束要么使用 `shutdown save` 停掉Redis服务\n\n### Bitmaps\n- Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作\n- Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量\n\n#### Bitmaps命令\n| 命令 | 作用 |\n|--|--|\n| setbit key offset value | 设置值 |\n| getbit key offset | 获取值 |\n| bitcount [start] [end] | 获取Bitmaps 指定范围为 1 的个数 |\n| bitop op destkey key[key ...] | Bitmaps间的运算: and、or、not、xor |\n| bitpos key targetBit [start] [end] | 计算Bitmaps中第一个值为targetBit的偏移量 |\n\n### HyperLogLog\nHyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。\n\n| 命令 | 作用 |\n|--|--|\n| pfadd key element [element ...] | 添加 |\n| pfcount key [key ...] | 去重计数，存在一定误差 |\n| pfmerge destkey sourcekey [sourcekey ...] | 合并 |\n\n在选择HyperLogLog 时，需要确认两点：\n- 只是为了计算独立总数，不需要获取单条数据\n- 可以容忍一定误差\n\n### 发布订阅\n\n| 命令 | 作用 |\n|--|--|\n| publish channel message | 发布消息 |\n| subscribe channel [channel ...] | 订阅消息 |\n| unsubscribe [channel [channel ...]] | 取消订阅 |\n| psubscribe pattern [pattern ...] | 按照模式订阅 |\n| punsubscribe [pattern [pattern ...]] | 按照模式取消订阅 |\n| pubsub channels [pattern] | 查看活跃的频道 |\n| pubsub numsub [channel ...] | 查看频道订阅数 |\n| pubsub numpat | 查看模式订阅数 |\n\n订阅命令的注意点：\n- 客户端执行订阅命令之后进入了了订阅状态，只能接收`subscribe`、`psubscribe`、`unsubscribe`、`punsubscribe`这四个命令\n- 新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化\n\n活跃的频道是指当前频道至少有一个订阅者\n\n### GEO（地理信息定位）\nRedis3.2 版本提供了GEO功能。\n\n| 命令 | 作用 |\n|--|--|\n| geoadd key longitude latitude member [longitude latitude memeber ...] | 增加地理位置信息 |\n| geopos key member [memeber ...] | 获取地理位置信息 |\n| geodist key member1 member2 [unit] | 获取两个地理位置的距离 |\n| georadius key longitude latitude (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key] | 获取指定位置范围内的地理信息位置集合 |\n| georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key] | 获取指定位置范围内的成员信息 |\n| geohash key member [member ...] | 获取geohash |\n| zrem key member | 删除地理位置信息 |\n\n参数：\n- withcoord：返回结果中包含经纬度\n- withdist：返回结果中包含离中心节点位置的距离\n- withhash：返回结果中包含geohash\n- COUNT count：指定返回结果的数量\n- asc\\|desc：返回结果按照离中心节点的距离做升序或者降序\n- store key：将返回结果的地理位置信息保存到指定键\n- storedist key: 将返回结果离中心节点的距离保存到指定键\n\n`geohash`的特点：\n- GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中\n- 字符串越长，表示的位置更精确\n- 两个字符串越相似，它们之间的距离越近\n- geohash编码和经纬度是可以互换的\n\n## 客户端\n\n","slug":"Redis开发与运维","published":1,"updated":"2020-04-24T04:43:57.610Z","_id":"ck9bzne7r0009hywid5jp6gcc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"初识Redis\"><a href=\"#初识Redis\" class=\"headerlink\" title=\"初识Redis\"></a>初识Redis</h2><h3 id=\"Redis特性\"><a href=\"#Redis特性\" class=\"headerlink\" title=\"Redis特性\"></a>Redis特性</h3><ul>\n<li>速度快：10万/秒</li>\n<li>基于键值对的数据结构服务器</li>\n<li>丰富的功能</li>\n<li>简单稳定</li>\n<li>客户端语言多</li>\n<li>持久化：RDB 和 AOF</li>\n<li>主从复制</li>\n<li>高可用和分布式<a id=\"more\"></a>\n</li>\n</ul>\n<p>速度快的原因：</p>\n<ul>\n<li>数据存放于内存中</li>\n<li>C语言编写</li>\n<li>单线程，避免多线程产生的竞争问题</li>\n</ul>\n<p>Reids的功能：</p>\n<ul>\n<li>键过期功能</li>\n<li>发布订阅功能</li>\n<li>支持Lua 脚本</li>\n<li>提供了简单的事务</li>\n<li>提供了流水线（Pipeline）功能</li>\n</ul>\n<h3 id=\"用好Redis的建议\"><a href=\"#用好Redis的建议\" class=\"headerlink\" title=\"用好Redis的建议\"></a>用好Redis的建议</h3><ol>\n<li>勿当作黑盒使用</li>\n<li>阅读源码</li>\n</ol>\n<h3 id=\"Redis-基本操作\"><a href=\"#Redis-基本操作\" class=\"headerlink\" title=\"Redis 基本操作\"></a>Redis 基本操作</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li>Linux 上通过源码安装</li>\n<li>Mac 上通过Brew 安装</li>\n</ul>\n<h4 id=\"配置、启动、操作、关闭\"><a href=\"#配置、启动、操作、关闭\" class=\"headerlink\" title=\"配置、启动、操作、关闭\"></a>配置、启动、操作、关闭</h4><p>Redis 可执行文件说明：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>可执行文件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redis-server</td>\n<td>启动Redis</td>\n</tr>\n<tr>\n<td>redis-cli</td>\n<td>Redis 命令行客户端</td>\n</tr>\n<tr>\n<td>redis-benchmark</td>\n<td>Redis 基准测试工具</td>\n</tr>\n<tr>\n<td>redis-check-aof</td>\n<td>Redis AOF 持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td>redis-check-dump</td>\n<td>Redis RDB 持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td>redis-sentinel</td>\n<td>启动 Redis Sentinel</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis 基础配置：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>配置名</th>\n<th>配置说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>port</td>\n<td>端口</td>\n</tr>\n<tr>\n<td>logfile</td>\n<td>日志文件</td>\n</tr>\n<tr>\n<td>dir</td>\n<td>Redis 工作目录（存放持久化文件和日志文件）</td>\n</tr>\n<tr>\n<td>daemonize</td>\n<td>是否以守护进程的方式启动Redis</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>停止 Redis 服务：<br><code>redis-cli shutdown</code> 用来停止Redis 服务，三点注意：</p>\n<ul>\n<li>Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式</li>\n<li>除了<code>shutdown</code> 命令外，还可以通过<code>kill</code> 进程号的方式关掉Redis，但不可使用 <code>kill -9</code> 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。</li>\n<li><code>shutdown</code> 还有一个参数，代表是否在关闭Redis前，生成持久化文件：<code>redis-cli shutdown nosave|save</code></li>\n</ul>\n<h3 id=\"Redis-版本\"><a href=\"#Redis-版本\" class=\"headerlink\" title=\"Redis 版本\"></a>Redis 版本</h3><p>  版本号第二位如果是奇数为非稳定版本，偶数代表稳定版本</p>\n<h2 id=\"API的理解和使用\"><a href=\"#API的理解和使用\" class=\"headerlink\" title=\"API的理解和使用\"></a>API的理解和使用</h2><h3 id=\"全局命令\"><a href=\"#全局命令\" class=\"headerlink\" title=\"全局命令\"></a>全局命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>keys *</td>\n<td>查看所有键</td>\n</tr>\n<tr>\n<td>dbsize</td>\n<td>键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量</td>\n</tr>\n<tr>\n<td>exists key</td>\n<td>检查键是否存在</td>\n</tr>\n<tr>\n<td>del key [key …]</td>\n<td>删除键</td>\n</tr>\n<tr>\n<td>expire key seconds</td>\n<td>键过期</td>\n</tr>\n<tr>\n<td>ttl key</td>\n<td>查看键的过期时间</td>\n</tr>\n<tr>\n<td>type key</td>\n<td>键的数据结构类型</td>\n</tr>\n<tr>\n<td>object encoding key</td>\n<td>查询内部编码</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"数据结构和内部编码\"><a href=\"#数据结构和内部编码\" class=\"headerlink\" title=\"数据结构和内部编码\"></a>数据结构和内部编码</h3><pre class=\"mermaid\">  graph TB\n    key --> string\n    key --> hash\n    key --> list\n    key --> set\n    key --> zset\n    string --> raw\n    string --> int\n    string --> embstr\n    hash --> hashtable_1[hashtable]\n    hash --> ziplist_1[ziplist]\n    list --> linkedlist\n    list --> ziplist_2[ziplist]\n    set --> hashtable_2[hashtable]\n    set --> intset\n    zset --> skiplist\n    zset --> ziplist_3[ziplist]</pre>\n\n<p>Redis这样设计的好处：</p>\n<ul>\n<li>可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势</li>\n<li>多种内部编码实现可以在不同场景下发挥各自的优势</li>\n</ul>\n<h3 id=\"单线程架构\"><a href=\"#单线程架构\" class=\"headerlink\" title=\"单线程架构\"></a>单线程架构</h3><p>单线程为什么这么快？</p>\n<ul>\n<li>纯内存访问</li>\n<li>非阻塞I/O</li>\n<li>单线程避免了线程切换和竞态的消耗</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><h4 id=\"字符串类型常用命令\"><a href=\"#字符串类型常用命令\" class=\"headerlink\" title=\"字符串类型常用命令\"></a>字符串类型常用命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set key value [ex seconds] [px milliseconds] [nx xx]</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>setnx</td>\n<td>存在设置失败</td>\n</tr>\n<tr>\n<td>setex</td>\n<td>存在才能设置成功</td>\n</tr>\n<tr>\n<td>get key</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>mset key value [key value …]</td>\n<td>批量设置值</td>\n</tr>\n<tr>\n<td>mget key [key …]</td>\n<td>批量获取值</td>\n</tr>\n<tr>\n<td>incr key</td>\n<td>自增操作，值不是整数返回错误，键不存在按照 0 自增</td>\n</tr>\n<tr>\n<td>decr key</td>\n<td>自减操作</td>\n</tr>\n<tr>\n<td>incrby decrby incrbyfloat</td>\n<td>根据数值自增自减</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"字符串类型不常用命令\"><a href=\"#字符串类型不常用命令\" class=\"headerlink\" title=\"字符串类型不常用命令\"></a>字符串类型不常用命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>append key value</td>\n<td>追加值</td>\n</tr>\n<tr>\n<td>strlen key</td>\n<td>字符串长度</td>\n</tr>\n<tr>\n<td>getset key value</td>\n<td>设置并返回原值</td>\n</tr>\n<tr>\n<td>setrange key offset value</td>\n<td>设置指定位置的字符</td>\n</tr>\n<tr>\n<td>getrange key start end</td>\n<td>获取部分字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"字符串内部编码\"><a href=\"#字符串内部编码\" class=\"headerlink\" title=\"字符串内部编码\"></a>字符串内部编码</h4><ul>\n<li>int：8 个字节的长整型</li>\n<li>embstr：小于等于 39 个字节的字符串</li>\n<li>raw：大于 39 个字符的字符串</li>\n</ul>\n<h3 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h3><h4 id=\"哈希命令\"><a href=\"#哈希命令\" class=\"headerlink\" title=\"哈希命令\"></a>哈希命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hset key field value</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>hget key field</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>hdel key field [field …]</td>\n<td>删除field</td>\n</tr>\n<tr>\n<td>hlen key</td>\n<td>计算field 个数</td>\n</tr>\n<tr>\n<td>hmget key field [field …]</td>\n<td>批量获取field-value</td>\n</tr>\n<tr>\n<td>hmset key field value [field value …]</td>\n<td>批量设置field-value</td>\n</tr>\n<tr>\n<td>hexists key field</td>\n<td>判断field 是否存在</td>\n</tr>\n<tr>\n<td>hkeys key</td>\n<td>获取所有field</td>\n</tr>\n<tr>\n<td>hvals key</td>\n<td>获取所有value</td>\n</tr>\n<tr>\n<td>hgetall key</td>\n<td>获取所有的field-value</td>\n</tr>\n<tr>\n<td>hincrby hincrbyfloat key field</td>\n<td>field 自增</td>\n</tr>\n<tr>\n<td>hstrlen key field</td>\n<td>计算value 的字符串长度</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"内部编码\"><a href=\"#内部编码\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><ul>\n<li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有指都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。</li>\n<li>hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。</li>\n</ul>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"列表的两个特点：\"><a href=\"#列表的两个特点：\" class=\"headerlink\" title=\"列表的两个特点：\"></a>列表的两个特点：</h4><ul>\n<li>列表中的元素是有序的</li>\n<li>列表中的元素可以是重复的</li>\n</ul>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rpush lpush key value [value …]</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>linsert key (before after) pivot value</td>\n<td>插入</td>\n</tr>\n<tr>\n<td>lrange key start end</td>\n<td>查找</td>\n</tr>\n<tr>\n<td>lindex key index</td>\n<td>获取列表指定索引下表的元素</td>\n</tr>\n<tr>\n<td>llen key</td>\n<td>获取列表长度</td>\n</tr>\n<tr>\n<td>lpop rpop key</td>\n<td>弹出元素</td>\n</tr>\n<tr>\n<td>lrem key count value</td>\n<td>删除指定元素，count&gt;0，从左到右；count&lt;0从右到左 删除最多count个元素；count=0，删除所有</td>\n</tr>\n<tr>\n<td>ltrim key start end</td>\n<td>按照索引范围剪切列表</td>\n</tr>\n<tr>\n<td>lset key index newValue</td>\n<td>修改</td>\n</tr>\n<tr>\n<td>blpop brpop key [key …] timeout</td>\n<td>阻塞操作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"内部编码-1\"><a href=\"#内部编码-1\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><ul>\n<li>ziplist</li>\n<li>linkedlist</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>消息队列</li>\n<li>文章列表</li>\n<li>lpush + lpop = Stack（栈）</li>\n<li>lpush + rpop = Queue（队列）</li>\n<li>lpush + ltrim = Capped Collection（有限集合）</li>\n<li>lpush + brpop = Message Queue（消息队列）</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。</p>\n<h4 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h4><p>集合内操作：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sadd key ele [ele …]</td>\n<td>添加元素</td>\n</tr>\n<tr>\n<td>srem key ele [ele …]</td>\n<td>删除元素</td>\n</tr>\n<tr>\n<td>scard key</td>\n<td>计算元素个数</td>\n</tr>\n<tr>\n<td>sismember key ele</td>\n<td>判断元素是否在集合中</td>\n</tr>\n<tr>\n<td>srandmember key [count:1]</td>\n<td>随机从集合返回指定个数元素</td>\n</tr>\n<tr>\n<td>spop key</td>\n<td>从集合随机弹出一个元素</td>\n</tr>\n<tr>\n<td>smember key</td>\n<td>获取所有元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>集合间操作：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sinter key [key …]</td>\n<td>求多个结合的交集</td>\n</tr>\n<tr>\n<td>suinon key [key …]</td>\n<td>求多个结合的并集</td>\n</tr>\n<tr>\n<td>sdiff key [key …]</td>\n<td>求多个集合的差集</td>\n</tr>\n<tr>\n<td>sinterstore sunionstore sdiffstore destination key [key …]</td>\n<td>将交集、并集、差集的结果保存</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。</p>\n<h4 id=\"内部编码-2\"><a href=\"#内部编码-2\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><ul>\n<li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现</li>\n<li>hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现</li>\n</ul>\n<h4 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>标签</li>\n</ul>\n<h3 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h3><p>  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。</p>\n<h4 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h4><p>集合内：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zadd key score memeber [score memeber …]</td>\n<td>添加成员</td>\n</tr>\n<tr>\n<td>zcard key</td>\n<td>计算成员个数</td>\n</tr>\n<tr>\n<td>zscore key member</td>\n<td>计算某个成员的分数</td>\n</tr>\n<tr>\n<td>zrank zrevrank key member</td>\n<td>计算成员的排名</td>\n</tr>\n<tr>\n<td>zrem key memeber [member …]</td>\n<td>删除成员</td>\n</tr>\n<tr>\n<td>zincrby key increment member</td>\n<td>增加成员的分数</td>\n</tr>\n<tr>\n<td>zrange zrevrange key start end [withscores]</td>\n<td>返回指定排名范围的成员</td>\n</tr>\n<tr>\n<td>zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count]</td>\n<td>返回指定分数范围的成员</td>\n</tr>\n<tr>\n<td>zcount key min max</td>\n<td>返回指定分数范围成员个数</td>\n</tr>\n<tr>\n<td>zremrangebyrank key start end</td>\n<td>删除指定排名内的升序元素</td>\n</tr>\n<tr>\n<td>zremrangebyscore key min max</td>\n<td>删除指定分数范围的成员</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis3.2为zadd添加了nx、xx、ch、incr 四个选项：</p>\n<ul>\n<li>nx：member 必须不存在才能设置成功，用于添加</li>\n<li>xx：member 必须存在才能设置成功，用于更新</li>\n<li>ch：返回此次操作后，有序集合元素和分数变化的个数</li>\n<li>incr：对score做增加，相当于zincrby</li>\n</ul>\n<p>集合间的操作</p>\n<ul>\n<li>交集：<br><code>zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><ul>\n<li>destination：交集计算结果保存在这个键</li>\n<li>numkeys：需要做交集计算键的个数</li>\n<li>key[key …]：需要做交集计算的键</li>\n<li>weights weight[weight …]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1</li>\n<li>aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum</li>\n</ul>\n</li>\n<li>并集：<br><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></li>\n</ul>\n<h4 id=\"内部编码-3\"><a href=\"#内部编码-3\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><ul>\n<li>ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现</li>\n<li>skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现</li>\n</ul>\n<h4 id=\"使用场景-2\"><a href=\"#使用场景-2\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>点赞数</li>\n<li>前十名</li>\n<li>用户分数</li>\n</ul>\n<h3 id=\"键管理\"><a href=\"#键管理\" class=\"headerlink\" title=\"键管理\"></a>键管理</h3><h4 id=\"单个键管理\"><a href=\"#单个键管理\" class=\"headerlink\" title=\"单个键管理\"></a>单个键管理</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rename key newkey</td>\n<td>键重命名</td>\n</tr>\n<tr>\n<td>renamenx key newkey</td>\n<td>newkey 不存在时重命名</td>\n</tr>\n<tr>\n<td>randomkey</td>\n<td>随机返回一个键</td>\n</tr>\n<tr>\n<td>expire key seconds</td>\n<td>键在seconds 秒后过期</td>\n</tr>\n<tr>\n<td>expireat key timestamp</td>\n<td>键在秒级时间戳timestamp 后过期</td>\n</tr>\n<tr>\n<td>pexpire key milliseconds</td>\n<td>键在milliseconds 毫秒后过期</td>\n</tr>\n<tr>\n<td>pexpireat key milliseconds-timestamp</td>\n<td>键在毫秒级时间戳timestamp 后过期</td>\n</tr>\n<tr>\n<td>move key db</td>\n<td>键内部迁移</td>\n</tr>\n<tr>\n<td>dump key</td>\n<td>键值序列化，采用RDB格式</td>\n</tr>\n<tr>\n<td>restore key ttl value</td>\n<td>反序列化键值</td>\n</tr>\n<tr>\n<td>migrate host port (key “”) destination-db timeout [copy] [replace] [keys key [key …]]</td>\n<td>Redis 实例间进行数据迁移</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis过期命令注意点：</p>\n<ul>\n<li>expire key的键不存在，返回结果为 0</li>\n<li>过期时间如果为负值，键会立即被删除</li>\n<li>persist 可以将键的过期时间清除</li>\n<li>对于字符串类型键，set 命令会去掉过期时间</li>\n<li>Redis 不支持二级数据结构内部元素的过期功能</li>\n<li>setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间</li>\n</ul>\n<p>migrate 参数：</p>\n<ul>\n<li>host：目标Redis 的IP地址</li>\n<li>port：目标Redis 的端口</li>\n<li>key|””：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”</li>\n<li>destination：目标Redis 的数据库索引</li>\n<li>timeout：迁移的超时时间（毫秒）</li>\n<li>[copy]：添加后，迁移不删除源键</li>\n<li>[replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖</li>\n<li>[keys key[key …]]：迁移多个键</li>\n</ul>\n<h4 id=\"遍历键\"><a href=\"#遍历键\" class=\"headerlink\" title=\"遍历键\"></a>遍历键</h4><ul>\n<li><code>keys pattern</code>：全量遍历键<br>keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：<ul>\n<li>在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制</li>\n<li>如果确认键值总数确实比较少，可以执行该命令</li>\n<li>使用scan 命令，可以有效防止阻塞</li>\n</ul>\n</li>\n<li><code>scan cursor [match pattern] [count number]</code>：渐进式遍历<ul>\n<li>curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束</li>\n<li>match pattern：可选参数，匹配正则</li>\n<li>count number：可选参数，每次要遍历的键个数，默认是 10</li>\n</ul>\n</li>\n</ul>\n<p>除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan</p>\n<h4 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>select dbIndex</td>\n<td>切换数据库，Redis默认配置中有16个数据库</td>\n</tr>\n<tr>\n<td>flushdb</td>\n<td>清除当前数据库</td>\n</tr>\n<tr>\n<td>flushall</td>\n<td>清除所有数据库</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>  <strong>注意</strong>：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：</p>\n<ul>\n<li>Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响</li>\n<li>多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库</li>\n<li>部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱</li>\n</ul>\n<h2 id=\"小功能大用处\"><a href=\"#小功能大用处\" class=\"headerlink\" title=\"小功能大用处\"></a>小功能大用处</h2><h3 id=\"慢查询分析\"><a href=\"#慢查询分析\" class=\"headerlink\" title=\"慢查询分析\"></a>慢查询分析</h3><p>Redis 提供了<code>slowlog-log-slower-than</code> 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config set slowlog-log-slower-than 20000</span><br><span class=\"line\">config set slowlog-max-len 1000</span><br><span class=\"line\">config rewrite</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取慢查询日志</span></span><br><span class=\"line\">slowlog get [n]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取慢查询日志列表当前的长度</span></span><br><span class=\"line\">slowlog len</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 慢查询日志重置</span></span><br><span class=\"line\">slowlog reset</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"redis-cli-详解\"><a href=\"#redis-cli-详解\" class=\"headerlink\" title=\"redis-cli 详解\"></a>redis-cli 详解</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-r</td>\n<td>命令执行多次</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>每隔几秒执行一次</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>从标准输入读取数据作为最后一个参数</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>连接Redis Cluster 节点时使用</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>Redis 配置了命令时使用</td>\n</tr>\n<tr>\n<td>—scan 和 —pattern</td>\n<td>用于扫描指定模式的键</td>\n</tr>\n<tr>\n<td>—slave</td>\n<td>把当前客户端模拟成当前Redis 节点的从节点</td>\n</tr>\n<tr>\n<td>—rdb</td>\n<td>请求Redis实例生成并发送RDB持久化文件保存到本地</td>\n</tr>\n<tr>\n<td>—pipe</td>\n<td>批量执行Redis 命令</td>\n</tr>\n<tr>\n<td>—bigkeys</td>\n<td>使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值</td>\n</tr>\n<tr>\n<td>—eval</td>\n<td>执行Lua 脚本</td>\n</tr>\n<tr>\n<td>—latency</td>\n<td>检测网络延迟</td>\n</tr>\n<tr>\n<td>—latency-history</td>\n<td>分时段了解延迟信息</td>\n</tr>\n<tr>\n<td>—latency-dist</td>\n<td>使用统计图表输出延迟统计信息</td>\n</tr>\n<tr>\n<td>—stat</td>\n<td>实时获取Redis 的重要统计信息</td>\n</tr>\n<tr>\n<td>—no-raw</td>\n<td>要求命令的返回结果必须是原始的格式</td>\n</tr>\n<tr>\n<td>—raw</td>\n<td>要求命令的返回结果是转换后的格式</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"redis-server-详解\"><a href=\"#redis-server-详解\" class=\"headerlink\" title=\"redis-server 详解\"></a>redis-server 详解</h3><p>参数 <code>--test-memory</code> 用来检测当前系统能否稳定的分配指定容量的内存给Redis</p>\n<h3 id=\"redis-benchmark-详解\"><a href=\"#redis-benchmark-详解\" class=\"headerlink\" title=\"redis-benchmark 详解\"></a>redis-benchmark 详解</h3><p>redis-benchmark 可以为Redis做基准性能测试</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>客户端的并发数（默认50）</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>客户端请求总量（默认100000）</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>插入随机的键做测试</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>每个请求pipeline 的数据量（默认1）</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>是否使用keepalive，1为使用，0为不使用</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>对指定命令进行基准测试</td>\n</tr>\n<tr>\n<td>—csv</td>\n<td>将结果按照csv格式输出</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"Pipeline\"><a href=\"#Pipeline\" class=\"headerlink\" title=\"Pipeline\"></a>Pipeline</h3><p>有效节约RTT（Round Trip Time，往返时间）</p>\n<h3 id=\"事务与Lua\"><a href=\"#事务与Lua\" class=\"headerlink\" title=\"事务与Lua\"></a>事务与Lua</h3><p>Redis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。</p>\n<h4 id=\"不同错误下的处理机制\"><a href=\"#不同错误下的处理机制\" class=\"headerlink\" title=\"不同错误下的处理机制\"></a>不同错误下的处理机制</h4><ol>\n<li>命令错误：整个事务无法执行</li>\n<li>运行时异常：不支持回滚</li>\n</ol>\n<h4 id=\"Lua\"><a href=\"#Lua\" class=\"headerlink\" title=\"Lua\"></a>Lua</h4><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 没有local代表是全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> strings val = <span class=\"string\">\"world\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(val)</span><br><span class=\"line\"><span class=\"comment\">-- 表格，下标从 1 开始</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> tables myArray = &#123;<span class=\"string\">\"redis\"</span>, <span class=\"string\">\"jedis\"</span>, <span class=\"literal\">true</span>, <span class=\"number\">88.0</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myArray[<span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">-- for循环</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    sum = sum + i</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #myArray</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(myArray[i])</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- ipairs函数，返回索引下标和值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,value <span class=\"keyword\">in</span> <span class=\"built_in\">ipairs</span>(myArray)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(index)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- while</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt;= <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    sum = sum + <span class=\"number\">1</span></span><br><span class=\"line\">    i = i + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum)</span><br><span class=\"line\"><span class=\"comment\">-- if else</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #myArray</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> myArray[i] == <span class=\"string\">\"jedis\"</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"true\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">-- do nothing</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 哈希</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> tables user_1 = &#123;age = <span class=\"number\">28</span>, name = <span class=\"string\">\"tom\"</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"user_1 age is\"</span> .. user_1[<span class=\"string\">\"age\"</span>])</span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(user_1)</span><br><span class=\"line\"><span class=\"keyword\">do</span> <span class=\"built_in\">print</span>(key .. value)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">contact</span><span class=\"params\">(str1, str2)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str1 .. str2</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(contact(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"Redis中使用Lua\"><a href=\"#Redis中使用Lua\" class=\"headerlink\" title=\"Redis中使用Lua\"></a>Redis中使用Lua</h4><ul>\n<li>eval<br>Redis 中执行<code>eval script key_num keys args</code>:<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; eval 'return \"hello \" .. KEYS[1] .. ARGV[1]' 1 redis world</span><br></pre></td></tr></table></figure>\n如果Lua 脚本较长，可以使用redis-cli —eval 直接执行文件</li>\n<li>evalsha<br>首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli script load \"$(cat lua_get.lua)\"</span><br><span class=\"line\">evalsha sha1_value key_num keys args</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Lua的Redis-API\"><a href=\"#Lua的Redis-API\" class=\"headerlink\" title=\"Lua的Redis API\"></a>Lua的Redis API</h4><p>Lua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis.call(<span class=\"string\">\"set\"</span>, <span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>)</span><br><span class=\"line\">redis.call(<span class=\"string\">\"get\"</span>, <span class=\"string\">\"hello\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Redis-如何管理Lua脚本\"><a href=\"#Redis-如何管理Lua脚本\" class=\"headerlink\" title=\"Redis 如何管理Lua脚本\"></a>Redis 如何管理Lua脚本</h4><ul>\n<li><code>script load script</code>：将Lua 脚本加载到Redis内存中</li>\n<li><code>script exists sha1</code>：判断sha1 是否已经加载到Redis内存中</li>\n<li><code>script flush</code>：清除已经加载的所有Lua脚本</li>\n<li><code>script kill</code>：用于杀掉正在执行的Lua脚本，Redis 提供了<code>lua-time-limit</code> 参数，默认是 5 秒，但只是当Lua 脚本时间超过<code>lua-time-limit</code> 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，<code>script kill</code> 将不会生效，此时要么等待脚本结束要么使用 <code>shutdown save</code> 停掉Redis服务</li>\n</ul>\n<h3 id=\"Bitmaps\"><a href=\"#Bitmaps\" class=\"headerlink\" title=\"Bitmaps\"></a>Bitmaps</h3><ul>\n<li>Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作</li>\n<li>Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量</li>\n</ul>\n<h4 id=\"Bitmaps命令\"><a href=\"#Bitmaps命令\" class=\"headerlink\" title=\"Bitmaps命令\"></a>Bitmaps命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setbit key offset value</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>getbit key offset</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>bitcount [start] [end]</td>\n<td>获取Bitmaps 指定范围为 1 的个数</td>\n</tr>\n<tr>\n<td>bitop op destkey key[key …]</td>\n<td>Bitmaps间的运算: and、or、not、xor</td>\n</tr>\n<tr>\n<td>bitpos key targetBit [start] [end]</td>\n<td>计算Bitmaps中第一个值为targetBit的偏移量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h3><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pfadd key element [element …]</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>pfcount key [key …]</td>\n<td>去重计数，存在一定误差</td>\n</tr>\n<tr>\n<td>pfmerge destkey sourcekey [sourcekey …]</td>\n<td>合并</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在选择HyperLogLog 时，需要确认两点：</p>\n<ul>\n<li>只是为了计算独立总数，不需要获取单条数据</li>\n<li>可以容忍一定误差</li>\n</ul>\n<h3 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>publish channel message</td>\n<td>发布消息</td>\n</tr>\n<tr>\n<td>subscribe channel [channel …]</td>\n<td>订阅消息</td>\n</tr>\n<tr>\n<td>unsubscribe [channel [channel …]]</td>\n<td>取消订阅</td>\n</tr>\n<tr>\n<td>psubscribe pattern [pattern …]</td>\n<td>按照模式订阅</td>\n</tr>\n<tr>\n<td>punsubscribe [pattern [pattern …]]</td>\n<td>按照模式取消订阅</td>\n</tr>\n<tr>\n<td>pubsub channels [pattern]</td>\n<td>查看活跃的频道</td>\n</tr>\n<tr>\n<td>pubsub numsub [channel …]</td>\n<td>查看频道订阅数</td>\n</tr>\n<tr>\n<td>pubsub numpat</td>\n<td>查看模式订阅数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>订阅命令的注意点：</p>\n<ul>\n<li>客户端执行订阅命令之后进入了了订阅状态，只能接收<code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>这四个命令</li>\n<li>新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化</li>\n</ul>\n<p>活跃的频道是指当前频道至少有一个订阅者</p>\n<h3 id=\"GEO（地理信息定位）\"><a href=\"#GEO（地理信息定位）\" class=\"headerlink\" title=\"GEO（地理信息定位）\"></a>GEO（地理信息定位）</h3><p>Redis3.2 版本提供了GEO功能。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>geoadd key longitude latitude member [longitude latitude memeber …]</td>\n<td>增加地理位置信息</td>\n</tr>\n<tr>\n<td>geopos key member [memeber …]</td>\n<td>获取地理位置信息</td>\n</tr>\n<tr>\n<td>geodist key member1 member2 [unit]</td>\n<td>获取两个地理位置的距离</td>\n</tr>\n<tr>\n<td>georadius key longitude latitude (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>\n<td>获取指定位置范围内的地理信息位置集合</td>\n</tr>\n<tr>\n<td>georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>\n<td>获取指定位置范围内的成员信息</td>\n</tr>\n<tr>\n<td>geohash key member [member …]</td>\n<td>获取geohash</td>\n</tr>\n<tr>\n<td>zrem key member</td>\n<td>删除地理位置信息</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>参数：</p>\n<ul>\n<li>withcoord：返回结果中包含经纬度</li>\n<li>withdist：返回结果中包含离中心节点位置的距离</li>\n<li>withhash：返回结果中包含geohash</li>\n<li>COUNT count：指定返回结果的数量</li>\n<li>asc|desc：返回结果按照离中心节点的距离做升序或者降序</li>\n<li>store key：将返回结果的地理位置信息保存到指定键</li>\n<li>storedist key: 将返回结果离中心节点的距离保存到指定键</li>\n</ul>\n<p><code>geohash</code>的特点：</p>\n<ul>\n<li>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中</li>\n<li>字符串越长，表示的位置更精确</li>\n<li>两个字符串越相似，它们之间的距离越近</li>\n<li>geohash编码和经纬度是可以互换的</li>\n</ul>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2>","site":{"data":{}},"excerpt":"<h2 id=\"初识Redis\"><a href=\"#初识Redis\" class=\"headerlink\" title=\"初识Redis\"></a>初识Redis</h2><h3 id=\"Redis特性\"><a href=\"#Redis特性\" class=\"headerlink\" title=\"Redis特性\"></a>Redis特性</h3><ul>\n<li>速度快：10万/秒</li>\n<li>基于键值对的数据结构服务器</li>\n<li>丰富的功能</li>\n<li>简单稳定</li>\n<li>客户端语言多</li>\n<li>持久化：RDB 和 AOF</li>\n<li>主从复制</li>\n<li>高可用和分布式","more":"</li>\n</ul>\n<p>速度快的原因：</p>\n<ul>\n<li>数据存放于内存中</li>\n<li>C语言编写</li>\n<li>单线程，避免多线程产生的竞争问题</li>\n</ul>\n<p>Reids的功能：</p>\n<ul>\n<li>键过期功能</li>\n<li>发布订阅功能</li>\n<li>支持Lua 脚本</li>\n<li>提供了简单的事务</li>\n<li>提供了流水线（Pipeline）功能</li>\n</ul>\n<h3 id=\"用好Redis的建议\"><a href=\"#用好Redis的建议\" class=\"headerlink\" title=\"用好Redis的建议\"></a>用好Redis的建议</h3><ol>\n<li>勿当作黑盒使用</li>\n<li>阅读源码</li>\n</ol>\n<h3 id=\"Redis-基本操作\"><a href=\"#Redis-基本操作\" class=\"headerlink\" title=\"Redis 基本操作\"></a>Redis 基本操作</h3><h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li>Linux 上通过源码安装</li>\n<li>Mac 上通过Brew 安装</li>\n</ul>\n<h4 id=\"配置、启动、操作、关闭\"><a href=\"#配置、启动、操作、关闭\" class=\"headerlink\" title=\"配置、启动、操作、关闭\"></a>配置、启动、操作、关闭</h4><p>Redis 可执行文件说明：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>可执行文件</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redis-server</td>\n<td>启动Redis</td>\n</tr>\n<tr>\n<td>redis-cli</td>\n<td>Redis 命令行客户端</td>\n</tr>\n<tr>\n<td>redis-benchmark</td>\n<td>Redis 基准测试工具</td>\n</tr>\n<tr>\n<td>redis-check-aof</td>\n<td>Redis AOF 持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td>redis-check-dump</td>\n<td>Redis RDB 持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td>redis-sentinel</td>\n<td>启动 Redis Sentinel</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis 基础配置：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>配置名</th>\n<th>配置说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>port</td>\n<td>端口</td>\n</tr>\n<tr>\n<td>logfile</td>\n<td>日志文件</td>\n</tr>\n<tr>\n<td>dir</td>\n<td>Redis 工作目录（存放持久化文件和日志文件）</td>\n</tr>\n<tr>\n<td>daemonize</td>\n<td>是否以守护进程的方式启动Redis</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>停止 Redis 服务：<br><code>redis-cli shutdown</code> 用来停止Redis 服务，三点注意：</p>\n<ul>\n<li>Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式</li>\n<li>除了<code>shutdown</code> 命令外，还可以通过<code>kill</code> 进程号的方式关掉Redis，但不可使用 <code>kill -9</code> 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。</li>\n<li><code>shutdown</code> 还有一个参数，代表是否在关闭Redis前，生成持久化文件：<code>redis-cli shutdown nosave|save</code></li>\n</ul>\n<h3 id=\"Redis-版本\"><a href=\"#Redis-版本\" class=\"headerlink\" title=\"Redis 版本\"></a>Redis 版本</h3><p>  版本号第二位如果是奇数为非稳定版本，偶数代表稳定版本</p>\n<h2 id=\"API的理解和使用\"><a href=\"#API的理解和使用\" class=\"headerlink\" title=\"API的理解和使用\"></a>API的理解和使用</h2><h3 id=\"全局命令\"><a href=\"#全局命令\" class=\"headerlink\" title=\"全局命令\"></a>全局命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>keys *</td>\n<td>查看所有键</td>\n</tr>\n<tr>\n<td>dbsize</td>\n<td>键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量</td>\n</tr>\n<tr>\n<td>exists key</td>\n<td>检查键是否存在</td>\n</tr>\n<tr>\n<td>del key [key …]</td>\n<td>删除键</td>\n</tr>\n<tr>\n<td>expire key seconds</td>\n<td>键过期</td>\n</tr>\n<tr>\n<td>ttl key</td>\n<td>查看键的过期时间</td>\n</tr>\n<tr>\n<td>type key</td>\n<td>键的数据结构类型</td>\n</tr>\n<tr>\n<td>object encoding key</td>\n<td>查询内部编码</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"数据结构和内部编码\"><a href=\"#数据结构和内部编码\" class=\"headerlink\" title=\"数据结构和内部编码\"></a>数据结构和内部编码</h3><pre class=\"mermaid\">  graph TB\n    key --> string\n    key --> hash\n    key --> list\n    key --> set\n    key --> zset\n    string --> raw\n    string --> int\n    string --> embstr\n    hash --> hashtable_1[hashtable]\n    hash --> ziplist_1[ziplist]\n    list --> linkedlist\n    list --> ziplist_2[ziplist]\n    set --> hashtable_2[hashtable]\n    set --> intset\n    zset --> skiplist\n    zset --> ziplist_3[ziplist]</pre>\n\n<p>Redis这样设计的好处：</p>\n<ul>\n<li>可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势</li>\n<li>多种内部编码实现可以在不同场景下发挥各自的优势</li>\n</ul>\n<h3 id=\"单线程架构\"><a href=\"#单线程架构\" class=\"headerlink\" title=\"单线程架构\"></a>单线程架构</h3><p>单线程为什么这么快？</p>\n<ul>\n<li>纯内存访问</li>\n<li>非阻塞I/O</li>\n<li>单线程避免了线程切换和竞态的消耗</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><h4 id=\"字符串类型常用命令\"><a href=\"#字符串类型常用命令\" class=\"headerlink\" title=\"字符串类型常用命令\"></a>字符串类型常用命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set key value [ex seconds] [px milliseconds] [nx xx]</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>setnx</td>\n<td>存在设置失败</td>\n</tr>\n<tr>\n<td>setex</td>\n<td>存在才能设置成功</td>\n</tr>\n<tr>\n<td>get key</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>mset key value [key value …]</td>\n<td>批量设置值</td>\n</tr>\n<tr>\n<td>mget key [key …]</td>\n<td>批量获取值</td>\n</tr>\n<tr>\n<td>incr key</td>\n<td>自增操作，值不是整数返回错误，键不存在按照 0 自增</td>\n</tr>\n<tr>\n<td>decr key</td>\n<td>自减操作</td>\n</tr>\n<tr>\n<td>incrby decrby incrbyfloat</td>\n<td>根据数值自增自减</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"字符串类型不常用命令\"><a href=\"#字符串类型不常用命令\" class=\"headerlink\" title=\"字符串类型不常用命令\"></a>字符串类型不常用命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>append key value</td>\n<td>追加值</td>\n</tr>\n<tr>\n<td>strlen key</td>\n<td>字符串长度</td>\n</tr>\n<tr>\n<td>getset key value</td>\n<td>设置并返回原值</td>\n</tr>\n<tr>\n<td>setrange key offset value</td>\n<td>设置指定位置的字符</td>\n</tr>\n<tr>\n<td>getrange key start end</td>\n<td>获取部分字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"字符串内部编码\"><a href=\"#字符串内部编码\" class=\"headerlink\" title=\"字符串内部编码\"></a>字符串内部编码</h4><ul>\n<li>int：8 个字节的长整型</li>\n<li>embstr：小于等于 39 个字节的字符串</li>\n<li>raw：大于 39 个字符的字符串</li>\n</ul>\n<h3 id=\"哈希\"><a href=\"#哈希\" class=\"headerlink\" title=\"哈希\"></a>哈希</h3><h4 id=\"哈希命令\"><a href=\"#哈希命令\" class=\"headerlink\" title=\"哈希命令\"></a>哈希命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hset key field value</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>hget key field</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>hdel key field [field …]</td>\n<td>删除field</td>\n</tr>\n<tr>\n<td>hlen key</td>\n<td>计算field 个数</td>\n</tr>\n<tr>\n<td>hmget key field [field …]</td>\n<td>批量获取field-value</td>\n</tr>\n<tr>\n<td>hmset key field value [field value …]</td>\n<td>批量设置field-value</td>\n</tr>\n<tr>\n<td>hexists key field</td>\n<td>判断field 是否存在</td>\n</tr>\n<tr>\n<td>hkeys key</td>\n<td>获取所有field</td>\n</tr>\n<tr>\n<td>hvals key</td>\n<td>获取所有value</td>\n</tr>\n<tr>\n<td>hgetall key</td>\n<td>获取所有的field-value</td>\n</tr>\n<tr>\n<td>hincrby hincrbyfloat key field</td>\n<td>field 自增</td>\n</tr>\n<tr>\n<td>hstrlen key field</td>\n<td>计算value 的字符串长度</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"内部编码\"><a href=\"#内部编码\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><ul>\n<li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有指都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。</li>\n<li>hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。</li>\n</ul>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"列表的两个特点：\"><a href=\"#列表的两个特点：\" class=\"headerlink\" title=\"列表的两个特点：\"></a>列表的两个特点：</h4><ul>\n<li>列表中的元素是有序的</li>\n<li>列表中的元素可以是重复的</li>\n</ul>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rpush lpush key value [value …]</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>linsert key (before after) pivot value</td>\n<td>插入</td>\n</tr>\n<tr>\n<td>lrange key start end</td>\n<td>查找</td>\n</tr>\n<tr>\n<td>lindex key index</td>\n<td>获取列表指定索引下表的元素</td>\n</tr>\n<tr>\n<td>llen key</td>\n<td>获取列表长度</td>\n</tr>\n<tr>\n<td>lpop rpop key</td>\n<td>弹出元素</td>\n</tr>\n<tr>\n<td>lrem key count value</td>\n<td>删除指定元素，count&gt;0，从左到右；count&lt;0从右到左 删除最多count个元素；count=0，删除所有</td>\n</tr>\n<tr>\n<td>ltrim key start end</td>\n<td>按照索引范围剪切列表</td>\n</tr>\n<tr>\n<td>lset key index newValue</td>\n<td>修改</td>\n</tr>\n<tr>\n<td>blpop brpop key [key …] timeout</td>\n<td>阻塞操作</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"内部编码-1\"><a href=\"#内部编码-1\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><ul>\n<li>ziplist</li>\n<li>linkedlist</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>消息队列</li>\n<li>文章列表</li>\n<li>lpush + lpop = Stack（栈）</li>\n<li>lpush + rpop = Queue（队列）</li>\n<li>lpush + ltrim = Capped Collection（有限集合）</li>\n<li>lpush + brpop = Message Queue（消息队列）</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。</p>\n<h4 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h4><p>集合内操作：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sadd key ele [ele …]</td>\n<td>添加元素</td>\n</tr>\n<tr>\n<td>srem key ele [ele …]</td>\n<td>删除元素</td>\n</tr>\n<tr>\n<td>scard key</td>\n<td>计算元素个数</td>\n</tr>\n<tr>\n<td>sismember key ele</td>\n<td>判断元素是否在集合中</td>\n</tr>\n<tr>\n<td>srandmember key [count:1]</td>\n<td>随机从集合返回指定个数元素</td>\n</tr>\n<tr>\n<td>spop key</td>\n<td>从集合随机弹出一个元素</td>\n</tr>\n<tr>\n<td>smember key</td>\n<td>获取所有元素</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>集合间操作：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sinter key [key …]</td>\n<td>求多个结合的交集</td>\n</tr>\n<tr>\n<td>suinon key [key …]</td>\n<td>求多个结合的并集</td>\n</tr>\n<tr>\n<td>sdiff key [key …]</td>\n<td>求多个集合的差集</td>\n</tr>\n<tr>\n<td>sinterstore sunionstore sdiffstore destination key [key …]</td>\n<td>将交集、并集、差集的结果保存</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。</p>\n<h4 id=\"内部编码-2\"><a href=\"#内部编码-2\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><ul>\n<li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现</li>\n<li>hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现</li>\n</ul>\n<h4 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>标签</li>\n</ul>\n<h3 id=\"有序集合\"><a href=\"#有序集合\" class=\"headerlink\" title=\"有序集合\"></a>有序集合</h3><p>  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。</p>\n<h4 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h4><p>集合内：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zadd key score memeber [score memeber …]</td>\n<td>添加成员</td>\n</tr>\n<tr>\n<td>zcard key</td>\n<td>计算成员个数</td>\n</tr>\n<tr>\n<td>zscore key member</td>\n<td>计算某个成员的分数</td>\n</tr>\n<tr>\n<td>zrank zrevrank key member</td>\n<td>计算成员的排名</td>\n</tr>\n<tr>\n<td>zrem key memeber [member …]</td>\n<td>删除成员</td>\n</tr>\n<tr>\n<td>zincrby key increment member</td>\n<td>增加成员的分数</td>\n</tr>\n<tr>\n<td>zrange zrevrange key start end [withscores]</td>\n<td>返回指定排名范围的成员</td>\n</tr>\n<tr>\n<td>zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count]</td>\n<td>返回指定分数范围的成员</td>\n</tr>\n<tr>\n<td>zcount key min max</td>\n<td>返回指定分数范围成员个数</td>\n</tr>\n<tr>\n<td>zremrangebyrank key start end</td>\n<td>删除指定排名内的升序元素</td>\n</tr>\n<tr>\n<td>zremrangebyscore key min max</td>\n<td>删除指定分数范围的成员</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis3.2为zadd添加了nx、xx、ch、incr 四个选项：</p>\n<ul>\n<li>nx：member 必须不存在才能设置成功，用于添加</li>\n<li>xx：member 必须存在才能设置成功，用于更新</li>\n<li>ch：返回此次操作后，有序集合元素和分数变化的个数</li>\n<li>incr：对score做增加，相当于zincrby</li>\n</ul>\n<p>集合间的操作</p>\n<ul>\n<li>交集：<br><code>zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><ul>\n<li>destination：交集计算结果保存在这个键</li>\n<li>numkeys：需要做交集计算键的个数</li>\n<li>key[key …]：需要做交集计算的键</li>\n<li>weights weight[weight …]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1</li>\n<li>aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum</li>\n</ul>\n</li>\n<li>并集：<br><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></li>\n</ul>\n<h4 id=\"内部编码-3\"><a href=\"#内部编码-3\" class=\"headerlink\" title=\"内部编码\"></a>内部编码</h4><ul>\n<li>ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现</li>\n<li>skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现</li>\n</ul>\n<h4 id=\"使用场景-2\"><a href=\"#使用场景-2\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>点赞数</li>\n<li>前十名</li>\n<li>用户分数</li>\n</ul>\n<h3 id=\"键管理\"><a href=\"#键管理\" class=\"headerlink\" title=\"键管理\"></a>键管理</h3><h4 id=\"单个键管理\"><a href=\"#单个键管理\" class=\"headerlink\" title=\"单个键管理\"></a>单个键管理</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rename key newkey</td>\n<td>键重命名</td>\n</tr>\n<tr>\n<td>renamenx key newkey</td>\n<td>newkey 不存在时重命名</td>\n</tr>\n<tr>\n<td>randomkey</td>\n<td>随机返回一个键</td>\n</tr>\n<tr>\n<td>expire key seconds</td>\n<td>键在seconds 秒后过期</td>\n</tr>\n<tr>\n<td>expireat key timestamp</td>\n<td>键在秒级时间戳timestamp 后过期</td>\n</tr>\n<tr>\n<td>pexpire key milliseconds</td>\n<td>键在milliseconds 毫秒后过期</td>\n</tr>\n<tr>\n<td>pexpireat key milliseconds-timestamp</td>\n<td>键在毫秒级时间戳timestamp 后过期</td>\n</tr>\n<tr>\n<td>move key db</td>\n<td>键内部迁移</td>\n</tr>\n<tr>\n<td>dump key</td>\n<td>键值序列化，采用RDB格式</td>\n</tr>\n<tr>\n<td>restore key ttl value</td>\n<td>反序列化键值</td>\n</tr>\n<tr>\n<td>migrate host port (key “”) destination-db timeout [copy] [replace] [keys key [key …]]</td>\n<td>Redis 实例间进行数据迁移</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Redis过期命令注意点：</p>\n<ul>\n<li>expire key的键不存在，返回结果为 0</li>\n<li>过期时间如果为负值，键会立即被删除</li>\n<li>persist 可以将键的过期时间清除</li>\n<li>对于字符串类型键，set 命令会去掉过期时间</li>\n<li>Redis 不支持二级数据结构内部元素的过期功能</li>\n<li>setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间</li>\n</ul>\n<p>migrate 参数：</p>\n<ul>\n<li>host：目标Redis 的IP地址</li>\n<li>port：目标Redis 的端口</li>\n<li>key|””：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”</li>\n<li>destination：目标Redis 的数据库索引</li>\n<li>timeout：迁移的超时时间（毫秒）</li>\n<li>[copy]：添加后，迁移不删除源键</li>\n<li>[replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖</li>\n<li>[keys key[key …]]：迁移多个键</li>\n</ul>\n<h4 id=\"遍历键\"><a href=\"#遍历键\" class=\"headerlink\" title=\"遍历键\"></a>遍历键</h4><ul>\n<li><code>keys pattern</code>：全量遍历键<br>keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：<ul>\n<li>在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制</li>\n<li>如果确认键值总数确实比较少，可以执行该命令</li>\n<li>使用scan 命令，可以有效防止阻塞</li>\n</ul>\n</li>\n<li><code>scan cursor [match pattern] [count number]</code>：渐进式遍历<ul>\n<li>curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束</li>\n<li>match pattern：可选参数，匹配正则</li>\n<li>count number：可选参数，每次要遍历的键个数，默认是 10</li>\n</ul>\n</li>\n</ul>\n<p>除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan</p>\n<h4 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>select dbIndex</td>\n<td>切换数据库，Redis默认配置中有16个数据库</td>\n</tr>\n<tr>\n<td>flushdb</td>\n<td>清除当前数据库</td>\n</tr>\n<tr>\n<td>flushall</td>\n<td>清除所有数据库</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>  <strong>注意</strong>：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：</p>\n<ul>\n<li>Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响</li>\n<li>多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库</li>\n<li>部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱</li>\n</ul>\n<h2 id=\"小功能大用处\"><a href=\"#小功能大用处\" class=\"headerlink\" title=\"小功能大用处\"></a>小功能大用处</h2><h3 id=\"慢查询分析\"><a href=\"#慢查询分析\" class=\"headerlink\" title=\"慢查询分析\"></a>慢查询分析</h3><p>Redis 提供了<code>slowlog-log-slower-than</code> 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config set slowlog-log-slower-than 20000</span><br><span class=\"line\">config set slowlog-max-len 1000</span><br><span class=\"line\">config rewrite</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取慢查询日志</span></span><br><span class=\"line\">slowlog get [n]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取慢查询日志列表当前的长度</span></span><br><span class=\"line\">slowlog len</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 慢查询日志重置</span></span><br><span class=\"line\">slowlog reset</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"redis-cli-详解\"><a href=\"#redis-cli-详解\" class=\"headerlink\" title=\"redis-cli 详解\"></a>redis-cli 详解</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-r</td>\n<td>命令执行多次</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>每隔几秒执行一次</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>从标准输入读取数据作为最后一个参数</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>连接Redis Cluster 节点时使用</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>Redis 配置了命令时使用</td>\n</tr>\n<tr>\n<td>—scan 和 —pattern</td>\n<td>用于扫描指定模式的键</td>\n</tr>\n<tr>\n<td>—slave</td>\n<td>把当前客户端模拟成当前Redis 节点的从节点</td>\n</tr>\n<tr>\n<td>—rdb</td>\n<td>请求Redis实例生成并发送RDB持久化文件保存到本地</td>\n</tr>\n<tr>\n<td>—pipe</td>\n<td>批量执行Redis 命令</td>\n</tr>\n<tr>\n<td>—bigkeys</td>\n<td>使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值</td>\n</tr>\n<tr>\n<td>—eval</td>\n<td>执行Lua 脚本</td>\n</tr>\n<tr>\n<td>—latency</td>\n<td>检测网络延迟</td>\n</tr>\n<tr>\n<td>—latency-history</td>\n<td>分时段了解延迟信息</td>\n</tr>\n<tr>\n<td>—latency-dist</td>\n<td>使用统计图表输出延迟统计信息</td>\n</tr>\n<tr>\n<td>—stat</td>\n<td>实时获取Redis 的重要统计信息</td>\n</tr>\n<tr>\n<td>—no-raw</td>\n<td>要求命令的返回结果必须是原始的格式</td>\n</tr>\n<tr>\n<td>—raw</td>\n<td>要求命令的返回结果是转换后的格式</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"redis-server-详解\"><a href=\"#redis-server-详解\" class=\"headerlink\" title=\"redis-server 详解\"></a>redis-server 详解</h3><p>参数 <code>--test-memory</code> 用来检测当前系统能否稳定的分配指定容量的内存给Redis</p>\n<h3 id=\"redis-benchmark-详解\"><a href=\"#redis-benchmark-详解\" class=\"headerlink\" title=\"redis-benchmark 详解\"></a>redis-benchmark 详解</h3><p>redis-benchmark 可以为Redis做基准性能测试</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>客户端的并发数（默认50）</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>客户端请求总量（默认100000）</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>插入随机的键做测试</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>每个请求pipeline 的数据量（默认1）</td>\n</tr>\n<tr>\n<td>-k</td>\n<td>是否使用keepalive，1为使用，0为不使用</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>对指定命令进行基准测试</td>\n</tr>\n<tr>\n<td>—csv</td>\n<td>将结果按照csv格式输出</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"Pipeline\"><a href=\"#Pipeline\" class=\"headerlink\" title=\"Pipeline\"></a>Pipeline</h3><p>有效节约RTT（Round Trip Time，往返时间）</p>\n<h3 id=\"事务与Lua\"><a href=\"#事务与Lua\" class=\"headerlink\" title=\"事务与Lua\"></a>事务与Lua</h3><p>Redis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。</p>\n<h4 id=\"不同错误下的处理机制\"><a href=\"#不同错误下的处理机制\" class=\"headerlink\" title=\"不同错误下的处理机制\"></a>不同错误下的处理机制</h4><ol>\n<li>命令错误：整个事务无法执行</li>\n<li>运行时异常：不支持回滚</li>\n</ol>\n<h4 id=\"Lua\"><a href=\"#Lua\" class=\"headerlink\" title=\"Lua\"></a>Lua</h4><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 没有local代表是全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> strings val = <span class=\"string\">\"world\"</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(val)</span><br><span class=\"line\"><span class=\"comment\">-- 表格，下标从 1 开始</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> tables myArray = &#123;<span class=\"string\">\"redis\"</span>, <span class=\"string\">\"jedis\"</span>, <span class=\"literal\">true</span>, <span class=\"number\">88.0</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myArray[<span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"comment\">-- for循环</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    sum = sum + i</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #myArray</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(myArray[i])</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- ipairs函数，返回索引下标和值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> index,value <span class=\"keyword\">in</span> <span class=\"built_in\">ipairs</span>(myArray)</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(index)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- while</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> int i = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt;= <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    sum = sum + <span class=\"number\">1</span></span><br><span class=\"line\">    i = i + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(sum)</span><br><span class=\"line\"><span class=\"comment\">-- if else</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, #myArray</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> myArray[i] == <span class=\"string\">\"jedis\"</span></span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"true\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">-- do nothing</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 哈希</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> tables user_1 = &#123;age = <span class=\"number\">28</span>, name = <span class=\"string\">\"tom\"</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"user_1 age is\"</span> .. user_1[<span class=\"string\">\"age\"</span>])</span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> <span class=\"built_in\">pairs</span>(user_1)</span><br><span class=\"line\"><span class=\"keyword\">do</span> <span class=\"built_in\">print</span>(key .. value)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">-- 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">contact</span><span class=\"params\">(str1, str2)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> str1 .. str2</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(contact(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"Redis中使用Lua\"><a href=\"#Redis中使用Lua\" class=\"headerlink\" title=\"Redis中使用Lua\"></a>Redis中使用Lua</h4><ul>\n<li>eval<br>Redis 中执行<code>eval script key_num keys args</code>:<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; eval 'return \"hello \" .. KEYS[1] .. ARGV[1]' 1 redis world</span><br></pre></td></tr></table></figure>\n如果Lua 脚本较长，可以使用redis-cli —eval 直接执行文件</li>\n<li>evalsha<br>首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli script load \"$(cat lua_get.lua)\"</span><br><span class=\"line\">evalsha sha1_value key_num keys args</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Lua的Redis-API\"><a href=\"#Lua的Redis-API\" class=\"headerlink\" title=\"Lua的Redis API\"></a>Lua的Redis API</h4><p>Lua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis.call(<span class=\"string\">\"set\"</span>, <span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>)</span><br><span class=\"line\">redis.call(<span class=\"string\">\"get\"</span>, <span class=\"string\">\"hello\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Redis-如何管理Lua脚本\"><a href=\"#Redis-如何管理Lua脚本\" class=\"headerlink\" title=\"Redis 如何管理Lua脚本\"></a>Redis 如何管理Lua脚本</h4><ul>\n<li><code>script load script</code>：将Lua 脚本加载到Redis内存中</li>\n<li><code>script exists sha1</code>：判断sha1 是否已经加载到Redis内存中</li>\n<li><code>script flush</code>：清除已经加载的所有Lua脚本</li>\n<li><code>script kill</code>：用于杀掉正在执行的Lua脚本，Redis 提供了<code>lua-time-limit</code> 参数，默认是 5 秒，但只是当Lua 脚本时间超过<code>lua-time-limit</code> 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，<code>script kill</code> 将不会生效，此时要么等待脚本结束要么使用 <code>shutdown save</code> 停掉Redis服务</li>\n</ul>\n<h3 id=\"Bitmaps\"><a href=\"#Bitmaps\" class=\"headerlink\" title=\"Bitmaps\"></a>Bitmaps</h3><ul>\n<li>Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作</li>\n<li>Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量</li>\n</ul>\n<h4 id=\"Bitmaps命令\"><a href=\"#Bitmaps命令\" class=\"headerlink\" title=\"Bitmaps命令\"></a>Bitmaps命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setbit key offset value</td>\n<td>设置值</td>\n</tr>\n<tr>\n<td>getbit key offset</td>\n<td>获取值</td>\n</tr>\n<tr>\n<td>bitcount [start] [end]</td>\n<td>获取Bitmaps 指定范围为 1 的个数</td>\n</tr>\n<tr>\n<td>bitop op destkey key[key …]</td>\n<td>Bitmaps间的运算: and、or、not、xor</td>\n</tr>\n<tr>\n<td>bitpos key targetBit [start] [end]</td>\n<td>计算Bitmaps中第一个值为targetBit的偏移量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"HyperLogLog\"><a href=\"#HyperLogLog\" class=\"headerlink\" title=\"HyperLogLog\"></a>HyperLogLog</h3><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pfadd key element [element …]</td>\n<td>添加</td>\n</tr>\n<tr>\n<td>pfcount key [key …]</td>\n<td>去重计数，存在一定误差</td>\n</tr>\n<tr>\n<td>pfmerge destkey sourcekey [sourcekey …]</td>\n<td>合并</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在选择HyperLogLog 时，需要确认两点：</p>\n<ul>\n<li>只是为了计算独立总数，不需要获取单条数据</li>\n<li>可以容忍一定误差</li>\n</ul>\n<h3 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>publish channel message</td>\n<td>发布消息</td>\n</tr>\n<tr>\n<td>subscribe channel [channel …]</td>\n<td>订阅消息</td>\n</tr>\n<tr>\n<td>unsubscribe [channel [channel …]]</td>\n<td>取消订阅</td>\n</tr>\n<tr>\n<td>psubscribe pattern [pattern …]</td>\n<td>按照模式订阅</td>\n</tr>\n<tr>\n<td>punsubscribe [pattern [pattern …]]</td>\n<td>按照模式取消订阅</td>\n</tr>\n<tr>\n<td>pubsub channels [pattern]</td>\n<td>查看活跃的频道</td>\n</tr>\n<tr>\n<td>pubsub numsub [channel …]</td>\n<td>查看频道订阅数</td>\n</tr>\n<tr>\n<td>pubsub numpat</td>\n<td>查看模式订阅数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>订阅命令的注意点：</p>\n<ul>\n<li>客户端执行订阅命令之后进入了了订阅状态，只能接收<code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>这四个命令</li>\n<li>新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化</li>\n</ul>\n<p>活跃的频道是指当前频道至少有一个订阅者</p>\n<h3 id=\"GEO（地理信息定位）\"><a href=\"#GEO（地理信息定位）\" class=\"headerlink\" title=\"GEO（地理信息定位）\"></a>GEO（地理信息定位）</h3><p>Redis3.2 版本提供了GEO功能。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>geoadd key longitude latitude member [longitude latitude memeber …]</td>\n<td>增加地理位置信息</td>\n</tr>\n<tr>\n<td>geopos key member [memeber …]</td>\n<td>获取地理位置信息</td>\n</tr>\n<tr>\n<td>geodist key member1 member2 [unit]</td>\n<td>获取两个地理位置的距离</td>\n</tr>\n<tr>\n<td>georadius key longitude latitude (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>\n<td>获取指定位置范围内的地理信息位置集合</td>\n</tr>\n<tr>\n<td>georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>\n<td>获取指定位置范围内的成员信息</td>\n</tr>\n<tr>\n<td>geohash key member [member …]</td>\n<td>获取geohash</td>\n</tr>\n<tr>\n<td>zrem key member</td>\n<td>删除地理位置信息</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>参数：</p>\n<ul>\n<li>withcoord：返回结果中包含经纬度</li>\n<li>withdist：返回结果中包含离中心节点位置的距离</li>\n<li>withhash：返回结果中包含geohash</li>\n<li>COUNT count：指定返回结果的数量</li>\n<li>asc|desc：返回结果按照离中心节点的距离做升序或者降序</li>\n<li>store key：将返回结果的地理位置信息保存到指定键</li>\n<li>storedist key: 将返回结果离中心节点的距离保存到指定键</li>\n</ul>\n<p><code>geohash</code>的特点：</p>\n<ul>\n<li>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中</li>\n<li>字符串越长，表示的位置更精确</li>\n<li>两个字符串越相似，它们之间的距离越近</li>\n<li>geohash编码和经纬度是可以互换的</li>\n</ul>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck9bzne4h0002hywi5uupgmlh","category_id":"ck9bzne4r0004hywi6vn13x8a","_id":"ck9bzne4y0007hywi8jbb8lpm"},{"post_id":"ck9bzne7r0009hywid5jp6gcc","category_id":"ck9bzne7s000ahywi9jso82id","_id":"ck9bzne7t000dhywibxgm9lbh"}],"PostTag":[{"post_id":"ck9bzne4h0002hywi5uupgmlh","tag_id":"ck9bzne4u0005hywi9u4bh285","_id":"ck9bzne4x0006hywi9avthzrq"},{"post_id":"ck9bzne7r0009hywid5jp6gcc","tag_id":"ck9bzne7s000bhywi49kp0sop","_id":"ck9bzne7t000chywi9pstgwoe"}],"Tag":[{"name":"算法","_id":"ck9bzne4u0005hywi9u4bh285"},{"name":"Redis","_id":"ck9bzne7s000bhywi49kp0sop"}]}}