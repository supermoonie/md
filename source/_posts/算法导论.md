---
title: 算法导论
date: 2020-04-20 17:41:44
tags: 算法
categories:
- 算法
---

## 第一部分 基础知识

### 第 2 章 算法基础

#### 2.1 插入排序

![algorithm_introduction_02](http://img.code4j.online/assets/algorithm_introduction_02.png)

<!-- more -->

#### 2.2 算法分析

- 运行时间：基本操作数或步数
- 最坏情况与平均情况分析
- 增长量级 

#### 2.3 设计算法

分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。

每层递归都有三个步骤：

1. 分解原问题为若干子问题
2. 解决这些子问题
3. 合并这些子问题的解成原问题的解

![algorithm_introduction_03](http://img.code4j.online/assets/algorithm_introduction_03.png)

### 第 3 章 函数的增长

### 第 4 章 分治策略

三种求解递归式的方法：
- 代入法：猜测一个界，然后用数学归纳法证明这个界是正确的
- 递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用产生的代价
- 主方法：可求解如下公式的递归式的界：
  $$
  T(n) = aT(n/b) + f(n)
  $$
  其中 $a \ge 1, b \gt 1, f(n)$ 是一个给定的函数。该公式刻画了这样的一个分治算法：生成 a 个子问题，每个子问题的规模是原问题规模的 1/b ，分解和合并步骤共花费时间为 $f(n)$ 。

#### 4.1 最大字数组问题
- 暴力求解算法
  两层for循环遍历每种可能的组合，时间复杂度为 $O(n^2)$ 
- 分治策略求解算法
  将数组划分为两个规模尽量一致的字数组，则最大字数组必然是一下三种情况：
  - 左字数组
  - 右字数组
  - 跨越中点的字数组

  ![algorithm_introduction_04](http://img.code4j.online/assets/algorithm_introduction_04.svg)

### 第 5 章 堆排序



![heap_sort](http://img.code4j.online/assets/heap_sort.svg)

#### 5.1 建堆：

1. 选取最后一个包含叶子结点的节点（n/2）
2. 从n/2, (n/2 - 1), (n/2 - 2) ... 依次遍历至根节点
3. 遍历的过程中与子节点进行比较，如果子节点大则进行交换并再次对此子节点进行堆调整

#### 5.2 堆排序

1. 建堆，使数组中的最大值位于根节点
2. 将根节点与最后一个节点互换位置并去除
3. 堆剩余的数组元素建堆
4. 重复2，3 直至剩下最后一个元素

#### 5.3 优先队列

参考Java的`PriorityQueue` 

### 第 6 章 快速排序



